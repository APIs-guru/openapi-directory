# coding: utf-8

"""
    Cloud Storage JSON API

    Stores and retrieves potentially large, immutable data objects.

    The version of the OpenAPI document: v1
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501

import warnings
from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
from typing import Any, Dict, List, Optional, Tuple, Union
from typing_extensions import Annotated

from pydantic import Field, StrictBool, StrictStr, field_validator
from typing import List, Optional
from typing_extensions import Annotated
from openapi_client.models.bulk_restore_objects_request import BulkRestoreObjectsRequest
from openapi_client.models.channel import Channel
from openapi_client.models.compose_request import ComposeRequest
from openapi_client.models.google_longrunning_operation import GoogleLongrunningOperation
from openapi_client.models.object import Object
from openapi_client.models.objects import Objects
from openapi_client.models.policy import Policy
from openapi_client.models.rewrite_response import RewriteResponse
from openapi_client.models.test_iam_permissions_response import TestIamPermissionsResponse

from openapi_client.api_client import ApiClient, RequestSerialized
from openapi_client.api_response import ApiResponse
from openapi_client.rest import RESTResponseType


class ObjectsApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client


    @validate_call
    def storage_objects_bulk_restore(
        self,
        bucket: Annotated[StrictStr, Field(description="Name of the bucket in which the object resides.")],
        alt: Annotated[Optional[StrictStr], Field(description="Data format for the response.")] = None,
        fields: Annotated[Optional[StrictStr], Field(description="Selector specifying which fields to include in a partial response.")] = None,
        key: Annotated[Optional[StrictStr], Field(description="API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.")] = None,
        oauth_token: Annotated[Optional[StrictStr], Field(description="OAuth 2.0 token for the current user.")] = None,
        pretty_print: Annotated[Optional[StrictBool], Field(description="Returns response with indentations and line breaks.")] = None,
        quota_user: Annotated[Optional[StrictStr], Field(description="An opaque string that represents a user for quota purposes. Must not exceed 40 characters.")] = None,
        upload_type: Annotated[Optional[StrictStr], Field(description="Upload protocol for media (e.g. \"media\", \"multipart\", \"resumable\").")] = None,
        user_ip: Annotated[Optional[StrictStr], Field(description="Deprecated. Please use quotaUser instead.")] = None,
        bulk_restore_objects_request: Optional[BulkRestoreObjectsRequest] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GoogleLongrunningOperation:
        """storage_objects_bulk_restore

        Initiates a long-running bulk restore operation on the specified bucket.

        :param bucket: Name of the bucket in which the object resides. (required)
        :type bucket: str
        :param alt: Data format for the response.
        :type alt: str
        :param fields: Selector specifying which fields to include in a partial response.
        :type fields: str
        :param key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :type key: str
        :param oauth_token: OAuth 2.0 token for the current user.
        :type oauth_token: str
        :param pretty_print: Returns response with indentations and line breaks.
        :type pretty_print: bool
        :param quota_user: An opaque string that represents a user for quota purposes. Must not exceed 40 characters.
        :type quota_user: str
        :param upload_type: Upload protocol for media (e.g. \"media\", \"multipart\", \"resumable\").
        :type upload_type: str
        :param user_ip: Deprecated. Please use quotaUser instead.
        :type user_ip: str
        :param bulk_restore_objects_request:
        :type bulk_restore_objects_request: BulkRestoreObjectsRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._storage_objects_bulk_restore_serialize(
            bucket=bucket,
            alt=alt,
            fields=fields,
            key=key,
            oauth_token=oauth_token,
            pretty_print=pretty_print,
            quota_user=quota_user,
            upload_type=upload_type,
            user_ip=user_ip,
            bulk_restore_objects_request=bulk_restore_objects_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GoogleLongrunningOperation",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def storage_objects_bulk_restore_with_http_info(
        self,
        bucket: Annotated[StrictStr, Field(description="Name of the bucket in which the object resides.")],
        alt: Annotated[Optional[StrictStr], Field(description="Data format for the response.")] = None,
        fields: Annotated[Optional[StrictStr], Field(description="Selector specifying which fields to include in a partial response.")] = None,
        key: Annotated[Optional[StrictStr], Field(description="API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.")] = None,
        oauth_token: Annotated[Optional[StrictStr], Field(description="OAuth 2.0 token for the current user.")] = None,
        pretty_print: Annotated[Optional[StrictBool], Field(description="Returns response with indentations and line breaks.")] = None,
        quota_user: Annotated[Optional[StrictStr], Field(description="An opaque string that represents a user for quota purposes. Must not exceed 40 characters.")] = None,
        upload_type: Annotated[Optional[StrictStr], Field(description="Upload protocol for media (e.g. \"media\", \"multipart\", \"resumable\").")] = None,
        user_ip: Annotated[Optional[StrictStr], Field(description="Deprecated. Please use quotaUser instead.")] = None,
        bulk_restore_objects_request: Optional[BulkRestoreObjectsRequest] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GoogleLongrunningOperation]:
        """storage_objects_bulk_restore

        Initiates a long-running bulk restore operation on the specified bucket.

        :param bucket: Name of the bucket in which the object resides. (required)
        :type bucket: str
        :param alt: Data format for the response.
        :type alt: str
        :param fields: Selector specifying which fields to include in a partial response.
        :type fields: str
        :param key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :type key: str
        :param oauth_token: OAuth 2.0 token for the current user.
        :type oauth_token: str
        :param pretty_print: Returns response with indentations and line breaks.
        :type pretty_print: bool
        :param quota_user: An opaque string that represents a user for quota purposes. Must not exceed 40 characters.
        :type quota_user: str
        :param upload_type: Upload protocol for media (e.g. \"media\", \"multipart\", \"resumable\").
        :type upload_type: str
        :param user_ip: Deprecated. Please use quotaUser instead.
        :type user_ip: str
        :param bulk_restore_objects_request:
        :type bulk_restore_objects_request: BulkRestoreObjectsRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._storage_objects_bulk_restore_serialize(
            bucket=bucket,
            alt=alt,
            fields=fields,
            key=key,
            oauth_token=oauth_token,
            pretty_print=pretty_print,
            quota_user=quota_user,
            upload_type=upload_type,
            user_ip=user_ip,
            bulk_restore_objects_request=bulk_restore_objects_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GoogleLongrunningOperation",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def storage_objects_bulk_restore_without_preload_content(
        self,
        bucket: Annotated[StrictStr, Field(description="Name of the bucket in which the object resides.")],
        alt: Annotated[Optional[StrictStr], Field(description="Data format for the response.")] = None,
        fields: Annotated[Optional[StrictStr], Field(description="Selector specifying which fields to include in a partial response.")] = None,
        key: Annotated[Optional[StrictStr], Field(description="API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.")] = None,
        oauth_token: Annotated[Optional[StrictStr], Field(description="OAuth 2.0 token for the current user.")] = None,
        pretty_print: Annotated[Optional[StrictBool], Field(description="Returns response with indentations and line breaks.")] = None,
        quota_user: Annotated[Optional[StrictStr], Field(description="An opaque string that represents a user for quota purposes. Must not exceed 40 characters.")] = None,
        upload_type: Annotated[Optional[StrictStr], Field(description="Upload protocol for media (e.g. \"media\", \"multipart\", \"resumable\").")] = None,
        user_ip: Annotated[Optional[StrictStr], Field(description="Deprecated. Please use quotaUser instead.")] = None,
        bulk_restore_objects_request: Optional[BulkRestoreObjectsRequest] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """storage_objects_bulk_restore

        Initiates a long-running bulk restore operation on the specified bucket.

        :param bucket: Name of the bucket in which the object resides. (required)
        :type bucket: str
        :param alt: Data format for the response.
        :type alt: str
        :param fields: Selector specifying which fields to include in a partial response.
        :type fields: str
        :param key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :type key: str
        :param oauth_token: OAuth 2.0 token for the current user.
        :type oauth_token: str
        :param pretty_print: Returns response with indentations and line breaks.
        :type pretty_print: bool
        :param quota_user: An opaque string that represents a user for quota purposes. Must not exceed 40 characters.
        :type quota_user: str
        :param upload_type: Upload protocol for media (e.g. \"media\", \"multipart\", \"resumable\").
        :type upload_type: str
        :param user_ip: Deprecated. Please use quotaUser instead.
        :type user_ip: str
        :param bulk_restore_objects_request:
        :type bulk_restore_objects_request: BulkRestoreObjectsRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._storage_objects_bulk_restore_serialize(
            bucket=bucket,
            alt=alt,
            fields=fields,
            key=key,
            oauth_token=oauth_token,
            pretty_print=pretty_print,
            quota_user=quota_user,
            upload_type=upload_type,
            user_ip=user_ip,
            bulk_restore_objects_request=bulk_restore_objects_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GoogleLongrunningOperation",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _storage_objects_bulk_restore_serialize(
        self,
        bucket,
        alt,
        fields,
        key,
        oauth_token,
        pretty_print,
        quota_user,
        upload_type,
        user_ip,
        bulk_restore_objects_request,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if bucket is not None:
            _path_params['bucket'] = bucket
        # process the query parameters
        if alt is not None:
            
            _query_params.append(('alt', alt))
            
        if fields is not None:
            
            _query_params.append(('fields', fields))
            
        if key is not None:
            
            _query_params.append(('key', key))
            
        if oauth_token is not None:
            
            _query_params.append(('oauth_token', oauth_token))
            
        if pretty_print is not None:
            
            _query_params.append(('prettyPrint', pretty_print))
            
        if quota_user is not None:
            
            _query_params.append(('quotaUser', quota_user))
            
        if upload_type is not None:
            
            _query_params.append(('uploadType', upload_type))
            
        if user_ip is not None:
            
            _query_params.append(('userIp', user_ip))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if bulk_restore_objects_request is not None:
            _body_params = bulk_restore_objects_request


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'Oauth2c', 
            'Oauth2'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/b/{bucket}/o/bulkRestore',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def storage_objects_compose(
        self,
        destination_bucket: Annotated[StrictStr, Field(description="Name of the bucket containing the source objects. The destination object is stored in this bucket.")],
        destination_object: Annotated[StrictStr, Field(description="Name of the new object. For information about how to URL encode object names to be path safe, see [Encoding URI Path Parts](https://cloud.google.com/storage/docs/request-endpoints#encoding).")],
        alt: Annotated[Optional[StrictStr], Field(description="Data format for the response.")] = None,
        fields: Annotated[Optional[StrictStr], Field(description="Selector specifying which fields to include in a partial response.")] = None,
        key: Annotated[Optional[StrictStr], Field(description="API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.")] = None,
        oauth_token: Annotated[Optional[StrictStr], Field(description="OAuth 2.0 token for the current user.")] = None,
        pretty_print: Annotated[Optional[StrictBool], Field(description="Returns response with indentations and line breaks.")] = None,
        quota_user: Annotated[Optional[StrictStr], Field(description="An opaque string that represents a user for quota purposes. Must not exceed 40 characters.")] = None,
        upload_type: Annotated[Optional[StrictStr], Field(description="Upload protocol for media (e.g. \"media\", \"multipart\", \"resumable\").")] = None,
        user_ip: Annotated[Optional[StrictStr], Field(description="Deprecated. Please use quotaUser instead.")] = None,
        destination_predefined_acl: Annotated[Optional[StrictStr], Field(description="Apply a predefined set of access controls to the destination object.")] = None,
        if_generation_match: Annotated[Optional[StrictStr], Field(description="Makes the operation conditional on whether the object's current generation matches the given value. Setting to 0 makes the operation succeed only if there are no live versions of the object.")] = None,
        if_metageneration_match: Annotated[Optional[StrictStr], Field(description="Makes the operation conditional on whether the object's current metageneration matches the given value.")] = None,
        kms_key_name: Annotated[Optional[StrictStr], Field(description="Resource name of the Cloud KMS key, of the form projects/my-project/locations/global/keyRings/my-kr/cryptoKeys/my-key, that will be used to encrypt the object. Overrides the object metadata's kms_key_name value, if any.")] = None,
        user_project: Annotated[Optional[StrictStr], Field(description="The project to be billed for this request. Required for Requester Pays buckets.")] = None,
        compose_request: Optional[ComposeRequest] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> Object:
        """storage_objects_compose

        Concatenates a list of existing objects into a new object in the same bucket.

        :param destination_bucket: Name of the bucket containing the source objects. The destination object is stored in this bucket. (required)
        :type destination_bucket: str
        :param destination_object: Name of the new object. For information about how to URL encode object names to be path safe, see [Encoding URI Path Parts](https://cloud.google.com/storage/docs/request-endpoints#encoding). (required)
        :type destination_object: str
        :param alt: Data format for the response.
        :type alt: str
        :param fields: Selector specifying which fields to include in a partial response.
        :type fields: str
        :param key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :type key: str
        :param oauth_token: OAuth 2.0 token for the current user.
        :type oauth_token: str
        :param pretty_print: Returns response with indentations and line breaks.
        :type pretty_print: bool
        :param quota_user: An opaque string that represents a user for quota purposes. Must not exceed 40 characters.
        :type quota_user: str
        :param upload_type: Upload protocol for media (e.g. \"media\", \"multipart\", \"resumable\").
        :type upload_type: str
        :param user_ip: Deprecated. Please use quotaUser instead.
        :type user_ip: str
        :param destination_predefined_acl: Apply a predefined set of access controls to the destination object.
        :type destination_predefined_acl: str
        :param if_generation_match: Makes the operation conditional on whether the object's current generation matches the given value. Setting to 0 makes the operation succeed only if there are no live versions of the object.
        :type if_generation_match: str
        :param if_metageneration_match: Makes the operation conditional on whether the object's current metageneration matches the given value.
        :type if_metageneration_match: str
        :param kms_key_name: Resource name of the Cloud KMS key, of the form projects/my-project/locations/global/keyRings/my-kr/cryptoKeys/my-key, that will be used to encrypt the object. Overrides the object metadata's kms_key_name value, if any.
        :type kms_key_name: str
        :param user_project: The project to be billed for this request. Required for Requester Pays buckets.
        :type user_project: str
        :param compose_request:
        :type compose_request: ComposeRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._storage_objects_compose_serialize(
            destination_bucket=destination_bucket,
            destination_object=destination_object,
            alt=alt,
            fields=fields,
            key=key,
            oauth_token=oauth_token,
            pretty_print=pretty_print,
            quota_user=quota_user,
            upload_type=upload_type,
            user_ip=user_ip,
            destination_predefined_acl=destination_predefined_acl,
            if_generation_match=if_generation_match,
            if_metageneration_match=if_metageneration_match,
            kms_key_name=kms_key_name,
            user_project=user_project,
            compose_request=compose_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def storage_objects_compose_with_http_info(
        self,
        destination_bucket: Annotated[StrictStr, Field(description="Name of the bucket containing the source objects. The destination object is stored in this bucket.")],
        destination_object: Annotated[StrictStr, Field(description="Name of the new object. For information about how to URL encode object names to be path safe, see [Encoding URI Path Parts](https://cloud.google.com/storage/docs/request-endpoints#encoding).")],
        alt: Annotated[Optional[StrictStr], Field(description="Data format for the response.")] = None,
        fields: Annotated[Optional[StrictStr], Field(description="Selector specifying which fields to include in a partial response.")] = None,
        key: Annotated[Optional[StrictStr], Field(description="API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.")] = None,
        oauth_token: Annotated[Optional[StrictStr], Field(description="OAuth 2.0 token for the current user.")] = None,
        pretty_print: Annotated[Optional[StrictBool], Field(description="Returns response with indentations and line breaks.")] = None,
        quota_user: Annotated[Optional[StrictStr], Field(description="An opaque string that represents a user for quota purposes. Must not exceed 40 characters.")] = None,
        upload_type: Annotated[Optional[StrictStr], Field(description="Upload protocol for media (e.g. \"media\", \"multipart\", \"resumable\").")] = None,
        user_ip: Annotated[Optional[StrictStr], Field(description="Deprecated. Please use quotaUser instead.")] = None,
        destination_predefined_acl: Annotated[Optional[StrictStr], Field(description="Apply a predefined set of access controls to the destination object.")] = None,
        if_generation_match: Annotated[Optional[StrictStr], Field(description="Makes the operation conditional on whether the object's current generation matches the given value. Setting to 0 makes the operation succeed only if there are no live versions of the object.")] = None,
        if_metageneration_match: Annotated[Optional[StrictStr], Field(description="Makes the operation conditional on whether the object's current metageneration matches the given value.")] = None,
        kms_key_name: Annotated[Optional[StrictStr], Field(description="Resource name of the Cloud KMS key, of the form projects/my-project/locations/global/keyRings/my-kr/cryptoKeys/my-key, that will be used to encrypt the object. Overrides the object metadata's kms_key_name value, if any.")] = None,
        user_project: Annotated[Optional[StrictStr], Field(description="The project to be billed for this request. Required for Requester Pays buckets.")] = None,
        compose_request: Optional[ComposeRequest] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[Object]:
        """storage_objects_compose

        Concatenates a list of existing objects into a new object in the same bucket.

        :param destination_bucket: Name of the bucket containing the source objects. The destination object is stored in this bucket. (required)
        :type destination_bucket: str
        :param destination_object: Name of the new object. For information about how to URL encode object names to be path safe, see [Encoding URI Path Parts](https://cloud.google.com/storage/docs/request-endpoints#encoding). (required)
        :type destination_object: str
        :param alt: Data format for the response.
        :type alt: str
        :param fields: Selector specifying which fields to include in a partial response.
        :type fields: str
        :param key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :type key: str
        :param oauth_token: OAuth 2.0 token for the current user.
        :type oauth_token: str
        :param pretty_print: Returns response with indentations and line breaks.
        :type pretty_print: bool
        :param quota_user: An opaque string that represents a user for quota purposes. Must not exceed 40 characters.
        :type quota_user: str
        :param upload_type: Upload protocol for media (e.g. \"media\", \"multipart\", \"resumable\").
        :type upload_type: str
        :param user_ip: Deprecated. Please use quotaUser instead.
        :type user_ip: str
        :param destination_predefined_acl: Apply a predefined set of access controls to the destination object.
        :type destination_predefined_acl: str
        :param if_generation_match: Makes the operation conditional on whether the object's current generation matches the given value. Setting to 0 makes the operation succeed only if there are no live versions of the object.
        :type if_generation_match: str
        :param if_metageneration_match: Makes the operation conditional on whether the object's current metageneration matches the given value.
        :type if_metageneration_match: str
        :param kms_key_name: Resource name of the Cloud KMS key, of the form projects/my-project/locations/global/keyRings/my-kr/cryptoKeys/my-key, that will be used to encrypt the object. Overrides the object metadata's kms_key_name value, if any.
        :type kms_key_name: str
        :param user_project: The project to be billed for this request. Required for Requester Pays buckets.
        :type user_project: str
        :param compose_request:
        :type compose_request: ComposeRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._storage_objects_compose_serialize(
            destination_bucket=destination_bucket,
            destination_object=destination_object,
            alt=alt,
            fields=fields,
            key=key,
            oauth_token=oauth_token,
            pretty_print=pretty_print,
            quota_user=quota_user,
            upload_type=upload_type,
            user_ip=user_ip,
            destination_predefined_acl=destination_predefined_acl,
            if_generation_match=if_generation_match,
            if_metageneration_match=if_metageneration_match,
            kms_key_name=kms_key_name,
            user_project=user_project,
            compose_request=compose_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def storage_objects_compose_without_preload_content(
        self,
        destination_bucket: Annotated[StrictStr, Field(description="Name of the bucket containing the source objects. The destination object is stored in this bucket.")],
        destination_object: Annotated[StrictStr, Field(description="Name of the new object. For information about how to URL encode object names to be path safe, see [Encoding URI Path Parts](https://cloud.google.com/storage/docs/request-endpoints#encoding).")],
        alt: Annotated[Optional[StrictStr], Field(description="Data format for the response.")] = None,
        fields: Annotated[Optional[StrictStr], Field(description="Selector specifying which fields to include in a partial response.")] = None,
        key: Annotated[Optional[StrictStr], Field(description="API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.")] = None,
        oauth_token: Annotated[Optional[StrictStr], Field(description="OAuth 2.0 token for the current user.")] = None,
        pretty_print: Annotated[Optional[StrictBool], Field(description="Returns response with indentations and line breaks.")] = None,
        quota_user: Annotated[Optional[StrictStr], Field(description="An opaque string that represents a user for quota purposes. Must not exceed 40 characters.")] = None,
        upload_type: Annotated[Optional[StrictStr], Field(description="Upload protocol for media (e.g. \"media\", \"multipart\", \"resumable\").")] = None,
        user_ip: Annotated[Optional[StrictStr], Field(description="Deprecated. Please use quotaUser instead.")] = None,
        destination_predefined_acl: Annotated[Optional[StrictStr], Field(description="Apply a predefined set of access controls to the destination object.")] = None,
        if_generation_match: Annotated[Optional[StrictStr], Field(description="Makes the operation conditional on whether the object's current generation matches the given value. Setting to 0 makes the operation succeed only if there are no live versions of the object.")] = None,
        if_metageneration_match: Annotated[Optional[StrictStr], Field(description="Makes the operation conditional on whether the object's current metageneration matches the given value.")] = None,
        kms_key_name: Annotated[Optional[StrictStr], Field(description="Resource name of the Cloud KMS key, of the form projects/my-project/locations/global/keyRings/my-kr/cryptoKeys/my-key, that will be used to encrypt the object. Overrides the object metadata's kms_key_name value, if any.")] = None,
        user_project: Annotated[Optional[StrictStr], Field(description="The project to be billed for this request. Required for Requester Pays buckets.")] = None,
        compose_request: Optional[ComposeRequest] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """storage_objects_compose

        Concatenates a list of existing objects into a new object in the same bucket.

        :param destination_bucket: Name of the bucket containing the source objects. The destination object is stored in this bucket. (required)
        :type destination_bucket: str
        :param destination_object: Name of the new object. For information about how to URL encode object names to be path safe, see [Encoding URI Path Parts](https://cloud.google.com/storage/docs/request-endpoints#encoding). (required)
        :type destination_object: str
        :param alt: Data format for the response.
        :type alt: str
        :param fields: Selector specifying which fields to include in a partial response.
        :type fields: str
        :param key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :type key: str
        :param oauth_token: OAuth 2.0 token for the current user.
        :type oauth_token: str
        :param pretty_print: Returns response with indentations and line breaks.
        :type pretty_print: bool
        :param quota_user: An opaque string that represents a user for quota purposes. Must not exceed 40 characters.
        :type quota_user: str
        :param upload_type: Upload protocol for media (e.g. \"media\", \"multipart\", \"resumable\").
        :type upload_type: str
        :param user_ip: Deprecated. Please use quotaUser instead.
        :type user_ip: str
        :param destination_predefined_acl: Apply a predefined set of access controls to the destination object.
        :type destination_predefined_acl: str
        :param if_generation_match: Makes the operation conditional on whether the object's current generation matches the given value. Setting to 0 makes the operation succeed only if there are no live versions of the object.
        :type if_generation_match: str
        :param if_metageneration_match: Makes the operation conditional on whether the object's current metageneration matches the given value.
        :type if_metageneration_match: str
        :param kms_key_name: Resource name of the Cloud KMS key, of the form projects/my-project/locations/global/keyRings/my-kr/cryptoKeys/my-key, that will be used to encrypt the object. Overrides the object metadata's kms_key_name value, if any.
        :type kms_key_name: str
        :param user_project: The project to be billed for this request. Required for Requester Pays buckets.
        :type user_project: str
        :param compose_request:
        :type compose_request: ComposeRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._storage_objects_compose_serialize(
            destination_bucket=destination_bucket,
            destination_object=destination_object,
            alt=alt,
            fields=fields,
            key=key,
            oauth_token=oauth_token,
            pretty_print=pretty_print,
            quota_user=quota_user,
            upload_type=upload_type,
            user_ip=user_ip,
            destination_predefined_acl=destination_predefined_acl,
            if_generation_match=if_generation_match,
            if_metageneration_match=if_metageneration_match,
            kms_key_name=kms_key_name,
            user_project=user_project,
            compose_request=compose_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _storage_objects_compose_serialize(
        self,
        destination_bucket,
        destination_object,
        alt,
        fields,
        key,
        oauth_token,
        pretty_print,
        quota_user,
        upload_type,
        user_ip,
        destination_predefined_acl,
        if_generation_match,
        if_metageneration_match,
        kms_key_name,
        user_project,
        compose_request,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if destination_bucket is not None:
            _path_params['destinationBucket'] = destination_bucket
        if destination_object is not None:
            _path_params['destinationObject'] = destination_object
        # process the query parameters
        if alt is not None:
            
            _query_params.append(('alt', alt))
            
        if fields is not None:
            
            _query_params.append(('fields', fields))
            
        if key is not None:
            
            _query_params.append(('key', key))
            
        if oauth_token is not None:
            
            _query_params.append(('oauth_token', oauth_token))
            
        if pretty_print is not None:
            
            _query_params.append(('prettyPrint', pretty_print))
            
        if quota_user is not None:
            
            _query_params.append(('quotaUser', quota_user))
            
        if upload_type is not None:
            
            _query_params.append(('uploadType', upload_type))
            
        if user_ip is not None:
            
            _query_params.append(('userIp', user_ip))
            
        if destination_predefined_acl is not None:
            
            _query_params.append(('destinationPredefinedAcl', destination_predefined_acl))
            
        if if_generation_match is not None:
            
            _query_params.append(('ifGenerationMatch', if_generation_match))
            
        if if_metageneration_match is not None:
            
            _query_params.append(('ifMetagenerationMatch', if_metageneration_match))
            
        if kms_key_name is not None:
            
            _query_params.append(('kmsKeyName', kms_key_name))
            
        if user_project is not None:
            
            _query_params.append(('userProject', user_project))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if compose_request is not None:
            _body_params = compose_request


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'Oauth2c', 
            'Oauth2'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/b/{destinationBucket}/o/{destinationObject}/compose',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def storage_objects_copy(
        self,
        source_bucket: Annotated[StrictStr, Field(description="Name of the bucket in which to find the source object.")],
        source_object: Annotated[StrictStr, Field(description="Name of the source object. For information about how to URL encode object names to be path safe, see [Encoding URI Path Parts](https://cloud.google.com/storage/docs/request-endpoints#encoding).")],
        destination_bucket: Annotated[StrictStr, Field(description="Name of the bucket in which to store the new object. Overrides the provided object metadata's bucket value, if any.For information about how to URL encode object names to be path safe, see [Encoding URI Path Parts](https://cloud.google.com/storage/docs/request-endpoints#encoding).")],
        destination_object: Annotated[StrictStr, Field(description="Name of the new object. Required when the object metadata is not otherwise provided. Overrides the object metadata's name value, if any.")],
        alt: Annotated[Optional[StrictStr], Field(description="Data format for the response.")] = None,
        fields: Annotated[Optional[StrictStr], Field(description="Selector specifying which fields to include in a partial response.")] = None,
        key: Annotated[Optional[StrictStr], Field(description="API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.")] = None,
        oauth_token: Annotated[Optional[StrictStr], Field(description="OAuth 2.0 token for the current user.")] = None,
        pretty_print: Annotated[Optional[StrictBool], Field(description="Returns response with indentations and line breaks.")] = None,
        quota_user: Annotated[Optional[StrictStr], Field(description="An opaque string that represents a user for quota purposes. Must not exceed 40 characters.")] = None,
        upload_type: Annotated[Optional[StrictStr], Field(description="Upload protocol for media (e.g. \"media\", \"multipart\", \"resumable\").")] = None,
        user_ip: Annotated[Optional[StrictStr], Field(description="Deprecated. Please use quotaUser instead.")] = None,
        destination_kms_key_name: Annotated[Optional[StrictStr], Field(description="Resource name of the Cloud KMS key, of the form projects/my-project/locations/global/keyRings/my-kr/cryptoKeys/my-key, that will be used to encrypt the object. Overrides the object metadata's kms_key_name value, if any.")] = None,
        destination_predefined_acl: Annotated[Optional[StrictStr], Field(description="Apply a predefined set of access controls to the destination object.")] = None,
        if_generation_match: Annotated[Optional[StrictStr], Field(description="Makes the operation conditional on whether the destination object's current generation matches the given value. Setting to 0 makes the operation succeed only if there are no live versions of the object.")] = None,
        if_generation_not_match: Annotated[Optional[StrictStr], Field(description="Makes the operation conditional on whether the destination object's current generation does not match the given value. If no live object exists, the precondition fails. Setting to 0 makes the operation succeed only if there is a live version of the object.")] = None,
        if_metageneration_match: Annotated[Optional[StrictStr], Field(description="Makes the operation conditional on whether the destination object's current metageneration matches the given value.")] = None,
        if_metageneration_not_match: Annotated[Optional[StrictStr], Field(description="Makes the operation conditional on whether the destination object's current metageneration does not match the given value.")] = None,
        if_source_generation_match: Annotated[Optional[StrictStr], Field(description="Makes the operation conditional on whether the source object's current generation matches the given value.")] = None,
        if_source_generation_not_match: Annotated[Optional[StrictStr], Field(description="Makes the operation conditional on whether the source object's current generation does not match the given value.")] = None,
        if_source_metageneration_match: Annotated[Optional[StrictStr], Field(description="Makes the operation conditional on whether the source object's current metageneration matches the given value.")] = None,
        if_source_metageneration_not_match: Annotated[Optional[StrictStr], Field(description="Makes the operation conditional on whether the source object's current metageneration does not match the given value.")] = None,
        projection: Annotated[Optional[StrictStr], Field(description="Set of properties to return. Defaults to noAcl, unless the object resource specifies the acl property, when it defaults to full.")] = None,
        source_generation: Annotated[Optional[StrictStr], Field(description="If present, selects a specific revision of the source object (as opposed to the latest version, the default).")] = None,
        user_project: Annotated[Optional[StrictStr], Field(description="The project to be billed for this request. Required for Requester Pays buckets.")] = None,
        object: Optional[Object] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> Object:
        """storage_objects_copy

        Copies a source object to a destination object. Optionally overrides metadata.

        :param source_bucket: Name of the bucket in which to find the source object. (required)
        :type source_bucket: str
        :param source_object: Name of the source object. For information about how to URL encode object names to be path safe, see [Encoding URI Path Parts](https://cloud.google.com/storage/docs/request-endpoints#encoding). (required)
        :type source_object: str
        :param destination_bucket: Name of the bucket in which to store the new object. Overrides the provided object metadata's bucket value, if any.For information about how to URL encode object names to be path safe, see [Encoding URI Path Parts](https://cloud.google.com/storage/docs/request-endpoints#encoding). (required)
        :type destination_bucket: str
        :param destination_object: Name of the new object. Required when the object metadata is not otherwise provided. Overrides the object metadata's name value, if any. (required)
        :type destination_object: str
        :param alt: Data format for the response.
        :type alt: str
        :param fields: Selector specifying which fields to include in a partial response.
        :type fields: str
        :param key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :type key: str
        :param oauth_token: OAuth 2.0 token for the current user.
        :type oauth_token: str
        :param pretty_print: Returns response with indentations and line breaks.
        :type pretty_print: bool
        :param quota_user: An opaque string that represents a user for quota purposes. Must not exceed 40 characters.
        :type quota_user: str
        :param upload_type: Upload protocol for media (e.g. \"media\", \"multipart\", \"resumable\").
        :type upload_type: str
        :param user_ip: Deprecated. Please use quotaUser instead.
        :type user_ip: str
        :param destination_kms_key_name: Resource name of the Cloud KMS key, of the form projects/my-project/locations/global/keyRings/my-kr/cryptoKeys/my-key, that will be used to encrypt the object. Overrides the object metadata's kms_key_name value, if any.
        :type destination_kms_key_name: str
        :param destination_predefined_acl: Apply a predefined set of access controls to the destination object.
        :type destination_predefined_acl: str
        :param if_generation_match: Makes the operation conditional on whether the destination object's current generation matches the given value. Setting to 0 makes the operation succeed only if there are no live versions of the object.
        :type if_generation_match: str
        :param if_generation_not_match: Makes the operation conditional on whether the destination object's current generation does not match the given value. If no live object exists, the precondition fails. Setting to 0 makes the operation succeed only if there is a live version of the object.
        :type if_generation_not_match: str
        :param if_metageneration_match: Makes the operation conditional on whether the destination object's current metageneration matches the given value.
        :type if_metageneration_match: str
        :param if_metageneration_not_match: Makes the operation conditional on whether the destination object's current metageneration does not match the given value.
        :type if_metageneration_not_match: str
        :param if_source_generation_match: Makes the operation conditional on whether the source object's current generation matches the given value.
        :type if_source_generation_match: str
        :param if_source_generation_not_match: Makes the operation conditional on whether the source object's current generation does not match the given value.
        :type if_source_generation_not_match: str
        :param if_source_metageneration_match: Makes the operation conditional on whether the source object's current metageneration matches the given value.
        :type if_source_metageneration_match: str
        :param if_source_metageneration_not_match: Makes the operation conditional on whether the source object's current metageneration does not match the given value.
        :type if_source_metageneration_not_match: str
        :param projection: Set of properties to return. Defaults to noAcl, unless the object resource specifies the acl property, when it defaults to full.
        :type projection: str
        :param source_generation: If present, selects a specific revision of the source object (as opposed to the latest version, the default).
        :type source_generation: str
        :param user_project: The project to be billed for this request. Required for Requester Pays buckets.
        :type user_project: str
        :param object:
        :type object: Object
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._storage_objects_copy_serialize(
            source_bucket=source_bucket,
            source_object=source_object,
            destination_bucket=destination_bucket,
            destination_object=destination_object,
            alt=alt,
            fields=fields,
            key=key,
            oauth_token=oauth_token,
            pretty_print=pretty_print,
            quota_user=quota_user,
            upload_type=upload_type,
            user_ip=user_ip,
            destination_kms_key_name=destination_kms_key_name,
            destination_predefined_acl=destination_predefined_acl,
            if_generation_match=if_generation_match,
            if_generation_not_match=if_generation_not_match,
            if_metageneration_match=if_metageneration_match,
            if_metageneration_not_match=if_metageneration_not_match,
            if_source_generation_match=if_source_generation_match,
            if_source_generation_not_match=if_source_generation_not_match,
            if_source_metageneration_match=if_source_metageneration_match,
            if_source_metageneration_not_match=if_source_metageneration_not_match,
            projection=projection,
            source_generation=source_generation,
            user_project=user_project,
            object=object,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def storage_objects_copy_with_http_info(
        self,
        source_bucket: Annotated[StrictStr, Field(description="Name of the bucket in which to find the source object.")],
        source_object: Annotated[StrictStr, Field(description="Name of the source object. For information about how to URL encode object names to be path safe, see [Encoding URI Path Parts](https://cloud.google.com/storage/docs/request-endpoints#encoding).")],
        destination_bucket: Annotated[StrictStr, Field(description="Name of the bucket in which to store the new object. Overrides the provided object metadata's bucket value, if any.For information about how to URL encode object names to be path safe, see [Encoding URI Path Parts](https://cloud.google.com/storage/docs/request-endpoints#encoding).")],
        destination_object: Annotated[StrictStr, Field(description="Name of the new object. Required when the object metadata is not otherwise provided. Overrides the object metadata's name value, if any.")],
        alt: Annotated[Optional[StrictStr], Field(description="Data format for the response.")] = None,
        fields: Annotated[Optional[StrictStr], Field(description="Selector specifying which fields to include in a partial response.")] = None,
        key: Annotated[Optional[StrictStr], Field(description="API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.")] = None,
        oauth_token: Annotated[Optional[StrictStr], Field(description="OAuth 2.0 token for the current user.")] = None,
        pretty_print: Annotated[Optional[StrictBool], Field(description="Returns response with indentations and line breaks.")] = None,
        quota_user: Annotated[Optional[StrictStr], Field(description="An opaque string that represents a user for quota purposes. Must not exceed 40 characters.")] = None,
        upload_type: Annotated[Optional[StrictStr], Field(description="Upload protocol for media (e.g. \"media\", \"multipart\", \"resumable\").")] = None,
        user_ip: Annotated[Optional[StrictStr], Field(description="Deprecated. Please use quotaUser instead.")] = None,
        destination_kms_key_name: Annotated[Optional[StrictStr], Field(description="Resource name of the Cloud KMS key, of the form projects/my-project/locations/global/keyRings/my-kr/cryptoKeys/my-key, that will be used to encrypt the object. Overrides the object metadata's kms_key_name value, if any.")] = None,
        destination_predefined_acl: Annotated[Optional[StrictStr], Field(description="Apply a predefined set of access controls to the destination object.")] = None,
        if_generation_match: Annotated[Optional[StrictStr], Field(description="Makes the operation conditional on whether the destination object's current generation matches the given value. Setting to 0 makes the operation succeed only if there are no live versions of the object.")] = None,
        if_generation_not_match: Annotated[Optional[StrictStr], Field(description="Makes the operation conditional on whether the destination object's current generation does not match the given value. If no live object exists, the precondition fails. Setting to 0 makes the operation succeed only if there is a live version of the object.")] = None,
        if_metageneration_match: Annotated[Optional[StrictStr], Field(description="Makes the operation conditional on whether the destination object's current metageneration matches the given value.")] = None,
        if_metageneration_not_match: Annotated[Optional[StrictStr], Field(description="Makes the operation conditional on whether the destination object's current metageneration does not match the given value.")] = None,
        if_source_generation_match: Annotated[Optional[StrictStr], Field(description="Makes the operation conditional on whether the source object's current generation matches the given value.")] = None,
        if_source_generation_not_match: Annotated[Optional[StrictStr], Field(description="Makes the operation conditional on whether the source object's current generation does not match the given value.")] = None,
        if_source_metageneration_match: Annotated[Optional[StrictStr], Field(description="Makes the operation conditional on whether the source object's current metageneration matches the given value.")] = None,
        if_source_metageneration_not_match: Annotated[Optional[StrictStr], Field(description="Makes the operation conditional on whether the source object's current metageneration does not match the given value.")] = None,
        projection: Annotated[Optional[StrictStr], Field(description="Set of properties to return. Defaults to noAcl, unless the object resource specifies the acl property, when it defaults to full.")] = None,
        source_generation: Annotated[Optional[StrictStr], Field(description="If present, selects a specific revision of the source object (as opposed to the latest version, the default).")] = None,
        user_project: Annotated[Optional[StrictStr], Field(description="The project to be billed for this request. Required for Requester Pays buckets.")] = None,
        object: Optional[Object] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[Object]:
        """storage_objects_copy

        Copies a source object to a destination object. Optionally overrides metadata.

        :param source_bucket: Name of the bucket in which to find the source object. (required)
        :type source_bucket: str
        :param source_object: Name of the source object. For information about how to URL encode object names to be path safe, see [Encoding URI Path Parts](https://cloud.google.com/storage/docs/request-endpoints#encoding). (required)
        :type source_object: str
        :param destination_bucket: Name of the bucket in which to store the new object. Overrides the provided object metadata's bucket value, if any.For information about how to URL encode object names to be path safe, see [Encoding URI Path Parts](https://cloud.google.com/storage/docs/request-endpoints#encoding). (required)
        :type destination_bucket: str
        :param destination_object: Name of the new object. Required when the object metadata is not otherwise provided. Overrides the object metadata's name value, if any. (required)
        :type destination_object: str
        :param alt: Data format for the response.
        :type alt: str
        :param fields: Selector specifying which fields to include in a partial response.
        :type fields: str
        :param key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :type key: str
        :param oauth_token: OAuth 2.0 token for the current user.
        :type oauth_token: str
        :param pretty_print: Returns response with indentations and line breaks.
        :type pretty_print: bool
        :param quota_user: An opaque string that represents a user for quota purposes. Must not exceed 40 characters.
        :type quota_user: str
        :param upload_type: Upload protocol for media (e.g. \"media\", \"multipart\", \"resumable\").
        :type upload_type: str
        :param user_ip: Deprecated. Please use quotaUser instead.
        :type user_ip: str
        :param destination_kms_key_name: Resource name of the Cloud KMS key, of the form projects/my-project/locations/global/keyRings/my-kr/cryptoKeys/my-key, that will be used to encrypt the object. Overrides the object metadata's kms_key_name value, if any.
        :type destination_kms_key_name: str
        :param destination_predefined_acl: Apply a predefined set of access controls to the destination object.
        :type destination_predefined_acl: str
        :param if_generation_match: Makes the operation conditional on whether the destination object's current generation matches the given value. Setting to 0 makes the operation succeed only if there are no live versions of the object.
        :type if_generation_match: str
        :param if_generation_not_match: Makes the operation conditional on whether the destination object's current generation does not match the given value. If no live object exists, the precondition fails. Setting to 0 makes the operation succeed only if there is a live version of the object.
        :type if_generation_not_match: str
        :param if_metageneration_match: Makes the operation conditional on whether the destination object's current metageneration matches the given value.
        :type if_metageneration_match: str
        :param if_metageneration_not_match: Makes the operation conditional on whether the destination object's current metageneration does not match the given value.
        :type if_metageneration_not_match: str
        :param if_source_generation_match: Makes the operation conditional on whether the source object's current generation matches the given value.
        :type if_source_generation_match: str
        :param if_source_generation_not_match: Makes the operation conditional on whether the source object's current generation does not match the given value.
        :type if_source_generation_not_match: str
        :param if_source_metageneration_match: Makes the operation conditional on whether the source object's current metageneration matches the given value.
        :type if_source_metageneration_match: str
        :param if_source_metageneration_not_match: Makes the operation conditional on whether the source object's current metageneration does not match the given value.
        :type if_source_metageneration_not_match: str
        :param projection: Set of properties to return. Defaults to noAcl, unless the object resource specifies the acl property, when it defaults to full.
        :type projection: str
        :param source_generation: If present, selects a specific revision of the source object (as opposed to the latest version, the default).
        :type source_generation: str
        :param user_project: The project to be billed for this request. Required for Requester Pays buckets.
        :type user_project: str
        :param object:
        :type object: Object
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._storage_objects_copy_serialize(
            source_bucket=source_bucket,
            source_object=source_object,
            destination_bucket=destination_bucket,
            destination_object=destination_object,
            alt=alt,
            fields=fields,
            key=key,
            oauth_token=oauth_token,
            pretty_print=pretty_print,
            quota_user=quota_user,
            upload_type=upload_type,
            user_ip=user_ip,
            destination_kms_key_name=destination_kms_key_name,
            destination_predefined_acl=destination_predefined_acl,
            if_generation_match=if_generation_match,
            if_generation_not_match=if_generation_not_match,
            if_metageneration_match=if_metageneration_match,
            if_metageneration_not_match=if_metageneration_not_match,
            if_source_generation_match=if_source_generation_match,
            if_source_generation_not_match=if_source_generation_not_match,
            if_source_metageneration_match=if_source_metageneration_match,
            if_source_metageneration_not_match=if_source_metageneration_not_match,
            projection=projection,
            source_generation=source_generation,
            user_project=user_project,
            object=object,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def storage_objects_copy_without_preload_content(
        self,
        source_bucket: Annotated[StrictStr, Field(description="Name of the bucket in which to find the source object.")],
        source_object: Annotated[StrictStr, Field(description="Name of the source object. For information about how to URL encode object names to be path safe, see [Encoding URI Path Parts](https://cloud.google.com/storage/docs/request-endpoints#encoding).")],
        destination_bucket: Annotated[StrictStr, Field(description="Name of the bucket in which to store the new object. Overrides the provided object metadata's bucket value, if any.For information about how to URL encode object names to be path safe, see [Encoding URI Path Parts](https://cloud.google.com/storage/docs/request-endpoints#encoding).")],
        destination_object: Annotated[StrictStr, Field(description="Name of the new object. Required when the object metadata is not otherwise provided. Overrides the object metadata's name value, if any.")],
        alt: Annotated[Optional[StrictStr], Field(description="Data format for the response.")] = None,
        fields: Annotated[Optional[StrictStr], Field(description="Selector specifying which fields to include in a partial response.")] = None,
        key: Annotated[Optional[StrictStr], Field(description="API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.")] = None,
        oauth_token: Annotated[Optional[StrictStr], Field(description="OAuth 2.0 token for the current user.")] = None,
        pretty_print: Annotated[Optional[StrictBool], Field(description="Returns response with indentations and line breaks.")] = None,
        quota_user: Annotated[Optional[StrictStr], Field(description="An opaque string that represents a user for quota purposes. Must not exceed 40 characters.")] = None,
        upload_type: Annotated[Optional[StrictStr], Field(description="Upload protocol for media (e.g. \"media\", \"multipart\", \"resumable\").")] = None,
        user_ip: Annotated[Optional[StrictStr], Field(description="Deprecated. Please use quotaUser instead.")] = None,
        destination_kms_key_name: Annotated[Optional[StrictStr], Field(description="Resource name of the Cloud KMS key, of the form projects/my-project/locations/global/keyRings/my-kr/cryptoKeys/my-key, that will be used to encrypt the object. Overrides the object metadata's kms_key_name value, if any.")] = None,
        destination_predefined_acl: Annotated[Optional[StrictStr], Field(description="Apply a predefined set of access controls to the destination object.")] = None,
        if_generation_match: Annotated[Optional[StrictStr], Field(description="Makes the operation conditional on whether the destination object's current generation matches the given value. Setting to 0 makes the operation succeed only if there are no live versions of the object.")] = None,
        if_generation_not_match: Annotated[Optional[StrictStr], Field(description="Makes the operation conditional on whether the destination object's current generation does not match the given value. If no live object exists, the precondition fails. Setting to 0 makes the operation succeed only if there is a live version of the object.")] = None,
        if_metageneration_match: Annotated[Optional[StrictStr], Field(description="Makes the operation conditional on whether the destination object's current metageneration matches the given value.")] = None,
        if_metageneration_not_match: Annotated[Optional[StrictStr], Field(description="Makes the operation conditional on whether the destination object's current metageneration does not match the given value.")] = None,
        if_source_generation_match: Annotated[Optional[StrictStr], Field(description="Makes the operation conditional on whether the source object's current generation matches the given value.")] = None,
        if_source_generation_not_match: Annotated[Optional[StrictStr], Field(description="Makes the operation conditional on whether the source object's current generation does not match the given value.")] = None,
        if_source_metageneration_match: Annotated[Optional[StrictStr], Field(description="Makes the operation conditional on whether the source object's current metageneration matches the given value.")] = None,
        if_source_metageneration_not_match: Annotated[Optional[StrictStr], Field(description="Makes the operation conditional on whether the source object's current metageneration does not match the given value.")] = None,
        projection: Annotated[Optional[StrictStr], Field(description="Set of properties to return. Defaults to noAcl, unless the object resource specifies the acl property, when it defaults to full.")] = None,
        source_generation: Annotated[Optional[StrictStr], Field(description="If present, selects a specific revision of the source object (as opposed to the latest version, the default).")] = None,
        user_project: Annotated[Optional[StrictStr], Field(description="The project to be billed for this request. Required for Requester Pays buckets.")] = None,
        object: Optional[Object] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """storage_objects_copy

        Copies a source object to a destination object. Optionally overrides metadata.

        :param source_bucket: Name of the bucket in which to find the source object. (required)
        :type source_bucket: str
        :param source_object: Name of the source object. For information about how to URL encode object names to be path safe, see [Encoding URI Path Parts](https://cloud.google.com/storage/docs/request-endpoints#encoding). (required)
        :type source_object: str
        :param destination_bucket: Name of the bucket in which to store the new object. Overrides the provided object metadata's bucket value, if any.For information about how to URL encode object names to be path safe, see [Encoding URI Path Parts](https://cloud.google.com/storage/docs/request-endpoints#encoding). (required)
        :type destination_bucket: str
        :param destination_object: Name of the new object. Required when the object metadata is not otherwise provided. Overrides the object metadata's name value, if any. (required)
        :type destination_object: str
        :param alt: Data format for the response.
        :type alt: str
        :param fields: Selector specifying which fields to include in a partial response.
        :type fields: str
        :param key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :type key: str
        :param oauth_token: OAuth 2.0 token for the current user.
        :type oauth_token: str
        :param pretty_print: Returns response with indentations and line breaks.
        :type pretty_print: bool
        :param quota_user: An opaque string that represents a user for quota purposes. Must not exceed 40 characters.
        :type quota_user: str
        :param upload_type: Upload protocol for media (e.g. \"media\", \"multipart\", \"resumable\").
        :type upload_type: str
        :param user_ip: Deprecated. Please use quotaUser instead.
        :type user_ip: str
        :param destination_kms_key_name: Resource name of the Cloud KMS key, of the form projects/my-project/locations/global/keyRings/my-kr/cryptoKeys/my-key, that will be used to encrypt the object. Overrides the object metadata's kms_key_name value, if any.
        :type destination_kms_key_name: str
        :param destination_predefined_acl: Apply a predefined set of access controls to the destination object.
        :type destination_predefined_acl: str
        :param if_generation_match: Makes the operation conditional on whether the destination object's current generation matches the given value. Setting to 0 makes the operation succeed only if there are no live versions of the object.
        :type if_generation_match: str
        :param if_generation_not_match: Makes the operation conditional on whether the destination object's current generation does not match the given value. If no live object exists, the precondition fails. Setting to 0 makes the operation succeed only if there is a live version of the object.
        :type if_generation_not_match: str
        :param if_metageneration_match: Makes the operation conditional on whether the destination object's current metageneration matches the given value.
        :type if_metageneration_match: str
        :param if_metageneration_not_match: Makes the operation conditional on whether the destination object's current metageneration does not match the given value.
        :type if_metageneration_not_match: str
        :param if_source_generation_match: Makes the operation conditional on whether the source object's current generation matches the given value.
        :type if_source_generation_match: str
        :param if_source_generation_not_match: Makes the operation conditional on whether the source object's current generation does not match the given value.
        :type if_source_generation_not_match: str
        :param if_source_metageneration_match: Makes the operation conditional on whether the source object's current metageneration matches the given value.
        :type if_source_metageneration_match: str
        :param if_source_metageneration_not_match: Makes the operation conditional on whether the source object's current metageneration does not match the given value.
        :type if_source_metageneration_not_match: str
        :param projection: Set of properties to return. Defaults to noAcl, unless the object resource specifies the acl property, when it defaults to full.
        :type projection: str
        :param source_generation: If present, selects a specific revision of the source object (as opposed to the latest version, the default).
        :type source_generation: str
        :param user_project: The project to be billed for this request. Required for Requester Pays buckets.
        :type user_project: str
        :param object:
        :type object: Object
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._storage_objects_copy_serialize(
            source_bucket=source_bucket,
            source_object=source_object,
            destination_bucket=destination_bucket,
            destination_object=destination_object,
            alt=alt,
            fields=fields,
            key=key,
            oauth_token=oauth_token,
            pretty_print=pretty_print,
            quota_user=quota_user,
            upload_type=upload_type,
            user_ip=user_ip,
            destination_kms_key_name=destination_kms_key_name,
            destination_predefined_acl=destination_predefined_acl,
            if_generation_match=if_generation_match,
            if_generation_not_match=if_generation_not_match,
            if_metageneration_match=if_metageneration_match,
            if_metageneration_not_match=if_metageneration_not_match,
            if_source_generation_match=if_source_generation_match,
            if_source_generation_not_match=if_source_generation_not_match,
            if_source_metageneration_match=if_source_metageneration_match,
            if_source_metageneration_not_match=if_source_metageneration_not_match,
            projection=projection,
            source_generation=source_generation,
            user_project=user_project,
            object=object,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _storage_objects_copy_serialize(
        self,
        source_bucket,
        source_object,
        destination_bucket,
        destination_object,
        alt,
        fields,
        key,
        oauth_token,
        pretty_print,
        quota_user,
        upload_type,
        user_ip,
        destination_kms_key_name,
        destination_predefined_acl,
        if_generation_match,
        if_generation_not_match,
        if_metageneration_match,
        if_metageneration_not_match,
        if_source_generation_match,
        if_source_generation_not_match,
        if_source_metageneration_match,
        if_source_metageneration_not_match,
        projection,
        source_generation,
        user_project,
        object,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if source_bucket is not None:
            _path_params['sourceBucket'] = source_bucket
        if source_object is not None:
            _path_params['sourceObject'] = source_object
        if destination_bucket is not None:
            _path_params['destinationBucket'] = destination_bucket
        if destination_object is not None:
            _path_params['destinationObject'] = destination_object
        # process the query parameters
        if alt is not None:
            
            _query_params.append(('alt', alt))
            
        if fields is not None:
            
            _query_params.append(('fields', fields))
            
        if key is not None:
            
            _query_params.append(('key', key))
            
        if oauth_token is not None:
            
            _query_params.append(('oauth_token', oauth_token))
            
        if pretty_print is not None:
            
            _query_params.append(('prettyPrint', pretty_print))
            
        if quota_user is not None:
            
            _query_params.append(('quotaUser', quota_user))
            
        if upload_type is not None:
            
            _query_params.append(('uploadType', upload_type))
            
        if user_ip is not None:
            
            _query_params.append(('userIp', user_ip))
            
        if destination_kms_key_name is not None:
            
            _query_params.append(('destinationKmsKeyName', destination_kms_key_name))
            
        if destination_predefined_acl is not None:
            
            _query_params.append(('destinationPredefinedAcl', destination_predefined_acl))
            
        if if_generation_match is not None:
            
            _query_params.append(('ifGenerationMatch', if_generation_match))
            
        if if_generation_not_match is not None:
            
            _query_params.append(('ifGenerationNotMatch', if_generation_not_match))
            
        if if_metageneration_match is not None:
            
            _query_params.append(('ifMetagenerationMatch', if_metageneration_match))
            
        if if_metageneration_not_match is not None:
            
            _query_params.append(('ifMetagenerationNotMatch', if_metageneration_not_match))
            
        if if_source_generation_match is not None:
            
            _query_params.append(('ifSourceGenerationMatch', if_source_generation_match))
            
        if if_source_generation_not_match is not None:
            
            _query_params.append(('ifSourceGenerationNotMatch', if_source_generation_not_match))
            
        if if_source_metageneration_match is not None:
            
            _query_params.append(('ifSourceMetagenerationMatch', if_source_metageneration_match))
            
        if if_source_metageneration_not_match is not None:
            
            _query_params.append(('ifSourceMetagenerationNotMatch', if_source_metageneration_not_match))
            
        if projection is not None:
            
            _query_params.append(('projection', projection))
            
        if source_generation is not None:
            
            _query_params.append(('sourceGeneration', source_generation))
            
        if user_project is not None:
            
            _query_params.append(('userProject', user_project))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if object is not None:
            _body_params = object


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'Oauth2c', 
            'Oauth2'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/b/{sourceBucket}/o/{sourceObject}/copyTo/b/{destinationBucket}/o/{destinationObject}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def storage_objects_delete(
        self,
        bucket: Annotated[StrictStr, Field(description="Name of the bucket in which the object resides.")],
        object: Annotated[StrictStr, Field(description="Name of the object. For information about how to URL encode object names to be path safe, see [Encoding URI Path Parts](https://cloud.google.com/storage/docs/request-endpoints#encoding).")],
        alt: Annotated[Optional[StrictStr], Field(description="Data format for the response.")] = None,
        fields: Annotated[Optional[StrictStr], Field(description="Selector specifying which fields to include in a partial response.")] = None,
        key: Annotated[Optional[StrictStr], Field(description="API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.")] = None,
        oauth_token: Annotated[Optional[StrictStr], Field(description="OAuth 2.0 token for the current user.")] = None,
        pretty_print: Annotated[Optional[StrictBool], Field(description="Returns response with indentations and line breaks.")] = None,
        quota_user: Annotated[Optional[StrictStr], Field(description="An opaque string that represents a user for quota purposes. Must not exceed 40 characters.")] = None,
        upload_type: Annotated[Optional[StrictStr], Field(description="Upload protocol for media (e.g. \"media\", \"multipart\", \"resumable\").")] = None,
        user_ip: Annotated[Optional[StrictStr], Field(description="Deprecated. Please use quotaUser instead.")] = None,
        generation: Annotated[Optional[StrictStr], Field(description="If present, permanently deletes a specific revision of this object (as opposed to the latest version, the default).")] = None,
        if_generation_match: Annotated[Optional[StrictStr], Field(description="Makes the operation conditional on whether the object's current generation matches the given value. Setting to 0 makes the operation succeed only if there are no live versions of the object.")] = None,
        if_generation_not_match: Annotated[Optional[StrictStr], Field(description="Makes the operation conditional on whether the object's current generation does not match the given value. If no live object exists, the precondition fails. Setting to 0 makes the operation succeed only if there is a live version of the object.")] = None,
        if_metageneration_match: Annotated[Optional[StrictStr], Field(description="Makes the operation conditional on whether the object's current metageneration matches the given value.")] = None,
        if_metageneration_not_match: Annotated[Optional[StrictStr], Field(description="Makes the operation conditional on whether the object's current metageneration does not match the given value.")] = None,
        user_project: Annotated[Optional[StrictStr], Field(description="The project to be billed for this request. Required for Requester Pays buckets.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """storage_objects_delete

        Deletes an object and its metadata. Deletions are permanent if versioning is not enabled for the bucket, or if the generation parameter is used.

        :param bucket: Name of the bucket in which the object resides. (required)
        :type bucket: str
        :param object: Name of the object. For information about how to URL encode object names to be path safe, see [Encoding URI Path Parts](https://cloud.google.com/storage/docs/request-endpoints#encoding). (required)
        :type object: str
        :param alt: Data format for the response.
        :type alt: str
        :param fields: Selector specifying which fields to include in a partial response.
        :type fields: str
        :param key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :type key: str
        :param oauth_token: OAuth 2.0 token for the current user.
        :type oauth_token: str
        :param pretty_print: Returns response with indentations and line breaks.
        :type pretty_print: bool
        :param quota_user: An opaque string that represents a user for quota purposes. Must not exceed 40 characters.
        :type quota_user: str
        :param upload_type: Upload protocol for media (e.g. \"media\", \"multipart\", \"resumable\").
        :type upload_type: str
        :param user_ip: Deprecated. Please use quotaUser instead.
        :type user_ip: str
        :param generation: If present, permanently deletes a specific revision of this object (as opposed to the latest version, the default).
        :type generation: str
        :param if_generation_match: Makes the operation conditional on whether the object's current generation matches the given value. Setting to 0 makes the operation succeed only if there are no live versions of the object.
        :type if_generation_match: str
        :param if_generation_not_match: Makes the operation conditional on whether the object's current generation does not match the given value. If no live object exists, the precondition fails. Setting to 0 makes the operation succeed only if there is a live version of the object.
        :type if_generation_not_match: str
        :param if_metageneration_match: Makes the operation conditional on whether the object's current metageneration matches the given value.
        :type if_metageneration_match: str
        :param if_metageneration_not_match: Makes the operation conditional on whether the object's current metageneration does not match the given value.
        :type if_metageneration_not_match: str
        :param user_project: The project to be billed for this request. Required for Requester Pays buckets.
        :type user_project: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._storage_objects_delete_serialize(
            bucket=bucket,
            object=object,
            alt=alt,
            fields=fields,
            key=key,
            oauth_token=oauth_token,
            pretty_print=pretty_print,
            quota_user=quota_user,
            upload_type=upload_type,
            user_ip=user_ip,
            generation=generation,
            if_generation_match=if_generation_match,
            if_generation_not_match=if_generation_not_match,
            if_metageneration_match=if_metageneration_match,
            if_metageneration_not_match=if_metageneration_not_match,
            user_project=user_project,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def storage_objects_delete_with_http_info(
        self,
        bucket: Annotated[StrictStr, Field(description="Name of the bucket in which the object resides.")],
        object: Annotated[StrictStr, Field(description="Name of the object. For information about how to URL encode object names to be path safe, see [Encoding URI Path Parts](https://cloud.google.com/storage/docs/request-endpoints#encoding).")],
        alt: Annotated[Optional[StrictStr], Field(description="Data format for the response.")] = None,
        fields: Annotated[Optional[StrictStr], Field(description="Selector specifying which fields to include in a partial response.")] = None,
        key: Annotated[Optional[StrictStr], Field(description="API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.")] = None,
        oauth_token: Annotated[Optional[StrictStr], Field(description="OAuth 2.0 token for the current user.")] = None,
        pretty_print: Annotated[Optional[StrictBool], Field(description="Returns response with indentations and line breaks.")] = None,
        quota_user: Annotated[Optional[StrictStr], Field(description="An opaque string that represents a user for quota purposes. Must not exceed 40 characters.")] = None,
        upload_type: Annotated[Optional[StrictStr], Field(description="Upload protocol for media (e.g. \"media\", \"multipart\", \"resumable\").")] = None,
        user_ip: Annotated[Optional[StrictStr], Field(description="Deprecated. Please use quotaUser instead.")] = None,
        generation: Annotated[Optional[StrictStr], Field(description="If present, permanently deletes a specific revision of this object (as opposed to the latest version, the default).")] = None,
        if_generation_match: Annotated[Optional[StrictStr], Field(description="Makes the operation conditional on whether the object's current generation matches the given value. Setting to 0 makes the operation succeed only if there are no live versions of the object.")] = None,
        if_generation_not_match: Annotated[Optional[StrictStr], Field(description="Makes the operation conditional on whether the object's current generation does not match the given value. If no live object exists, the precondition fails. Setting to 0 makes the operation succeed only if there is a live version of the object.")] = None,
        if_metageneration_match: Annotated[Optional[StrictStr], Field(description="Makes the operation conditional on whether the object's current metageneration matches the given value.")] = None,
        if_metageneration_not_match: Annotated[Optional[StrictStr], Field(description="Makes the operation conditional on whether the object's current metageneration does not match the given value.")] = None,
        user_project: Annotated[Optional[StrictStr], Field(description="The project to be billed for this request. Required for Requester Pays buckets.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """storage_objects_delete

        Deletes an object and its metadata. Deletions are permanent if versioning is not enabled for the bucket, or if the generation parameter is used.

        :param bucket: Name of the bucket in which the object resides. (required)
        :type bucket: str
        :param object: Name of the object. For information about how to URL encode object names to be path safe, see [Encoding URI Path Parts](https://cloud.google.com/storage/docs/request-endpoints#encoding). (required)
        :type object: str
        :param alt: Data format for the response.
        :type alt: str
        :param fields: Selector specifying which fields to include in a partial response.
        :type fields: str
        :param key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :type key: str
        :param oauth_token: OAuth 2.0 token for the current user.
        :type oauth_token: str
        :param pretty_print: Returns response with indentations and line breaks.
        :type pretty_print: bool
        :param quota_user: An opaque string that represents a user for quota purposes. Must not exceed 40 characters.
        :type quota_user: str
        :param upload_type: Upload protocol for media (e.g. \"media\", \"multipart\", \"resumable\").
        :type upload_type: str
        :param user_ip: Deprecated. Please use quotaUser instead.
        :type user_ip: str
        :param generation: If present, permanently deletes a specific revision of this object (as opposed to the latest version, the default).
        :type generation: str
        :param if_generation_match: Makes the operation conditional on whether the object's current generation matches the given value. Setting to 0 makes the operation succeed only if there are no live versions of the object.
        :type if_generation_match: str
        :param if_generation_not_match: Makes the operation conditional on whether the object's current generation does not match the given value. If no live object exists, the precondition fails. Setting to 0 makes the operation succeed only if there is a live version of the object.
        :type if_generation_not_match: str
        :param if_metageneration_match: Makes the operation conditional on whether the object's current metageneration matches the given value.
        :type if_metageneration_match: str
        :param if_metageneration_not_match: Makes the operation conditional on whether the object's current metageneration does not match the given value.
        :type if_metageneration_not_match: str
        :param user_project: The project to be billed for this request. Required for Requester Pays buckets.
        :type user_project: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._storage_objects_delete_serialize(
            bucket=bucket,
            object=object,
            alt=alt,
            fields=fields,
            key=key,
            oauth_token=oauth_token,
            pretty_print=pretty_print,
            quota_user=quota_user,
            upload_type=upload_type,
            user_ip=user_ip,
            generation=generation,
            if_generation_match=if_generation_match,
            if_generation_not_match=if_generation_not_match,
            if_metageneration_match=if_metageneration_match,
            if_metageneration_not_match=if_metageneration_not_match,
            user_project=user_project,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def storage_objects_delete_without_preload_content(
        self,
        bucket: Annotated[StrictStr, Field(description="Name of the bucket in which the object resides.")],
        object: Annotated[StrictStr, Field(description="Name of the object. For information about how to URL encode object names to be path safe, see [Encoding URI Path Parts](https://cloud.google.com/storage/docs/request-endpoints#encoding).")],
        alt: Annotated[Optional[StrictStr], Field(description="Data format for the response.")] = None,
        fields: Annotated[Optional[StrictStr], Field(description="Selector specifying which fields to include in a partial response.")] = None,
        key: Annotated[Optional[StrictStr], Field(description="API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.")] = None,
        oauth_token: Annotated[Optional[StrictStr], Field(description="OAuth 2.0 token for the current user.")] = None,
        pretty_print: Annotated[Optional[StrictBool], Field(description="Returns response with indentations and line breaks.")] = None,
        quota_user: Annotated[Optional[StrictStr], Field(description="An opaque string that represents a user for quota purposes. Must not exceed 40 characters.")] = None,
        upload_type: Annotated[Optional[StrictStr], Field(description="Upload protocol for media (e.g. \"media\", \"multipart\", \"resumable\").")] = None,
        user_ip: Annotated[Optional[StrictStr], Field(description="Deprecated. Please use quotaUser instead.")] = None,
        generation: Annotated[Optional[StrictStr], Field(description="If present, permanently deletes a specific revision of this object (as opposed to the latest version, the default).")] = None,
        if_generation_match: Annotated[Optional[StrictStr], Field(description="Makes the operation conditional on whether the object's current generation matches the given value. Setting to 0 makes the operation succeed only if there are no live versions of the object.")] = None,
        if_generation_not_match: Annotated[Optional[StrictStr], Field(description="Makes the operation conditional on whether the object's current generation does not match the given value. If no live object exists, the precondition fails. Setting to 0 makes the operation succeed only if there is a live version of the object.")] = None,
        if_metageneration_match: Annotated[Optional[StrictStr], Field(description="Makes the operation conditional on whether the object's current metageneration matches the given value.")] = None,
        if_metageneration_not_match: Annotated[Optional[StrictStr], Field(description="Makes the operation conditional on whether the object's current metageneration does not match the given value.")] = None,
        user_project: Annotated[Optional[StrictStr], Field(description="The project to be billed for this request. Required for Requester Pays buckets.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """storage_objects_delete

        Deletes an object and its metadata. Deletions are permanent if versioning is not enabled for the bucket, or if the generation parameter is used.

        :param bucket: Name of the bucket in which the object resides. (required)
        :type bucket: str
        :param object: Name of the object. For information about how to URL encode object names to be path safe, see [Encoding URI Path Parts](https://cloud.google.com/storage/docs/request-endpoints#encoding). (required)
        :type object: str
        :param alt: Data format for the response.
        :type alt: str
        :param fields: Selector specifying which fields to include in a partial response.
        :type fields: str
        :param key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :type key: str
        :param oauth_token: OAuth 2.0 token for the current user.
        :type oauth_token: str
        :param pretty_print: Returns response with indentations and line breaks.
        :type pretty_print: bool
        :param quota_user: An opaque string that represents a user for quota purposes. Must not exceed 40 characters.
        :type quota_user: str
        :param upload_type: Upload protocol for media (e.g. \"media\", \"multipart\", \"resumable\").
        :type upload_type: str
        :param user_ip: Deprecated. Please use quotaUser instead.
        :type user_ip: str
        :param generation: If present, permanently deletes a specific revision of this object (as opposed to the latest version, the default).
        :type generation: str
        :param if_generation_match: Makes the operation conditional on whether the object's current generation matches the given value. Setting to 0 makes the operation succeed only if there are no live versions of the object.
        :type if_generation_match: str
        :param if_generation_not_match: Makes the operation conditional on whether the object's current generation does not match the given value. If no live object exists, the precondition fails. Setting to 0 makes the operation succeed only if there is a live version of the object.
        :type if_generation_not_match: str
        :param if_metageneration_match: Makes the operation conditional on whether the object's current metageneration matches the given value.
        :type if_metageneration_match: str
        :param if_metageneration_not_match: Makes the operation conditional on whether the object's current metageneration does not match the given value.
        :type if_metageneration_not_match: str
        :param user_project: The project to be billed for this request. Required for Requester Pays buckets.
        :type user_project: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._storage_objects_delete_serialize(
            bucket=bucket,
            object=object,
            alt=alt,
            fields=fields,
            key=key,
            oauth_token=oauth_token,
            pretty_print=pretty_print,
            quota_user=quota_user,
            upload_type=upload_type,
            user_ip=user_ip,
            generation=generation,
            if_generation_match=if_generation_match,
            if_generation_not_match=if_generation_not_match,
            if_metageneration_match=if_metageneration_match,
            if_metageneration_not_match=if_metageneration_not_match,
            user_project=user_project,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _storage_objects_delete_serialize(
        self,
        bucket,
        object,
        alt,
        fields,
        key,
        oauth_token,
        pretty_print,
        quota_user,
        upload_type,
        user_ip,
        generation,
        if_generation_match,
        if_generation_not_match,
        if_metageneration_match,
        if_metageneration_not_match,
        user_project,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if bucket is not None:
            _path_params['bucket'] = bucket
        if object is not None:
            _path_params['object'] = object
        # process the query parameters
        if alt is not None:
            
            _query_params.append(('alt', alt))
            
        if fields is not None:
            
            _query_params.append(('fields', fields))
            
        if key is not None:
            
            _query_params.append(('key', key))
            
        if oauth_token is not None:
            
            _query_params.append(('oauth_token', oauth_token))
            
        if pretty_print is not None:
            
            _query_params.append(('prettyPrint', pretty_print))
            
        if quota_user is not None:
            
            _query_params.append(('quotaUser', quota_user))
            
        if upload_type is not None:
            
            _query_params.append(('uploadType', upload_type))
            
        if user_ip is not None:
            
            _query_params.append(('userIp', user_ip))
            
        if generation is not None:
            
            _query_params.append(('generation', generation))
            
        if if_generation_match is not None:
            
            _query_params.append(('ifGenerationMatch', if_generation_match))
            
        if if_generation_not_match is not None:
            
            _query_params.append(('ifGenerationNotMatch', if_generation_not_match))
            
        if if_metageneration_match is not None:
            
            _query_params.append(('ifMetagenerationMatch', if_metageneration_match))
            
        if if_metageneration_not_match is not None:
            
            _query_params.append(('ifMetagenerationNotMatch', if_metageneration_not_match))
            
        if user_project is not None:
            
            _query_params.append(('userProject', user_project))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter




        # authentication setting
        _auth_settings: List[str] = [
            'Oauth2c', 
            'Oauth2'
        ]

        return self.api_client.param_serialize(
            method='DELETE',
            resource_path='/b/{bucket}/o/{object}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def storage_objects_get(
        self,
        bucket: Annotated[StrictStr, Field(description="Name of the bucket in which the object resides.")],
        object: Annotated[StrictStr, Field(description="Name of the object. For information about how to URL encode object names to be path safe, see [Encoding URI Path Parts](https://cloud.google.com/storage/docs/request-endpoints#encoding).")],
        alt: Annotated[Optional[StrictStr], Field(description="Data format for the response.")] = None,
        fields: Annotated[Optional[StrictStr], Field(description="Selector specifying which fields to include in a partial response.")] = None,
        key: Annotated[Optional[StrictStr], Field(description="API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.")] = None,
        oauth_token: Annotated[Optional[StrictStr], Field(description="OAuth 2.0 token for the current user.")] = None,
        pretty_print: Annotated[Optional[StrictBool], Field(description="Returns response with indentations and line breaks.")] = None,
        quota_user: Annotated[Optional[StrictStr], Field(description="An opaque string that represents a user for quota purposes. Must not exceed 40 characters.")] = None,
        upload_type: Annotated[Optional[StrictStr], Field(description="Upload protocol for media (e.g. \"media\", \"multipart\", \"resumable\").")] = None,
        user_ip: Annotated[Optional[StrictStr], Field(description="Deprecated. Please use quotaUser instead.")] = None,
        generation: Annotated[Optional[StrictStr], Field(description="If present, selects a specific revision of this object (as opposed to the latest version, the default).")] = None,
        if_generation_match: Annotated[Optional[StrictStr], Field(description="Makes the operation conditional on whether the object's current generation matches the given value. Setting to 0 makes the operation succeed only if there are no live versions of the object.")] = None,
        if_generation_not_match: Annotated[Optional[StrictStr], Field(description="Makes the operation conditional on whether the object's current generation does not match the given value. If no live object exists, the precondition fails. Setting to 0 makes the operation succeed only if there is a live version of the object.")] = None,
        if_metageneration_match: Annotated[Optional[StrictStr], Field(description="Makes the operation conditional on whether the object's current metageneration matches the given value.")] = None,
        if_metageneration_not_match: Annotated[Optional[StrictStr], Field(description="Makes the operation conditional on whether the object's current metageneration does not match the given value.")] = None,
        projection: Annotated[Optional[StrictStr], Field(description="Set of properties to return. Defaults to noAcl.")] = None,
        soft_deleted: Annotated[Optional[StrictBool], Field(description="If true, only soft-deleted object versions will be listed. The default is false. For more information, see Soft Delete.")] = None,
        user_project: Annotated[Optional[StrictStr], Field(description="The project to be billed for this request. Required for Requester Pays buckets.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> Object:
        """storage_objects_get

        Retrieves an object or its metadata.

        :param bucket: Name of the bucket in which the object resides. (required)
        :type bucket: str
        :param object: Name of the object. For information about how to URL encode object names to be path safe, see [Encoding URI Path Parts](https://cloud.google.com/storage/docs/request-endpoints#encoding). (required)
        :type object: str
        :param alt: Data format for the response.
        :type alt: str
        :param fields: Selector specifying which fields to include in a partial response.
        :type fields: str
        :param key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :type key: str
        :param oauth_token: OAuth 2.0 token for the current user.
        :type oauth_token: str
        :param pretty_print: Returns response with indentations and line breaks.
        :type pretty_print: bool
        :param quota_user: An opaque string that represents a user for quota purposes. Must not exceed 40 characters.
        :type quota_user: str
        :param upload_type: Upload protocol for media (e.g. \"media\", \"multipart\", \"resumable\").
        :type upload_type: str
        :param user_ip: Deprecated. Please use quotaUser instead.
        :type user_ip: str
        :param generation: If present, selects a specific revision of this object (as opposed to the latest version, the default).
        :type generation: str
        :param if_generation_match: Makes the operation conditional on whether the object's current generation matches the given value. Setting to 0 makes the operation succeed only if there are no live versions of the object.
        :type if_generation_match: str
        :param if_generation_not_match: Makes the operation conditional on whether the object's current generation does not match the given value. If no live object exists, the precondition fails. Setting to 0 makes the operation succeed only if there is a live version of the object.
        :type if_generation_not_match: str
        :param if_metageneration_match: Makes the operation conditional on whether the object's current metageneration matches the given value.
        :type if_metageneration_match: str
        :param if_metageneration_not_match: Makes the operation conditional on whether the object's current metageneration does not match the given value.
        :type if_metageneration_not_match: str
        :param projection: Set of properties to return. Defaults to noAcl.
        :type projection: str
        :param soft_deleted: If true, only soft-deleted object versions will be listed. The default is false. For more information, see Soft Delete.
        :type soft_deleted: bool
        :param user_project: The project to be billed for this request. Required for Requester Pays buckets.
        :type user_project: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._storage_objects_get_serialize(
            bucket=bucket,
            object=object,
            alt=alt,
            fields=fields,
            key=key,
            oauth_token=oauth_token,
            pretty_print=pretty_print,
            quota_user=quota_user,
            upload_type=upload_type,
            user_ip=user_ip,
            generation=generation,
            if_generation_match=if_generation_match,
            if_generation_not_match=if_generation_not_match,
            if_metageneration_match=if_metageneration_match,
            if_metageneration_not_match=if_metageneration_not_match,
            projection=projection,
            soft_deleted=soft_deleted,
            user_project=user_project,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def storage_objects_get_with_http_info(
        self,
        bucket: Annotated[StrictStr, Field(description="Name of the bucket in which the object resides.")],
        object: Annotated[StrictStr, Field(description="Name of the object. For information about how to URL encode object names to be path safe, see [Encoding URI Path Parts](https://cloud.google.com/storage/docs/request-endpoints#encoding).")],
        alt: Annotated[Optional[StrictStr], Field(description="Data format for the response.")] = None,
        fields: Annotated[Optional[StrictStr], Field(description="Selector specifying which fields to include in a partial response.")] = None,
        key: Annotated[Optional[StrictStr], Field(description="API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.")] = None,
        oauth_token: Annotated[Optional[StrictStr], Field(description="OAuth 2.0 token for the current user.")] = None,
        pretty_print: Annotated[Optional[StrictBool], Field(description="Returns response with indentations and line breaks.")] = None,
        quota_user: Annotated[Optional[StrictStr], Field(description="An opaque string that represents a user for quota purposes. Must not exceed 40 characters.")] = None,
        upload_type: Annotated[Optional[StrictStr], Field(description="Upload protocol for media (e.g. \"media\", \"multipart\", \"resumable\").")] = None,
        user_ip: Annotated[Optional[StrictStr], Field(description="Deprecated. Please use quotaUser instead.")] = None,
        generation: Annotated[Optional[StrictStr], Field(description="If present, selects a specific revision of this object (as opposed to the latest version, the default).")] = None,
        if_generation_match: Annotated[Optional[StrictStr], Field(description="Makes the operation conditional on whether the object's current generation matches the given value. Setting to 0 makes the operation succeed only if there are no live versions of the object.")] = None,
        if_generation_not_match: Annotated[Optional[StrictStr], Field(description="Makes the operation conditional on whether the object's current generation does not match the given value. If no live object exists, the precondition fails. Setting to 0 makes the operation succeed only if there is a live version of the object.")] = None,
        if_metageneration_match: Annotated[Optional[StrictStr], Field(description="Makes the operation conditional on whether the object's current metageneration matches the given value.")] = None,
        if_metageneration_not_match: Annotated[Optional[StrictStr], Field(description="Makes the operation conditional on whether the object's current metageneration does not match the given value.")] = None,
        projection: Annotated[Optional[StrictStr], Field(description="Set of properties to return. Defaults to noAcl.")] = None,
        soft_deleted: Annotated[Optional[StrictBool], Field(description="If true, only soft-deleted object versions will be listed. The default is false. For more information, see Soft Delete.")] = None,
        user_project: Annotated[Optional[StrictStr], Field(description="The project to be billed for this request. Required for Requester Pays buckets.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[Object]:
        """storage_objects_get

        Retrieves an object or its metadata.

        :param bucket: Name of the bucket in which the object resides. (required)
        :type bucket: str
        :param object: Name of the object. For information about how to URL encode object names to be path safe, see [Encoding URI Path Parts](https://cloud.google.com/storage/docs/request-endpoints#encoding). (required)
        :type object: str
        :param alt: Data format for the response.
        :type alt: str
        :param fields: Selector specifying which fields to include in a partial response.
        :type fields: str
        :param key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :type key: str
        :param oauth_token: OAuth 2.0 token for the current user.
        :type oauth_token: str
        :param pretty_print: Returns response with indentations and line breaks.
        :type pretty_print: bool
        :param quota_user: An opaque string that represents a user for quota purposes. Must not exceed 40 characters.
        :type quota_user: str
        :param upload_type: Upload protocol for media (e.g. \"media\", \"multipart\", \"resumable\").
        :type upload_type: str
        :param user_ip: Deprecated. Please use quotaUser instead.
        :type user_ip: str
        :param generation: If present, selects a specific revision of this object (as opposed to the latest version, the default).
        :type generation: str
        :param if_generation_match: Makes the operation conditional on whether the object's current generation matches the given value. Setting to 0 makes the operation succeed only if there are no live versions of the object.
        :type if_generation_match: str
        :param if_generation_not_match: Makes the operation conditional on whether the object's current generation does not match the given value. If no live object exists, the precondition fails. Setting to 0 makes the operation succeed only if there is a live version of the object.
        :type if_generation_not_match: str
        :param if_metageneration_match: Makes the operation conditional on whether the object's current metageneration matches the given value.
        :type if_metageneration_match: str
        :param if_metageneration_not_match: Makes the operation conditional on whether the object's current metageneration does not match the given value.
        :type if_metageneration_not_match: str
        :param projection: Set of properties to return. Defaults to noAcl.
        :type projection: str
        :param soft_deleted: If true, only soft-deleted object versions will be listed. The default is false. For more information, see Soft Delete.
        :type soft_deleted: bool
        :param user_project: The project to be billed for this request. Required for Requester Pays buckets.
        :type user_project: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._storage_objects_get_serialize(
            bucket=bucket,
            object=object,
            alt=alt,
            fields=fields,
            key=key,
            oauth_token=oauth_token,
            pretty_print=pretty_print,
            quota_user=quota_user,
            upload_type=upload_type,
            user_ip=user_ip,
            generation=generation,
            if_generation_match=if_generation_match,
            if_generation_not_match=if_generation_not_match,
            if_metageneration_match=if_metageneration_match,
            if_metageneration_not_match=if_metageneration_not_match,
            projection=projection,
            soft_deleted=soft_deleted,
            user_project=user_project,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def storage_objects_get_without_preload_content(
        self,
        bucket: Annotated[StrictStr, Field(description="Name of the bucket in which the object resides.")],
        object: Annotated[StrictStr, Field(description="Name of the object. For information about how to URL encode object names to be path safe, see [Encoding URI Path Parts](https://cloud.google.com/storage/docs/request-endpoints#encoding).")],
        alt: Annotated[Optional[StrictStr], Field(description="Data format for the response.")] = None,
        fields: Annotated[Optional[StrictStr], Field(description="Selector specifying which fields to include in a partial response.")] = None,
        key: Annotated[Optional[StrictStr], Field(description="API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.")] = None,
        oauth_token: Annotated[Optional[StrictStr], Field(description="OAuth 2.0 token for the current user.")] = None,
        pretty_print: Annotated[Optional[StrictBool], Field(description="Returns response with indentations and line breaks.")] = None,
        quota_user: Annotated[Optional[StrictStr], Field(description="An opaque string that represents a user for quota purposes. Must not exceed 40 characters.")] = None,
        upload_type: Annotated[Optional[StrictStr], Field(description="Upload protocol for media (e.g. \"media\", \"multipart\", \"resumable\").")] = None,
        user_ip: Annotated[Optional[StrictStr], Field(description="Deprecated. Please use quotaUser instead.")] = None,
        generation: Annotated[Optional[StrictStr], Field(description="If present, selects a specific revision of this object (as opposed to the latest version, the default).")] = None,
        if_generation_match: Annotated[Optional[StrictStr], Field(description="Makes the operation conditional on whether the object's current generation matches the given value. Setting to 0 makes the operation succeed only if there are no live versions of the object.")] = None,
        if_generation_not_match: Annotated[Optional[StrictStr], Field(description="Makes the operation conditional on whether the object's current generation does not match the given value. If no live object exists, the precondition fails. Setting to 0 makes the operation succeed only if there is a live version of the object.")] = None,
        if_metageneration_match: Annotated[Optional[StrictStr], Field(description="Makes the operation conditional on whether the object's current metageneration matches the given value.")] = None,
        if_metageneration_not_match: Annotated[Optional[StrictStr], Field(description="Makes the operation conditional on whether the object's current metageneration does not match the given value.")] = None,
        projection: Annotated[Optional[StrictStr], Field(description="Set of properties to return. Defaults to noAcl.")] = None,
        soft_deleted: Annotated[Optional[StrictBool], Field(description="If true, only soft-deleted object versions will be listed. The default is false. For more information, see Soft Delete.")] = None,
        user_project: Annotated[Optional[StrictStr], Field(description="The project to be billed for this request. Required for Requester Pays buckets.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """storage_objects_get

        Retrieves an object or its metadata.

        :param bucket: Name of the bucket in which the object resides. (required)
        :type bucket: str
        :param object: Name of the object. For information about how to URL encode object names to be path safe, see [Encoding URI Path Parts](https://cloud.google.com/storage/docs/request-endpoints#encoding). (required)
        :type object: str
        :param alt: Data format for the response.
        :type alt: str
        :param fields: Selector specifying which fields to include in a partial response.
        :type fields: str
        :param key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :type key: str
        :param oauth_token: OAuth 2.0 token for the current user.
        :type oauth_token: str
        :param pretty_print: Returns response with indentations and line breaks.
        :type pretty_print: bool
        :param quota_user: An opaque string that represents a user for quota purposes. Must not exceed 40 characters.
        :type quota_user: str
        :param upload_type: Upload protocol for media (e.g. \"media\", \"multipart\", \"resumable\").
        :type upload_type: str
        :param user_ip: Deprecated. Please use quotaUser instead.
        :type user_ip: str
        :param generation: If present, selects a specific revision of this object (as opposed to the latest version, the default).
        :type generation: str
        :param if_generation_match: Makes the operation conditional on whether the object's current generation matches the given value. Setting to 0 makes the operation succeed only if there are no live versions of the object.
        :type if_generation_match: str
        :param if_generation_not_match: Makes the operation conditional on whether the object's current generation does not match the given value. If no live object exists, the precondition fails. Setting to 0 makes the operation succeed only if there is a live version of the object.
        :type if_generation_not_match: str
        :param if_metageneration_match: Makes the operation conditional on whether the object's current metageneration matches the given value.
        :type if_metageneration_match: str
        :param if_metageneration_not_match: Makes the operation conditional on whether the object's current metageneration does not match the given value.
        :type if_metageneration_not_match: str
        :param projection: Set of properties to return. Defaults to noAcl.
        :type projection: str
        :param soft_deleted: If true, only soft-deleted object versions will be listed. The default is false. For more information, see Soft Delete.
        :type soft_deleted: bool
        :param user_project: The project to be billed for this request. Required for Requester Pays buckets.
        :type user_project: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._storage_objects_get_serialize(
            bucket=bucket,
            object=object,
            alt=alt,
            fields=fields,
            key=key,
            oauth_token=oauth_token,
            pretty_print=pretty_print,
            quota_user=quota_user,
            upload_type=upload_type,
            user_ip=user_ip,
            generation=generation,
            if_generation_match=if_generation_match,
            if_generation_not_match=if_generation_not_match,
            if_metageneration_match=if_metageneration_match,
            if_metageneration_not_match=if_metageneration_not_match,
            projection=projection,
            soft_deleted=soft_deleted,
            user_project=user_project,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _storage_objects_get_serialize(
        self,
        bucket,
        object,
        alt,
        fields,
        key,
        oauth_token,
        pretty_print,
        quota_user,
        upload_type,
        user_ip,
        generation,
        if_generation_match,
        if_generation_not_match,
        if_metageneration_match,
        if_metageneration_not_match,
        projection,
        soft_deleted,
        user_project,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if bucket is not None:
            _path_params['bucket'] = bucket
        if object is not None:
            _path_params['object'] = object
        # process the query parameters
        if alt is not None:
            
            _query_params.append(('alt', alt))
            
        if fields is not None:
            
            _query_params.append(('fields', fields))
            
        if key is not None:
            
            _query_params.append(('key', key))
            
        if oauth_token is not None:
            
            _query_params.append(('oauth_token', oauth_token))
            
        if pretty_print is not None:
            
            _query_params.append(('prettyPrint', pretty_print))
            
        if quota_user is not None:
            
            _query_params.append(('quotaUser', quota_user))
            
        if upload_type is not None:
            
            _query_params.append(('uploadType', upload_type))
            
        if user_ip is not None:
            
            _query_params.append(('userIp', user_ip))
            
        if generation is not None:
            
            _query_params.append(('generation', generation))
            
        if if_generation_match is not None:
            
            _query_params.append(('ifGenerationMatch', if_generation_match))
            
        if if_generation_not_match is not None:
            
            _query_params.append(('ifGenerationNotMatch', if_generation_not_match))
            
        if if_metageneration_match is not None:
            
            _query_params.append(('ifMetagenerationMatch', if_metageneration_match))
            
        if if_metageneration_not_match is not None:
            
            _query_params.append(('ifMetagenerationNotMatch', if_metageneration_not_match))
            
        if projection is not None:
            
            _query_params.append(('projection', projection))
            
        if soft_deleted is not None:
            
            _query_params.append(('softDeleted', soft_deleted))
            
        if user_project is not None:
            
            _query_params.append(('userProject', user_project))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'Oauth2c', 
            'Oauth2'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/b/{bucket}/o/{object}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def storage_objects_get_iam_policy(
        self,
        bucket: Annotated[StrictStr, Field(description="Name of the bucket in which the object resides.")],
        object: Annotated[StrictStr, Field(description="Name of the object. For information about how to URL encode object names to be path safe, see [Encoding URI Path Parts](https://cloud.google.com/storage/docs/request-endpoints#encoding).")],
        alt: Annotated[Optional[StrictStr], Field(description="Data format for the response.")] = None,
        fields: Annotated[Optional[StrictStr], Field(description="Selector specifying which fields to include in a partial response.")] = None,
        key: Annotated[Optional[StrictStr], Field(description="API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.")] = None,
        oauth_token: Annotated[Optional[StrictStr], Field(description="OAuth 2.0 token for the current user.")] = None,
        pretty_print: Annotated[Optional[StrictBool], Field(description="Returns response with indentations and line breaks.")] = None,
        quota_user: Annotated[Optional[StrictStr], Field(description="An opaque string that represents a user for quota purposes. Must not exceed 40 characters.")] = None,
        upload_type: Annotated[Optional[StrictStr], Field(description="Upload protocol for media (e.g. \"media\", \"multipart\", \"resumable\").")] = None,
        user_ip: Annotated[Optional[StrictStr], Field(description="Deprecated. Please use quotaUser instead.")] = None,
        generation: Annotated[Optional[StrictStr], Field(description="If present, selects a specific revision of this object (as opposed to the latest version, the default).")] = None,
        user_project: Annotated[Optional[StrictStr], Field(description="The project to be billed for this request. Required for Requester Pays buckets.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> Policy:
        """storage_objects_get_iam_policy

        Returns an IAM policy for the specified object.

        :param bucket: Name of the bucket in which the object resides. (required)
        :type bucket: str
        :param object: Name of the object. For information about how to URL encode object names to be path safe, see [Encoding URI Path Parts](https://cloud.google.com/storage/docs/request-endpoints#encoding). (required)
        :type object: str
        :param alt: Data format for the response.
        :type alt: str
        :param fields: Selector specifying which fields to include in a partial response.
        :type fields: str
        :param key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :type key: str
        :param oauth_token: OAuth 2.0 token for the current user.
        :type oauth_token: str
        :param pretty_print: Returns response with indentations and line breaks.
        :type pretty_print: bool
        :param quota_user: An opaque string that represents a user for quota purposes. Must not exceed 40 characters.
        :type quota_user: str
        :param upload_type: Upload protocol for media (e.g. \"media\", \"multipart\", \"resumable\").
        :type upload_type: str
        :param user_ip: Deprecated. Please use quotaUser instead.
        :type user_ip: str
        :param generation: If present, selects a specific revision of this object (as opposed to the latest version, the default).
        :type generation: str
        :param user_project: The project to be billed for this request. Required for Requester Pays buckets.
        :type user_project: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._storage_objects_get_iam_policy_serialize(
            bucket=bucket,
            object=object,
            alt=alt,
            fields=fields,
            key=key,
            oauth_token=oauth_token,
            pretty_print=pretty_print,
            quota_user=quota_user,
            upload_type=upload_type,
            user_ip=user_ip,
            generation=generation,
            user_project=user_project,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Policy",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def storage_objects_get_iam_policy_with_http_info(
        self,
        bucket: Annotated[StrictStr, Field(description="Name of the bucket in which the object resides.")],
        object: Annotated[StrictStr, Field(description="Name of the object. For information about how to URL encode object names to be path safe, see [Encoding URI Path Parts](https://cloud.google.com/storage/docs/request-endpoints#encoding).")],
        alt: Annotated[Optional[StrictStr], Field(description="Data format for the response.")] = None,
        fields: Annotated[Optional[StrictStr], Field(description="Selector specifying which fields to include in a partial response.")] = None,
        key: Annotated[Optional[StrictStr], Field(description="API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.")] = None,
        oauth_token: Annotated[Optional[StrictStr], Field(description="OAuth 2.0 token for the current user.")] = None,
        pretty_print: Annotated[Optional[StrictBool], Field(description="Returns response with indentations and line breaks.")] = None,
        quota_user: Annotated[Optional[StrictStr], Field(description="An opaque string that represents a user for quota purposes. Must not exceed 40 characters.")] = None,
        upload_type: Annotated[Optional[StrictStr], Field(description="Upload protocol for media (e.g. \"media\", \"multipart\", \"resumable\").")] = None,
        user_ip: Annotated[Optional[StrictStr], Field(description="Deprecated. Please use quotaUser instead.")] = None,
        generation: Annotated[Optional[StrictStr], Field(description="If present, selects a specific revision of this object (as opposed to the latest version, the default).")] = None,
        user_project: Annotated[Optional[StrictStr], Field(description="The project to be billed for this request. Required for Requester Pays buckets.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[Policy]:
        """storage_objects_get_iam_policy

        Returns an IAM policy for the specified object.

        :param bucket: Name of the bucket in which the object resides. (required)
        :type bucket: str
        :param object: Name of the object. For information about how to URL encode object names to be path safe, see [Encoding URI Path Parts](https://cloud.google.com/storage/docs/request-endpoints#encoding). (required)
        :type object: str
        :param alt: Data format for the response.
        :type alt: str
        :param fields: Selector specifying which fields to include in a partial response.
        :type fields: str
        :param key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :type key: str
        :param oauth_token: OAuth 2.0 token for the current user.
        :type oauth_token: str
        :param pretty_print: Returns response with indentations and line breaks.
        :type pretty_print: bool
        :param quota_user: An opaque string that represents a user for quota purposes. Must not exceed 40 characters.
        :type quota_user: str
        :param upload_type: Upload protocol for media (e.g. \"media\", \"multipart\", \"resumable\").
        :type upload_type: str
        :param user_ip: Deprecated. Please use quotaUser instead.
        :type user_ip: str
        :param generation: If present, selects a specific revision of this object (as opposed to the latest version, the default).
        :type generation: str
        :param user_project: The project to be billed for this request. Required for Requester Pays buckets.
        :type user_project: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._storage_objects_get_iam_policy_serialize(
            bucket=bucket,
            object=object,
            alt=alt,
            fields=fields,
            key=key,
            oauth_token=oauth_token,
            pretty_print=pretty_print,
            quota_user=quota_user,
            upload_type=upload_type,
            user_ip=user_ip,
            generation=generation,
            user_project=user_project,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Policy",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def storage_objects_get_iam_policy_without_preload_content(
        self,
        bucket: Annotated[StrictStr, Field(description="Name of the bucket in which the object resides.")],
        object: Annotated[StrictStr, Field(description="Name of the object. For information about how to URL encode object names to be path safe, see [Encoding URI Path Parts](https://cloud.google.com/storage/docs/request-endpoints#encoding).")],
        alt: Annotated[Optional[StrictStr], Field(description="Data format for the response.")] = None,
        fields: Annotated[Optional[StrictStr], Field(description="Selector specifying which fields to include in a partial response.")] = None,
        key: Annotated[Optional[StrictStr], Field(description="API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.")] = None,
        oauth_token: Annotated[Optional[StrictStr], Field(description="OAuth 2.0 token for the current user.")] = None,
        pretty_print: Annotated[Optional[StrictBool], Field(description="Returns response with indentations and line breaks.")] = None,
        quota_user: Annotated[Optional[StrictStr], Field(description="An opaque string that represents a user for quota purposes. Must not exceed 40 characters.")] = None,
        upload_type: Annotated[Optional[StrictStr], Field(description="Upload protocol for media (e.g. \"media\", \"multipart\", \"resumable\").")] = None,
        user_ip: Annotated[Optional[StrictStr], Field(description="Deprecated. Please use quotaUser instead.")] = None,
        generation: Annotated[Optional[StrictStr], Field(description="If present, selects a specific revision of this object (as opposed to the latest version, the default).")] = None,
        user_project: Annotated[Optional[StrictStr], Field(description="The project to be billed for this request. Required for Requester Pays buckets.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """storage_objects_get_iam_policy

        Returns an IAM policy for the specified object.

        :param bucket: Name of the bucket in which the object resides. (required)
        :type bucket: str
        :param object: Name of the object. For information about how to URL encode object names to be path safe, see [Encoding URI Path Parts](https://cloud.google.com/storage/docs/request-endpoints#encoding). (required)
        :type object: str
        :param alt: Data format for the response.
        :type alt: str
        :param fields: Selector specifying which fields to include in a partial response.
        :type fields: str
        :param key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :type key: str
        :param oauth_token: OAuth 2.0 token for the current user.
        :type oauth_token: str
        :param pretty_print: Returns response with indentations and line breaks.
        :type pretty_print: bool
        :param quota_user: An opaque string that represents a user for quota purposes. Must not exceed 40 characters.
        :type quota_user: str
        :param upload_type: Upload protocol for media (e.g. \"media\", \"multipart\", \"resumable\").
        :type upload_type: str
        :param user_ip: Deprecated. Please use quotaUser instead.
        :type user_ip: str
        :param generation: If present, selects a specific revision of this object (as opposed to the latest version, the default).
        :type generation: str
        :param user_project: The project to be billed for this request. Required for Requester Pays buckets.
        :type user_project: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._storage_objects_get_iam_policy_serialize(
            bucket=bucket,
            object=object,
            alt=alt,
            fields=fields,
            key=key,
            oauth_token=oauth_token,
            pretty_print=pretty_print,
            quota_user=quota_user,
            upload_type=upload_type,
            user_ip=user_ip,
            generation=generation,
            user_project=user_project,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Policy",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _storage_objects_get_iam_policy_serialize(
        self,
        bucket,
        object,
        alt,
        fields,
        key,
        oauth_token,
        pretty_print,
        quota_user,
        upload_type,
        user_ip,
        generation,
        user_project,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if bucket is not None:
            _path_params['bucket'] = bucket
        if object is not None:
            _path_params['object'] = object
        # process the query parameters
        if alt is not None:
            
            _query_params.append(('alt', alt))
            
        if fields is not None:
            
            _query_params.append(('fields', fields))
            
        if key is not None:
            
            _query_params.append(('key', key))
            
        if oauth_token is not None:
            
            _query_params.append(('oauth_token', oauth_token))
            
        if pretty_print is not None:
            
            _query_params.append(('prettyPrint', pretty_print))
            
        if quota_user is not None:
            
            _query_params.append(('quotaUser', quota_user))
            
        if upload_type is not None:
            
            _query_params.append(('uploadType', upload_type))
            
        if user_ip is not None:
            
            _query_params.append(('userIp', user_ip))
            
        if generation is not None:
            
            _query_params.append(('generation', generation))
            
        if user_project is not None:
            
            _query_params.append(('userProject', user_project))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'Oauth2c', 
            'Oauth2'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/b/{bucket}/o/{object}/iam',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def storage_objects_insert(
        self,
        bucket: Annotated[StrictStr, Field(description="Name of the bucket in which to store the new object. Overrides the provided object metadata's bucket value, if any.")],
        alt: Annotated[Optional[StrictStr], Field(description="Data format for the response.")] = None,
        fields: Annotated[Optional[StrictStr], Field(description="Selector specifying which fields to include in a partial response.")] = None,
        key: Annotated[Optional[StrictStr], Field(description="API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.")] = None,
        oauth_token: Annotated[Optional[StrictStr], Field(description="OAuth 2.0 token for the current user.")] = None,
        pretty_print: Annotated[Optional[StrictBool], Field(description="Returns response with indentations and line breaks.")] = None,
        quota_user: Annotated[Optional[StrictStr], Field(description="An opaque string that represents a user for quota purposes. Must not exceed 40 characters.")] = None,
        upload_type: Annotated[Optional[StrictStr], Field(description="Upload protocol for media (e.g. \"media\", \"multipart\", \"resumable\").")] = None,
        user_ip: Annotated[Optional[StrictStr], Field(description="Deprecated. Please use quotaUser instead.")] = None,
        content_encoding: Annotated[Optional[StrictStr], Field(description="If set, sets the contentEncoding property of the final object to this value. Setting this parameter is equivalent to setting the contentEncoding metadata property. This can be useful when uploading an object with uploadType=media to indicate the encoding of the content being uploaded.")] = None,
        if_generation_match: Annotated[Optional[StrictStr], Field(description="Makes the operation conditional on whether the object's current generation matches the given value. Setting to 0 makes the operation succeed only if there are no live versions of the object.")] = None,
        if_generation_not_match: Annotated[Optional[StrictStr], Field(description="Makes the operation conditional on whether the object's current generation does not match the given value. If no live object exists, the precondition fails. Setting to 0 makes the operation succeed only if there is a live version of the object.")] = None,
        if_metageneration_match: Annotated[Optional[StrictStr], Field(description="Makes the operation conditional on whether the object's current metageneration matches the given value.")] = None,
        if_metageneration_not_match: Annotated[Optional[StrictStr], Field(description="Makes the operation conditional on whether the object's current metageneration does not match the given value.")] = None,
        kms_key_name: Annotated[Optional[StrictStr], Field(description="Resource name of the Cloud KMS key, of the form projects/my-project/locations/global/keyRings/my-kr/cryptoKeys/my-key, that will be used to encrypt the object. Overrides the object metadata's kms_key_name value, if any.")] = None,
        name: Annotated[Optional[StrictStr], Field(description="Name of the object. Required when the object metadata is not otherwise provided. Overrides the object metadata's name value, if any. For information about how to URL encode object names to be path safe, see [Encoding URI Path Parts](https://cloud.google.com/storage/docs/request-endpoints#encoding).")] = None,
        predefined_acl: Annotated[Optional[StrictStr], Field(description="Apply a predefined set of access controls to this object.")] = None,
        projection: Annotated[Optional[StrictStr], Field(description="Set of properties to return. Defaults to noAcl, unless the object resource specifies the acl property, when it defaults to full.")] = None,
        user_project: Annotated[Optional[StrictStr], Field(description="The project to be billed for this request. Required for Requester Pays buckets.")] = None,
        object: Optional[Object] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> Object:
        """storage_objects_insert

        Stores a new object and metadata.

        :param bucket: Name of the bucket in which to store the new object. Overrides the provided object metadata's bucket value, if any. (required)
        :type bucket: str
        :param alt: Data format for the response.
        :type alt: str
        :param fields: Selector specifying which fields to include in a partial response.
        :type fields: str
        :param key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :type key: str
        :param oauth_token: OAuth 2.0 token for the current user.
        :type oauth_token: str
        :param pretty_print: Returns response with indentations and line breaks.
        :type pretty_print: bool
        :param quota_user: An opaque string that represents a user for quota purposes. Must not exceed 40 characters.
        :type quota_user: str
        :param upload_type: Upload protocol for media (e.g. \"media\", \"multipart\", \"resumable\").
        :type upload_type: str
        :param user_ip: Deprecated. Please use quotaUser instead.
        :type user_ip: str
        :param content_encoding: If set, sets the contentEncoding property of the final object to this value. Setting this parameter is equivalent to setting the contentEncoding metadata property. This can be useful when uploading an object with uploadType=media to indicate the encoding of the content being uploaded.
        :type content_encoding: str
        :param if_generation_match: Makes the operation conditional on whether the object's current generation matches the given value. Setting to 0 makes the operation succeed only if there are no live versions of the object.
        :type if_generation_match: str
        :param if_generation_not_match: Makes the operation conditional on whether the object's current generation does not match the given value. If no live object exists, the precondition fails. Setting to 0 makes the operation succeed only if there is a live version of the object.
        :type if_generation_not_match: str
        :param if_metageneration_match: Makes the operation conditional on whether the object's current metageneration matches the given value.
        :type if_metageneration_match: str
        :param if_metageneration_not_match: Makes the operation conditional on whether the object's current metageneration does not match the given value.
        :type if_metageneration_not_match: str
        :param kms_key_name: Resource name of the Cloud KMS key, of the form projects/my-project/locations/global/keyRings/my-kr/cryptoKeys/my-key, that will be used to encrypt the object. Overrides the object metadata's kms_key_name value, if any.
        :type kms_key_name: str
        :param name: Name of the object. Required when the object metadata is not otherwise provided. Overrides the object metadata's name value, if any. For information about how to URL encode object names to be path safe, see [Encoding URI Path Parts](https://cloud.google.com/storage/docs/request-endpoints#encoding).
        :type name: str
        :param predefined_acl: Apply a predefined set of access controls to this object.
        :type predefined_acl: str
        :param projection: Set of properties to return. Defaults to noAcl, unless the object resource specifies the acl property, when it defaults to full.
        :type projection: str
        :param user_project: The project to be billed for this request. Required for Requester Pays buckets.
        :type user_project: str
        :param object:
        :type object: Object
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._storage_objects_insert_serialize(
            bucket=bucket,
            alt=alt,
            fields=fields,
            key=key,
            oauth_token=oauth_token,
            pretty_print=pretty_print,
            quota_user=quota_user,
            upload_type=upload_type,
            user_ip=user_ip,
            content_encoding=content_encoding,
            if_generation_match=if_generation_match,
            if_generation_not_match=if_generation_not_match,
            if_metageneration_match=if_metageneration_match,
            if_metageneration_not_match=if_metageneration_not_match,
            kms_key_name=kms_key_name,
            name=name,
            predefined_acl=predefined_acl,
            projection=projection,
            user_project=user_project,
            object=object,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def storage_objects_insert_with_http_info(
        self,
        bucket: Annotated[StrictStr, Field(description="Name of the bucket in which to store the new object. Overrides the provided object metadata's bucket value, if any.")],
        alt: Annotated[Optional[StrictStr], Field(description="Data format for the response.")] = None,
        fields: Annotated[Optional[StrictStr], Field(description="Selector specifying which fields to include in a partial response.")] = None,
        key: Annotated[Optional[StrictStr], Field(description="API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.")] = None,
        oauth_token: Annotated[Optional[StrictStr], Field(description="OAuth 2.0 token for the current user.")] = None,
        pretty_print: Annotated[Optional[StrictBool], Field(description="Returns response with indentations and line breaks.")] = None,
        quota_user: Annotated[Optional[StrictStr], Field(description="An opaque string that represents a user for quota purposes. Must not exceed 40 characters.")] = None,
        upload_type: Annotated[Optional[StrictStr], Field(description="Upload protocol for media (e.g. \"media\", \"multipart\", \"resumable\").")] = None,
        user_ip: Annotated[Optional[StrictStr], Field(description="Deprecated. Please use quotaUser instead.")] = None,
        content_encoding: Annotated[Optional[StrictStr], Field(description="If set, sets the contentEncoding property of the final object to this value. Setting this parameter is equivalent to setting the contentEncoding metadata property. This can be useful when uploading an object with uploadType=media to indicate the encoding of the content being uploaded.")] = None,
        if_generation_match: Annotated[Optional[StrictStr], Field(description="Makes the operation conditional on whether the object's current generation matches the given value. Setting to 0 makes the operation succeed only if there are no live versions of the object.")] = None,
        if_generation_not_match: Annotated[Optional[StrictStr], Field(description="Makes the operation conditional on whether the object's current generation does not match the given value. If no live object exists, the precondition fails. Setting to 0 makes the operation succeed only if there is a live version of the object.")] = None,
        if_metageneration_match: Annotated[Optional[StrictStr], Field(description="Makes the operation conditional on whether the object's current metageneration matches the given value.")] = None,
        if_metageneration_not_match: Annotated[Optional[StrictStr], Field(description="Makes the operation conditional on whether the object's current metageneration does not match the given value.")] = None,
        kms_key_name: Annotated[Optional[StrictStr], Field(description="Resource name of the Cloud KMS key, of the form projects/my-project/locations/global/keyRings/my-kr/cryptoKeys/my-key, that will be used to encrypt the object. Overrides the object metadata's kms_key_name value, if any.")] = None,
        name: Annotated[Optional[StrictStr], Field(description="Name of the object. Required when the object metadata is not otherwise provided. Overrides the object metadata's name value, if any. For information about how to URL encode object names to be path safe, see [Encoding URI Path Parts](https://cloud.google.com/storage/docs/request-endpoints#encoding).")] = None,
        predefined_acl: Annotated[Optional[StrictStr], Field(description="Apply a predefined set of access controls to this object.")] = None,
        projection: Annotated[Optional[StrictStr], Field(description="Set of properties to return. Defaults to noAcl, unless the object resource specifies the acl property, when it defaults to full.")] = None,
        user_project: Annotated[Optional[StrictStr], Field(description="The project to be billed for this request. Required for Requester Pays buckets.")] = None,
        object: Optional[Object] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[Object]:
        """storage_objects_insert

        Stores a new object and metadata.

        :param bucket: Name of the bucket in which to store the new object. Overrides the provided object metadata's bucket value, if any. (required)
        :type bucket: str
        :param alt: Data format for the response.
        :type alt: str
        :param fields: Selector specifying which fields to include in a partial response.
        :type fields: str
        :param key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :type key: str
        :param oauth_token: OAuth 2.0 token for the current user.
        :type oauth_token: str
        :param pretty_print: Returns response with indentations and line breaks.
        :type pretty_print: bool
        :param quota_user: An opaque string that represents a user for quota purposes. Must not exceed 40 characters.
        :type quota_user: str
        :param upload_type: Upload protocol for media (e.g. \"media\", \"multipart\", \"resumable\").
        :type upload_type: str
        :param user_ip: Deprecated. Please use quotaUser instead.
        :type user_ip: str
        :param content_encoding: If set, sets the contentEncoding property of the final object to this value. Setting this parameter is equivalent to setting the contentEncoding metadata property. This can be useful when uploading an object with uploadType=media to indicate the encoding of the content being uploaded.
        :type content_encoding: str
        :param if_generation_match: Makes the operation conditional on whether the object's current generation matches the given value. Setting to 0 makes the operation succeed only if there are no live versions of the object.
        :type if_generation_match: str
        :param if_generation_not_match: Makes the operation conditional on whether the object's current generation does not match the given value. If no live object exists, the precondition fails. Setting to 0 makes the operation succeed only if there is a live version of the object.
        :type if_generation_not_match: str
        :param if_metageneration_match: Makes the operation conditional on whether the object's current metageneration matches the given value.
        :type if_metageneration_match: str
        :param if_metageneration_not_match: Makes the operation conditional on whether the object's current metageneration does not match the given value.
        :type if_metageneration_not_match: str
        :param kms_key_name: Resource name of the Cloud KMS key, of the form projects/my-project/locations/global/keyRings/my-kr/cryptoKeys/my-key, that will be used to encrypt the object. Overrides the object metadata's kms_key_name value, if any.
        :type kms_key_name: str
        :param name: Name of the object. Required when the object metadata is not otherwise provided. Overrides the object metadata's name value, if any. For information about how to URL encode object names to be path safe, see [Encoding URI Path Parts](https://cloud.google.com/storage/docs/request-endpoints#encoding).
        :type name: str
        :param predefined_acl: Apply a predefined set of access controls to this object.
        :type predefined_acl: str
        :param projection: Set of properties to return. Defaults to noAcl, unless the object resource specifies the acl property, when it defaults to full.
        :type projection: str
        :param user_project: The project to be billed for this request. Required for Requester Pays buckets.
        :type user_project: str
        :param object:
        :type object: Object
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._storage_objects_insert_serialize(
            bucket=bucket,
            alt=alt,
            fields=fields,
            key=key,
            oauth_token=oauth_token,
            pretty_print=pretty_print,
            quota_user=quota_user,
            upload_type=upload_type,
            user_ip=user_ip,
            content_encoding=content_encoding,
            if_generation_match=if_generation_match,
            if_generation_not_match=if_generation_not_match,
            if_metageneration_match=if_metageneration_match,
            if_metageneration_not_match=if_metageneration_not_match,
            kms_key_name=kms_key_name,
            name=name,
            predefined_acl=predefined_acl,
            projection=projection,
            user_project=user_project,
            object=object,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def storage_objects_insert_without_preload_content(
        self,
        bucket: Annotated[StrictStr, Field(description="Name of the bucket in which to store the new object. Overrides the provided object metadata's bucket value, if any.")],
        alt: Annotated[Optional[StrictStr], Field(description="Data format for the response.")] = None,
        fields: Annotated[Optional[StrictStr], Field(description="Selector specifying which fields to include in a partial response.")] = None,
        key: Annotated[Optional[StrictStr], Field(description="API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.")] = None,
        oauth_token: Annotated[Optional[StrictStr], Field(description="OAuth 2.0 token for the current user.")] = None,
        pretty_print: Annotated[Optional[StrictBool], Field(description="Returns response with indentations and line breaks.")] = None,
        quota_user: Annotated[Optional[StrictStr], Field(description="An opaque string that represents a user for quota purposes. Must not exceed 40 characters.")] = None,
        upload_type: Annotated[Optional[StrictStr], Field(description="Upload protocol for media (e.g. \"media\", \"multipart\", \"resumable\").")] = None,
        user_ip: Annotated[Optional[StrictStr], Field(description="Deprecated. Please use quotaUser instead.")] = None,
        content_encoding: Annotated[Optional[StrictStr], Field(description="If set, sets the contentEncoding property of the final object to this value. Setting this parameter is equivalent to setting the contentEncoding metadata property. This can be useful when uploading an object with uploadType=media to indicate the encoding of the content being uploaded.")] = None,
        if_generation_match: Annotated[Optional[StrictStr], Field(description="Makes the operation conditional on whether the object's current generation matches the given value. Setting to 0 makes the operation succeed only if there are no live versions of the object.")] = None,
        if_generation_not_match: Annotated[Optional[StrictStr], Field(description="Makes the operation conditional on whether the object's current generation does not match the given value. If no live object exists, the precondition fails. Setting to 0 makes the operation succeed only if there is a live version of the object.")] = None,
        if_metageneration_match: Annotated[Optional[StrictStr], Field(description="Makes the operation conditional on whether the object's current metageneration matches the given value.")] = None,
        if_metageneration_not_match: Annotated[Optional[StrictStr], Field(description="Makes the operation conditional on whether the object's current metageneration does not match the given value.")] = None,
        kms_key_name: Annotated[Optional[StrictStr], Field(description="Resource name of the Cloud KMS key, of the form projects/my-project/locations/global/keyRings/my-kr/cryptoKeys/my-key, that will be used to encrypt the object. Overrides the object metadata's kms_key_name value, if any.")] = None,
        name: Annotated[Optional[StrictStr], Field(description="Name of the object. Required when the object metadata is not otherwise provided. Overrides the object metadata's name value, if any. For information about how to URL encode object names to be path safe, see [Encoding URI Path Parts](https://cloud.google.com/storage/docs/request-endpoints#encoding).")] = None,
        predefined_acl: Annotated[Optional[StrictStr], Field(description="Apply a predefined set of access controls to this object.")] = None,
        projection: Annotated[Optional[StrictStr], Field(description="Set of properties to return. Defaults to noAcl, unless the object resource specifies the acl property, when it defaults to full.")] = None,
        user_project: Annotated[Optional[StrictStr], Field(description="The project to be billed for this request. Required for Requester Pays buckets.")] = None,
        object: Optional[Object] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """storage_objects_insert

        Stores a new object and metadata.

        :param bucket: Name of the bucket in which to store the new object. Overrides the provided object metadata's bucket value, if any. (required)
        :type bucket: str
        :param alt: Data format for the response.
        :type alt: str
        :param fields: Selector specifying which fields to include in a partial response.
        :type fields: str
        :param key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :type key: str
        :param oauth_token: OAuth 2.0 token for the current user.
        :type oauth_token: str
        :param pretty_print: Returns response with indentations and line breaks.
        :type pretty_print: bool
        :param quota_user: An opaque string that represents a user for quota purposes. Must not exceed 40 characters.
        :type quota_user: str
        :param upload_type: Upload protocol for media (e.g. \"media\", \"multipart\", \"resumable\").
        :type upload_type: str
        :param user_ip: Deprecated. Please use quotaUser instead.
        :type user_ip: str
        :param content_encoding: If set, sets the contentEncoding property of the final object to this value. Setting this parameter is equivalent to setting the contentEncoding metadata property. This can be useful when uploading an object with uploadType=media to indicate the encoding of the content being uploaded.
        :type content_encoding: str
        :param if_generation_match: Makes the operation conditional on whether the object's current generation matches the given value. Setting to 0 makes the operation succeed only if there are no live versions of the object.
        :type if_generation_match: str
        :param if_generation_not_match: Makes the operation conditional on whether the object's current generation does not match the given value. If no live object exists, the precondition fails. Setting to 0 makes the operation succeed only if there is a live version of the object.
        :type if_generation_not_match: str
        :param if_metageneration_match: Makes the operation conditional on whether the object's current metageneration matches the given value.
        :type if_metageneration_match: str
        :param if_metageneration_not_match: Makes the operation conditional on whether the object's current metageneration does not match the given value.
        :type if_metageneration_not_match: str
        :param kms_key_name: Resource name of the Cloud KMS key, of the form projects/my-project/locations/global/keyRings/my-kr/cryptoKeys/my-key, that will be used to encrypt the object. Overrides the object metadata's kms_key_name value, if any.
        :type kms_key_name: str
        :param name: Name of the object. Required when the object metadata is not otherwise provided. Overrides the object metadata's name value, if any. For information about how to URL encode object names to be path safe, see [Encoding URI Path Parts](https://cloud.google.com/storage/docs/request-endpoints#encoding).
        :type name: str
        :param predefined_acl: Apply a predefined set of access controls to this object.
        :type predefined_acl: str
        :param projection: Set of properties to return. Defaults to noAcl, unless the object resource specifies the acl property, when it defaults to full.
        :type projection: str
        :param user_project: The project to be billed for this request. Required for Requester Pays buckets.
        :type user_project: str
        :param object:
        :type object: Object
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._storage_objects_insert_serialize(
            bucket=bucket,
            alt=alt,
            fields=fields,
            key=key,
            oauth_token=oauth_token,
            pretty_print=pretty_print,
            quota_user=quota_user,
            upload_type=upload_type,
            user_ip=user_ip,
            content_encoding=content_encoding,
            if_generation_match=if_generation_match,
            if_generation_not_match=if_generation_not_match,
            if_metageneration_match=if_metageneration_match,
            if_metageneration_not_match=if_metageneration_not_match,
            kms_key_name=kms_key_name,
            name=name,
            predefined_acl=predefined_acl,
            projection=projection,
            user_project=user_project,
            object=object,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _storage_objects_insert_serialize(
        self,
        bucket,
        alt,
        fields,
        key,
        oauth_token,
        pretty_print,
        quota_user,
        upload_type,
        user_ip,
        content_encoding,
        if_generation_match,
        if_generation_not_match,
        if_metageneration_match,
        if_metageneration_not_match,
        kms_key_name,
        name,
        predefined_acl,
        projection,
        user_project,
        object,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if bucket is not None:
            _path_params['bucket'] = bucket
        # process the query parameters
        if alt is not None:
            
            _query_params.append(('alt', alt))
            
        if fields is not None:
            
            _query_params.append(('fields', fields))
            
        if key is not None:
            
            _query_params.append(('key', key))
            
        if oauth_token is not None:
            
            _query_params.append(('oauth_token', oauth_token))
            
        if pretty_print is not None:
            
            _query_params.append(('prettyPrint', pretty_print))
            
        if quota_user is not None:
            
            _query_params.append(('quotaUser', quota_user))
            
        if upload_type is not None:
            
            _query_params.append(('uploadType', upload_type))
            
        if user_ip is not None:
            
            _query_params.append(('userIp', user_ip))
            
        if content_encoding is not None:
            
            _query_params.append(('contentEncoding', content_encoding))
            
        if if_generation_match is not None:
            
            _query_params.append(('ifGenerationMatch', if_generation_match))
            
        if if_generation_not_match is not None:
            
            _query_params.append(('ifGenerationNotMatch', if_generation_not_match))
            
        if if_metageneration_match is not None:
            
            _query_params.append(('ifMetagenerationMatch', if_metageneration_match))
            
        if if_metageneration_not_match is not None:
            
            _query_params.append(('ifMetagenerationNotMatch', if_metageneration_not_match))
            
        if kms_key_name is not None:
            
            _query_params.append(('kmsKeyName', kms_key_name))
            
        if name is not None:
            
            _query_params.append(('name', name))
            
        if predefined_acl is not None:
            
            _query_params.append(('predefinedAcl', predefined_acl))
            
        if projection is not None:
            
            _query_params.append(('projection', projection))
            
        if user_project is not None:
            
            _query_params.append(('userProject', user_project))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if object is not None:
            _body_params = object


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/octet-stream'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'Oauth2c', 
            'Oauth2'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/b/{bucket}/o',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def storage_objects_list(
        self,
        bucket: Annotated[StrictStr, Field(description="Name of the bucket in which to look for objects.")],
        alt: Annotated[Optional[StrictStr], Field(description="Data format for the response.")] = None,
        fields: Annotated[Optional[StrictStr], Field(description="Selector specifying which fields to include in a partial response.")] = None,
        key: Annotated[Optional[StrictStr], Field(description="API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.")] = None,
        oauth_token: Annotated[Optional[StrictStr], Field(description="OAuth 2.0 token for the current user.")] = None,
        pretty_print: Annotated[Optional[StrictBool], Field(description="Returns response with indentations and line breaks.")] = None,
        quota_user: Annotated[Optional[StrictStr], Field(description="An opaque string that represents a user for quota purposes. Must not exceed 40 characters.")] = None,
        upload_type: Annotated[Optional[StrictStr], Field(description="Upload protocol for media (e.g. \"media\", \"multipart\", \"resumable\").")] = None,
        user_ip: Annotated[Optional[StrictStr], Field(description="Deprecated. Please use quotaUser instead.")] = None,
        delimiter: Annotated[Optional[StrictStr], Field(description="Returns results in a directory-like mode. items will contain only objects whose names, aside from the prefix, do not contain delimiter. Objects whose names, aside from the prefix, contain delimiter will have their name, truncated after the delimiter, returned in prefixes. Duplicate prefixes are omitted.")] = None,
        end_offset: Annotated[Optional[StrictStr], Field(description="Filter results to objects whose names are lexicographically before endOffset. If startOffset is also set, the objects listed will have names between startOffset (inclusive) and endOffset (exclusive).")] = None,
        include_folders_as_prefixes: Annotated[Optional[StrictBool], Field(description="Only applicable if delimiter is set to '/'. If true, will also include folders and managed folders (besides objects) in the returned prefixes.")] = None,
        include_trailing_delimiter: Annotated[Optional[StrictBool], Field(description="If true, objects that end in exactly one instance of delimiter will have their metadata included in items in addition to prefixes.")] = None,
        match_glob: Annotated[Optional[StrictStr], Field(description="Filter results to objects and prefixes that match this glob pattern.")] = None,
        max_results: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Maximum number of items plus prefixes to return in a single page of responses. As duplicate prefixes are omitted, fewer total results may be returned than requested. The service will use this parameter or 1,000 items, whichever is smaller.")] = None,
        page_token: Annotated[Optional[StrictStr], Field(description="A previously-returned page token representing part of the larger set of results to view.")] = None,
        prefix: Annotated[Optional[StrictStr], Field(description="Filter results to objects whose names begin with this prefix.")] = None,
        projection: Annotated[Optional[StrictStr], Field(description="Set of properties to return. Defaults to noAcl.")] = None,
        soft_deleted: Annotated[Optional[StrictBool], Field(description="If true, only soft-deleted object versions will be listed. The default is false. For more information, see Soft Delete.")] = None,
        start_offset: Annotated[Optional[StrictStr], Field(description="Filter results to objects whose names are lexicographically equal to or after startOffset. If endOffset is also set, the objects listed will have names between startOffset (inclusive) and endOffset (exclusive).")] = None,
        user_project: Annotated[Optional[StrictStr], Field(description="The project to be billed for this request. Required for Requester Pays buckets.")] = None,
        versions: Annotated[Optional[StrictBool], Field(description="If true, lists all versions of an object as distinct results. The default is false. For more information, see Object Versioning.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> Objects:
        """storage_objects_list

        Retrieves a list of objects matching the criteria.

        :param bucket: Name of the bucket in which to look for objects. (required)
        :type bucket: str
        :param alt: Data format for the response.
        :type alt: str
        :param fields: Selector specifying which fields to include in a partial response.
        :type fields: str
        :param key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :type key: str
        :param oauth_token: OAuth 2.0 token for the current user.
        :type oauth_token: str
        :param pretty_print: Returns response with indentations and line breaks.
        :type pretty_print: bool
        :param quota_user: An opaque string that represents a user for quota purposes. Must not exceed 40 characters.
        :type quota_user: str
        :param upload_type: Upload protocol for media (e.g. \"media\", \"multipart\", \"resumable\").
        :type upload_type: str
        :param user_ip: Deprecated. Please use quotaUser instead.
        :type user_ip: str
        :param delimiter: Returns results in a directory-like mode. items will contain only objects whose names, aside from the prefix, do not contain delimiter. Objects whose names, aside from the prefix, contain delimiter will have their name, truncated after the delimiter, returned in prefixes. Duplicate prefixes are omitted.
        :type delimiter: str
        :param end_offset: Filter results to objects whose names are lexicographically before endOffset. If startOffset is also set, the objects listed will have names between startOffset (inclusive) and endOffset (exclusive).
        :type end_offset: str
        :param include_folders_as_prefixes: Only applicable if delimiter is set to '/'. If true, will also include folders and managed folders (besides objects) in the returned prefixes.
        :type include_folders_as_prefixes: bool
        :param include_trailing_delimiter: If true, objects that end in exactly one instance of delimiter will have their metadata included in items in addition to prefixes.
        :type include_trailing_delimiter: bool
        :param match_glob: Filter results to objects and prefixes that match this glob pattern.
        :type match_glob: str
        :param max_results: Maximum number of items plus prefixes to return in a single page of responses. As duplicate prefixes are omitted, fewer total results may be returned than requested. The service will use this parameter or 1,000 items, whichever is smaller.
        :type max_results: int
        :param page_token: A previously-returned page token representing part of the larger set of results to view.
        :type page_token: str
        :param prefix: Filter results to objects whose names begin with this prefix.
        :type prefix: str
        :param projection: Set of properties to return. Defaults to noAcl.
        :type projection: str
        :param soft_deleted: If true, only soft-deleted object versions will be listed. The default is false. For more information, see Soft Delete.
        :type soft_deleted: bool
        :param start_offset: Filter results to objects whose names are lexicographically equal to or after startOffset. If endOffset is also set, the objects listed will have names between startOffset (inclusive) and endOffset (exclusive).
        :type start_offset: str
        :param user_project: The project to be billed for this request. Required for Requester Pays buckets.
        :type user_project: str
        :param versions: If true, lists all versions of an object as distinct results. The default is false. For more information, see Object Versioning.
        :type versions: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._storage_objects_list_serialize(
            bucket=bucket,
            alt=alt,
            fields=fields,
            key=key,
            oauth_token=oauth_token,
            pretty_print=pretty_print,
            quota_user=quota_user,
            upload_type=upload_type,
            user_ip=user_ip,
            delimiter=delimiter,
            end_offset=end_offset,
            include_folders_as_prefixes=include_folders_as_prefixes,
            include_trailing_delimiter=include_trailing_delimiter,
            match_glob=match_glob,
            max_results=max_results,
            page_token=page_token,
            prefix=prefix,
            projection=projection,
            soft_deleted=soft_deleted,
            start_offset=start_offset,
            user_project=user_project,
            versions=versions,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Objects",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def storage_objects_list_with_http_info(
        self,
        bucket: Annotated[StrictStr, Field(description="Name of the bucket in which to look for objects.")],
        alt: Annotated[Optional[StrictStr], Field(description="Data format for the response.")] = None,
        fields: Annotated[Optional[StrictStr], Field(description="Selector specifying which fields to include in a partial response.")] = None,
        key: Annotated[Optional[StrictStr], Field(description="API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.")] = None,
        oauth_token: Annotated[Optional[StrictStr], Field(description="OAuth 2.0 token for the current user.")] = None,
        pretty_print: Annotated[Optional[StrictBool], Field(description="Returns response with indentations and line breaks.")] = None,
        quota_user: Annotated[Optional[StrictStr], Field(description="An opaque string that represents a user for quota purposes. Must not exceed 40 characters.")] = None,
        upload_type: Annotated[Optional[StrictStr], Field(description="Upload protocol for media (e.g. \"media\", \"multipart\", \"resumable\").")] = None,
        user_ip: Annotated[Optional[StrictStr], Field(description="Deprecated. Please use quotaUser instead.")] = None,
        delimiter: Annotated[Optional[StrictStr], Field(description="Returns results in a directory-like mode. items will contain only objects whose names, aside from the prefix, do not contain delimiter. Objects whose names, aside from the prefix, contain delimiter will have their name, truncated after the delimiter, returned in prefixes. Duplicate prefixes are omitted.")] = None,
        end_offset: Annotated[Optional[StrictStr], Field(description="Filter results to objects whose names are lexicographically before endOffset. If startOffset is also set, the objects listed will have names between startOffset (inclusive) and endOffset (exclusive).")] = None,
        include_folders_as_prefixes: Annotated[Optional[StrictBool], Field(description="Only applicable if delimiter is set to '/'. If true, will also include folders and managed folders (besides objects) in the returned prefixes.")] = None,
        include_trailing_delimiter: Annotated[Optional[StrictBool], Field(description="If true, objects that end in exactly one instance of delimiter will have their metadata included in items in addition to prefixes.")] = None,
        match_glob: Annotated[Optional[StrictStr], Field(description="Filter results to objects and prefixes that match this glob pattern.")] = None,
        max_results: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Maximum number of items plus prefixes to return in a single page of responses. As duplicate prefixes are omitted, fewer total results may be returned than requested. The service will use this parameter or 1,000 items, whichever is smaller.")] = None,
        page_token: Annotated[Optional[StrictStr], Field(description="A previously-returned page token representing part of the larger set of results to view.")] = None,
        prefix: Annotated[Optional[StrictStr], Field(description="Filter results to objects whose names begin with this prefix.")] = None,
        projection: Annotated[Optional[StrictStr], Field(description="Set of properties to return. Defaults to noAcl.")] = None,
        soft_deleted: Annotated[Optional[StrictBool], Field(description="If true, only soft-deleted object versions will be listed. The default is false. For more information, see Soft Delete.")] = None,
        start_offset: Annotated[Optional[StrictStr], Field(description="Filter results to objects whose names are lexicographically equal to or after startOffset. If endOffset is also set, the objects listed will have names between startOffset (inclusive) and endOffset (exclusive).")] = None,
        user_project: Annotated[Optional[StrictStr], Field(description="The project to be billed for this request. Required for Requester Pays buckets.")] = None,
        versions: Annotated[Optional[StrictBool], Field(description="If true, lists all versions of an object as distinct results. The default is false. For more information, see Object Versioning.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[Objects]:
        """storage_objects_list

        Retrieves a list of objects matching the criteria.

        :param bucket: Name of the bucket in which to look for objects. (required)
        :type bucket: str
        :param alt: Data format for the response.
        :type alt: str
        :param fields: Selector specifying which fields to include in a partial response.
        :type fields: str
        :param key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :type key: str
        :param oauth_token: OAuth 2.0 token for the current user.
        :type oauth_token: str
        :param pretty_print: Returns response with indentations and line breaks.
        :type pretty_print: bool
        :param quota_user: An opaque string that represents a user for quota purposes. Must not exceed 40 characters.
        :type quota_user: str
        :param upload_type: Upload protocol for media (e.g. \"media\", \"multipart\", \"resumable\").
        :type upload_type: str
        :param user_ip: Deprecated. Please use quotaUser instead.
        :type user_ip: str
        :param delimiter: Returns results in a directory-like mode. items will contain only objects whose names, aside from the prefix, do not contain delimiter. Objects whose names, aside from the prefix, contain delimiter will have their name, truncated after the delimiter, returned in prefixes. Duplicate prefixes are omitted.
        :type delimiter: str
        :param end_offset: Filter results to objects whose names are lexicographically before endOffset. If startOffset is also set, the objects listed will have names between startOffset (inclusive) and endOffset (exclusive).
        :type end_offset: str
        :param include_folders_as_prefixes: Only applicable if delimiter is set to '/'. If true, will also include folders and managed folders (besides objects) in the returned prefixes.
        :type include_folders_as_prefixes: bool
        :param include_trailing_delimiter: If true, objects that end in exactly one instance of delimiter will have their metadata included in items in addition to prefixes.
        :type include_trailing_delimiter: bool
        :param match_glob: Filter results to objects and prefixes that match this glob pattern.
        :type match_glob: str
        :param max_results: Maximum number of items plus prefixes to return in a single page of responses. As duplicate prefixes are omitted, fewer total results may be returned than requested. The service will use this parameter or 1,000 items, whichever is smaller.
        :type max_results: int
        :param page_token: A previously-returned page token representing part of the larger set of results to view.
        :type page_token: str
        :param prefix: Filter results to objects whose names begin with this prefix.
        :type prefix: str
        :param projection: Set of properties to return. Defaults to noAcl.
        :type projection: str
        :param soft_deleted: If true, only soft-deleted object versions will be listed. The default is false. For more information, see Soft Delete.
        :type soft_deleted: bool
        :param start_offset: Filter results to objects whose names are lexicographically equal to or after startOffset. If endOffset is also set, the objects listed will have names between startOffset (inclusive) and endOffset (exclusive).
        :type start_offset: str
        :param user_project: The project to be billed for this request. Required for Requester Pays buckets.
        :type user_project: str
        :param versions: If true, lists all versions of an object as distinct results. The default is false. For more information, see Object Versioning.
        :type versions: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._storage_objects_list_serialize(
            bucket=bucket,
            alt=alt,
            fields=fields,
            key=key,
            oauth_token=oauth_token,
            pretty_print=pretty_print,
            quota_user=quota_user,
            upload_type=upload_type,
            user_ip=user_ip,
            delimiter=delimiter,
            end_offset=end_offset,
            include_folders_as_prefixes=include_folders_as_prefixes,
            include_trailing_delimiter=include_trailing_delimiter,
            match_glob=match_glob,
            max_results=max_results,
            page_token=page_token,
            prefix=prefix,
            projection=projection,
            soft_deleted=soft_deleted,
            start_offset=start_offset,
            user_project=user_project,
            versions=versions,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Objects",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def storage_objects_list_without_preload_content(
        self,
        bucket: Annotated[StrictStr, Field(description="Name of the bucket in which to look for objects.")],
        alt: Annotated[Optional[StrictStr], Field(description="Data format for the response.")] = None,
        fields: Annotated[Optional[StrictStr], Field(description="Selector specifying which fields to include in a partial response.")] = None,
        key: Annotated[Optional[StrictStr], Field(description="API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.")] = None,
        oauth_token: Annotated[Optional[StrictStr], Field(description="OAuth 2.0 token for the current user.")] = None,
        pretty_print: Annotated[Optional[StrictBool], Field(description="Returns response with indentations and line breaks.")] = None,
        quota_user: Annotated[Optional[StrictStr], Field(description="An opaque string that represents a user for quota purposes. Must not exceed 40 characters.")] = None,
        upload_type: Annotated[Optional[StrictStr], Field(description="Upload protocol for media (e.g. \"media\", \"multipart\", \"resumable\").")] = None,
        user_ip: Annotated[Optional[StrictStr], Field(description="Deprecated. Please use quotaUser instead.")] = None,
        delimiter: Annotated[Optional[StrictStr], Field(description="Returns results in a directory-like mode. items will contain only objects whose names, aside from the prefix, do not contain delimiter. Objects whose names, aside from the prefix, contain delimiter will have their name, truncated after the delimiter, returned in prefixes. Duplicate prefixes are omitted.")] = None,
        end_offset: Annotated[Optional[StrictStr], Field(description="Filter results to objects whose names are lexicographically before endOffset. If startOffset is also set, the objects listed will have names between startOffset (inclusive) and endOffset (exclusive).")] = None,
        include_folders_as_prefixes: Annotated[Optional[StrictBool], Field(description="Only applicable if delimiter is set to '/'. If true, will also include folders and managed folders (besides objects) in the returned prefixes.")] = None,
        include_trailing_delimiter: Annotated[Optional[StrictBool], Field(description="If true, objects that end in exactly one instance of delimiter will have their metadata included in items in addition to prefixes.")] = None,
        match_glob: Annotated[Optional[StrictStr], Field(description="Filter results to objects and prefixes that match this glob pattern.")] = None,
        max_results: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Maximum number of items plus prefixes to return in a single page of responses. As duplicate prefixes are omitted, fewer total results may be returned than requested. The service will use this parameter or 1,000 items, whichever is smaller.")] = None,
        page_token: Annotated[Optional[StrictStr], Field(description="A previously-returned page token representing part of the larger set of results to view.")] = None,
        prefix: Annotated[Optional[StrictStr], Field(description="Filter results to objects whose names begin with this prefix.")] = None,
        projection: Annotated[Optional[StrictStr], Field(description="Set of properties to return. Defaults to noAcl.")] = None,
        soft_deleted: Annotated[Optional[StrictBool], Field(description="If true, only soft-deleted object versions will be listed. The default is false. For more information, see Soft Delete.")] = None,
        start_offset: Annotated[Optional[StrictStr], Field(description="Filter results to objects whose names are lexicographically equal to or after startOffset. If endOffset is also set, the objects listed will have names between startOffset (inclusive) and endOffset (exclusive).")] = None,
        user_project: Annotated[Optional[StrictStr], Field(description="The project to be billed for this request. Required for Requester Pays buckets.")] = None,
        versions: Annotated[Optional[StrictBool], Field(description="If true, lists all versions of an object as distinct results. The default is false. For more information, see Object Versioning.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """storage_objects_list

        Retrieves a list of objects matching the criteria.

        :param bucket: Name of the bucket in which to look for objects. (required)
        :type bucket: str
        :param alt: Data format for the response.
        :type alt: str
        :param fields: Selector specifying which fields to include in a partial response.
        :type fields: str
        :param key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :type key: str
        :param oauth_token: OAuth 2.0 token for the current user.
        :type oauth_token: str
        :param pretty_print: Returns response with indentations and line breaks.
        :type pretty_print: bool
        :param quota_user: An opaque string that represents a user for quota purposes. Must not exceed 40 characters.
        :type quota_user: str
        :param upload_type: Upload protocol for media (e.g. \"media\", \"multipart\", \"resumable\").
        :type upload_type: str
        :param user_ip: Deprecated. Please use quotaUser instead.
        :type user_ip: str
        :param delimiter: Returns results in a directory-like mode. items will contain only objects whose names, aside from the prefix, do not contain delimiter. Objects whose names, aside from the prefix, contain delimiter will have their name, truncated after the delimiter, returned in prefixes. Duplicate prefixes are omitted.
        :type delimiter: str
        :param end_offset: Filter results to objects whose names are lexicographically before endOffset. If startOffset is also set, the objects listed will have names between startOffset (inclusive) and endOffset (exclusive).
        :type end_offset: str
        :param include_folders_as_prefixes: Only applicable if delimiter is set to '/'. If true, will also include folders and managed folders (besides objects) in the returned prefixes.
        :type include_folders_as_prefixes: bool
        :param include_trailing_delimiter: If true, objects that end in exactly one instance of delimiter will have their metadata included in items in addition to prefixes.
        :type include_trailing_delimiter: bool
        :param match_glob: Filter results to objects and prefixes that match this glob pattern.
        :type match_glob: str
        :param max_results: Maximum number of items plus prefixes to return in a single page of responses. As duplicate prefixes are omitted, fewer total results may be returned than requested. The service will use this parameter or 1,000 items, whichever is smaller.
        :type max_results: int
        :param page_token: A previously-returned page token representing part of the larger set of results to view.
        :type page_token: str
        :param prefix: Filter results to objects whose names begin with this prefix.
        :type prefix: str
        :param projection: Set of properties to return. Defaults to noAcl.
        :type projection: str
        :param soft_deleted: If true, only soft-deleted object versions will be listed. The default is false. For more information, see Soft Delete.
        :type soft_deleted: bool
        :param start_offset: Filter results to objects whose names are lexicographically equal to or after startOffset. If endOffset is also set, the objects listed will have names between startOffset (inclusive) and endOffset (exclusive).
        :type start_offset: str
        :param user_project: The project to be billed for this request. Required for Requester Pays buckets.
        :type user_project: str
        :param versions: If true, lists all versions of an object as distinct results. The default is false. For more information, see Object Versioning.
        :type versions: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._storage_objects_list_serialize(
            bucket=bucket,
            alt=alt,
            fields=fields,
            key=key,
            oauth_token=oauth_token,
            pretty_print=pretty_print,
            quota_user=quota_user,
            upload_type=upload_type,
            user_ip=user_ip,
            delimiter=delimiter,
            end_offset=end_offset,
            include_folders_as_prefixes=include_folders_as_prefixes,
            include_trailing_delimiter=include_trailing_delimiter,
            match_glob=match_glob,
            max_results=max_results,
            page_token=page_token,
            prefix=prefix,
            projection=projection,
            soft_deleted=soft_deleted,
            start_offset=start_offset,
            user_project=user_project,
            versions=versions,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Objects",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _storage_objects_list_serialize(
        self,
        bucket,
        alt,
        fields,
        key,
        oauth_token,
        pretty_print,
        quota_user,
        upload_type,
        user_ip,
        delimiter,
        end_offset,
        include_folders_as_prefixes,
        include_trailing_delimiter,
        match_glob,
        max_results,
        page_token,
        prefix,
        projection,
        soft_deleted,
        start_offset,
        user_project,
        versions,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if bucket is not None:
            _path_params['bucket'] = bucket
        # process the query parameters
        if alt is not None:
            
            _query_params.append(('alt', alt))
            
        if fields is not None:
            
            _query_params.append(('fields', fields))
            
        if key is not None:
            
            _query_params.append(('key', key))
            
        if oauth_token is not None:
            
            _query_params.append(('oauth_token', oauth_token))
            
        if pretty_print is not None:
            
            _query_params.append(('prettyPrint', pretty_print))
            
        if quota_user is not None:
            
            _query_params.append(('quotaUser', quota_user))
            
        if upload_type is not None:
            
            _query_params.append(('uploadType', upload_type))
            
        if user_ip is not None:
            
            _query_params.append(('userIp', user_ip))
            
        if delimiter is not None:
            
            _query_params.append(('delimiter', delimiter))
            
        if end_offset is not None:
            
            _query_params.append(('endOffset', end_offset))
            
        if include_folders_as_prefixes is not None:
            
            _query_params.append(('includeFoldersAsPrefixes', include_folders_as_prefixes))
            
        if include_trailing_delimiter is not None:
            
            _query_params.append(('includeTrailingDelimiter', include_trailing_delimiter))
            
        if match_glob is not None:
            
            _query_params.append(('matchGlob', match_glob))
            
        if max_results is not None:
            
            _query_params.append(('maxResults', max_results))
            
        if page_token is not None:
            
            _query_params.append(('pageToken', page_token))
            
        if prefix is not None:
            
            _query_params.append(('prefix', prefix))
            
        if projection is not None:
            
            _query_params.append(('projection', projection))
            
        if soft_deleted is not None:
            
            _query_params.append(('softDeleted', soft_deleted))
            
        if start_offset is not None:
            
            _query_params.append(('startOffset', start_offset))
            
        if user_project is not None:
            
            _query_params.append(('userProject', user_project))
            
        if versions is not None:
            
            _query_params.append(('versions', versions))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'Oauth2c', 
            'Oauth2'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/b/{bucket}/o',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def storage_objects_patch(
        self,
        bucket: Annotated[StrictStr, Field(description="Name of the bucket in which the object resides.")],
        object: Annotated[StrictStr, Field(description="Name of the object. For information about how to URL encode object names to be path safe, see [Encoding URI Path Parts](https://cloud.google.com/storage/docs/request-endpoints#encoding).")],
        alt: Annotated[Optional[StrictStr], Field(description="Data format for the response.")] = None,
        fields: Annotated[Optional[StrictStr], Field(description="Selector specifying which fields to include in a partial response.")] = None,
        key: Annotated[Optional[StrictStr], Field(description="API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.")] = None,
        oauth_token: Annotated[Optional[StrictStr], Field(description="OAuth 2.0 token for the current user.")] = None,
        pretty_print: Annotated[Optional[StrictBool], Field(description="Returns response with indentations and line breaks.")] = None,
        quota_user: Annotated[Optional[StrictStr], Field(description="An opaque string that represents a user for quota purposes. Must not exceed 40 characters.")] = None,
        upload_type: Annotated[Optional[StrictStr], Field(description="Upload protocol for media (e.g. \"media\", \"multipart\", \"resumable\").")] = None,
        user_ip: Annotated[Optional[StrictStr], Field(description="Deprecated. Please use quotaUser instead.")] = None,
        generation: Annotated[Optional[StrictStr], Field(description="If present, selects a specific revision of this object (as opposed to the latest version, the default).")] = None,
        if_generation_match: Annotated[Optional[StrictStr], Field(description="Makes the operation conditional on whether the object's current generation matches the given value. Setting to 0 makes the operation succeed only if there are no live versions of the object.")] = None,
        if_generation_not_match: Annotated[Optional[StrictStr], Field(description="Makes the operation conditional on whether the object's current generation does not match the given value. If no live object exists, the precondition fails. Setting to 0 makes the operation succeed only if there is a live version of the object.")] = None,
        if_metageneration_match: Annotated[Optional[StrictStr], Field(description="Makes the operation conditional on whether the object's current metageneration matches the given value.")] = None,
        if_metageneration_not_match: Annotated[Optional[StrictStr], Field(description="Makes the operation conditional on whether the object's current metageneration does not match the given value.")] = None,
        override_unlocked_retention: Annotated[Optional[StrictBool], Field(description="Must be true to remove the retention configuration, reduce its unlocked retention period, or change its mode from unlocked to locked.")] = None,
        predefined_acl: Annotated[Optional[StrictStr], Field(description="Apply a predefined set of access controls to this object.")] = None,
        projection: Annotated[Optional[StrictStr], Field(description="Set of properties to return. Defaults to full.")] = None,
        user_project: Annotated[Optional[StrictStr], Field(description="The project to be billed for this request, for Requester Pays buckets.")] = None,
        object2: Optional[Object] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> Object:
        """storage_objects_patch

        Patches an object's metadata.

        :param bucket: Name of the bucket in which the object resides. (required)
        :type bucket: str
        :param object: Name of the object. For information about how to URL encode object names to be path safe, see [Encoding URI Path Parts](https://cloud.google.com/storage/docs/request-endpoints#encoding). (required)
        :type object: str
        :param alt: Data format for the response.
        :type alt: str
        :param fields: Selector specifying which fields to include in a partial response.
        :type fields: str
        :param key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :type key: str
        :param oauth_token: OAuth 2.0 token for the current user.
        :type oauth_token: str
        :param pretty_print: Returns response with indentations and line breaks.
        :type pretty_print: bool
        :param quota_user: An opaque string that represents a user for quota purposes. Must not exceed 40 characters.
        :type quota_user: str
        :param upload_type: Upload protocol for media (e.g. \"media\", \"multipart\", \"resumable\").
        :type upload_type: str
        :param user_ip: Deprecated. Please use quotaUser instead.
        :type user_ip: str
        :param generation: If present, selects a specific revision of this object (as opposed to the latest version, the default).
        :type generation: str
        :param if_generation_match: Makes the operation conditional on whether the object's current generation matches the given value. Setting to 0 makes the operation succeed only if there are no live versions of the object.
        :type if_generation_match: str
        :param if_generation_not_match: Makes the operation conditional on whether the object's current generation does not match the given value. If no live object exists, the precondition fails. Setting to 0 makes the operation succeed only if there is a live version of the object.
        :type if_generation_not_match: str
        :param if_metageneration_match: Makes the operation conditional on whether the object's current metageneration matches the given value.
        :type if_metageneration_match: str
        :param if_metageneration_not_match: Makes the operation conditional on whether the object's current metageneration does not match the given value.
        :type if_metageneration_not_match: str
        :param override_unlocked_retention: Must be true to remove the retention configuration, reduce its unlocked retention period, or change its mode from unlocked to locked.
        :type override_unlocked_retention: bool
        :param predefined_acl: Apply a predefined set of access controls to this object.
        :type predefined_acl: str
        :param projection: Set of properties to return. Defaults to full.
        :type projection: str
        :param user_project: The project to be billed for this request, for Requester Pays buckets.
        :type user_project: str
        :param object2:
        :type object2: Object
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._storage_objects_patch_serialize(
            bucket=bucket,
            object=object,
            alt=alt,
            fields=fields,
            key=key,
            oauth_token=oauth_token,
            pretty_print=pretty_print,
            quota_user=quota_user,
            upload_type=upload_type,
            user_ip=user_ip,
            generation=generation,
            if_generation_match=if_generation_match,
            if_generation_not_match=if_generation_not_match,
            if_metageneration_match=if_metageneration_match,
            if_metageneration_not_match=if_metageneration_not_match,
            override_unlocked_retention=override_unlocked_retention,
            predefined_acl=predefined_acl,
            projection=projection,
            user_project=user_project,
            object2=object2,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def storage_objects_patch_with_http_info(
        self,
        bucket: Annotated[StrictStr, Field(description="Name of the bucket in which the object resides.")],
        object: Annotated[StrictStr, Field(description="Name of the object. For information about how to URL encode object names to be path safe, see [Encoding URI Path Parts](https://cloud.google.com/storage/docs/request-endpoints#encoding).")],
        alt: Annotated[Optional[StrictStr], Field(description="Data format for the response.")] = None,
        fields: Annotated[Optional[StrictStr], Field(description="Selector specifying which fields to include in a partial response.")] = None,
        key: Annotated[Optional[StrictStr], Field(description="API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.")] = None,
        oauth_token: Annotated[Optional[StrictStr], Field(description="OAuth 2.0 token for the current user.")] = None,
        pretty_print: Annotated[Optional[StrictBool], Field(description="Returns response with indentations and line breaks.")] = None,
        quota_user: Annotated[Optional[StrictStr], Field(description="An opaque string that represents a user for quota purposes. Must not exceed 40 characters.")] = None,
        upload_type: Annotated[Optional[StrictStr], Field(description="Upload protocol for media (e.g. \"media\", \"multipart\", \"resumable\").")] = None,
        user_ip: Annotated[Optional[StrictStr], Field(description="Deprecated. Please use quotaUser instead.")] = None,
        generation: Annotated[Optional[StrictStr], Field(description="If present, selects a specific revision of this object (as opposed to the latest version, the default).")] = None,
        if_generation_match: Annotated[Optional[StrictStr], Field(description="Makes the operation conditional on whether the object's current generation matches the given value. Setting to 0 makes the operation succeed only if there are no live versions of the object.")] = None,
        if_generation_not_match: Annotated[Optional[StrictStr], Field(description="Makes the operation conditional on whether the object's current generation does not match the given value. If no live object exists, the precondition fails. Setting to 0 makes the operation succeed only if there is a live version of the object.")] = None,
        if_metageneration_match: Annotated[Optional[StrictStr], Field(description="Makes the operation conditional on whether the object's current metageneration matches the given value.")] = None,
        if_metageneration_not_match: Annotated[Optional[StrictStr], Field(description="Makes the operation conditional on whether the object's current metageneration does not match the given value.")] = None,
        override_unlocked_retention: Annotated[Optional[StrictBool], Field(description="Must be true to remove the retention configuration, reduce its unlocked retention period, or change its mode from unlocked to locked.")] = None,
        predefined_acl: Annotated[Optional[StrictStr], Field(description="Apply a predefined set of access controls to this object.")] = None,
        projection: Annotated[Optional[StrictStr], Field(description="Set of properties to return. Defaults to full.")] = None,
        user_project: Annotated[Optional[StrictStr], Field(description="The project to be billed for this request, for Requester Pays buckets.")] = None,
        object2: Optional[Object] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[Object]:
        """storage_objects_patch

        Patches an object's metadata.

        :param bucket: Name of the bucket in which the object resides. (required)
        :type bucket: str
        :param object: Name of the object. For information about how to URL encode object names to be path safe, see [Encoding URI Path Parts](https://cloud.google.com/storage/docs/request-endpoints#encoding). (required)
        :type object: str
        :param alt: Data format for the response.
        :type alt: str
        :param fields: Selector specifying which fields to include in a partial response.
        :type fields: str
        :param key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :type key: str
        :param oauth_token: OAuth 2.0 token for the current user.
        :type oauth_token: str
        :param pretty_print: Returns response with indentations and line breaks.
        :type pretty_print: bool
        :param quota_user: An opaque string that represents a user for quota purposes. Must not exceed 40 characters.
        :type quota_user: str
        :param upload_type: Upload protocol for media (e.g. \"media\", \"multipart\", \"resumable\").
        :type upload_type: str
        :param user_ip: Deprecated. Please use quotaUser instead.
        :type user_ip: str
        :param generation: If present, selects a specific revision of this object (as opposed to the latest version, the default).
        :type generation: str
        :param if_generation_match: Makes the operation conditional on whether the object's current generation matches the given value. Setting to 0 makes the operation succeed only if there are no live versions of the object.
        :type if_generation_match: str
        :param if_generation_not_match: Makes the operation conditional on whether the object's current generation does not match the given value. If no live object exists, the precondition fails. Setting to 0 makes the operation succeed only if there is a live version of the object.
        :type if_generation_not_match: str
        :param if_metageneration_match: Makes the operation conditional on whether the object's current metageneration matches the given value.
        :type if_metageneration_match: str
        :param if_metageneration_not_match: Makes the operation conditional on whether the object's current metageneration does not match the given value.
        :type if_metageneration_not_match: str
        :param override_unlocked_retention: Must be true to remove the retention configuration, reduce its unlocked retention period, or change its mode from unlocked to locked.
        :type override_unlocked_retention: bool
        :param predefined_acl: Apply a predefined set of access controls to this object.
        :type predefined_acl: str
        :param projection: Set of properties to return. Defaults to full.
        :type projection: str
        :param user_project: The project to be billed for this request, for Requester Pays buckets.
        :type user_project: str
        :param object2:
        :type object2: Object
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._storage_objects_patch_serialize(
            bucket=bucket,
            object=object,
            alt=alt,
            fields=fields,
            key=key,
            oauth_token=oauth_token,
            pretty_print=pretty_print,
            quota_user=quota_user,
            upload_type=upload_type,
            user_ip=user_ip,
            generation=generation,
            if_generation_match=if_generation_match,
            if_generation_not_match=if_generation_not_match,
            if_metageneration_match=if_metageneration_match,
            if_metageneration_not_match=if_metageneration_not_match,
            override_unlocked_retention=override_unlocked_retention,
            predefined_acl=predefined_acl,
            projection=projection,
            user_project=user_project,
            object2=object2,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def storage_objects_patch_without_preload_content(
        self,
        bucket: Annotated[StrictStr, Field(description="Name of the bucket in which the object resides.")],
        object: Annotated[StrictStr, Field(description="Name of the object. For information about how to URL encode object names to be path safe, see [Encoding URI Path Parts](https://cloud.google.com/storage/docs/request-endpoints#encoding).")],
        alt: Annotated[Optional[StrictStr], Field(description="Data format for the response.")] = None,
        fields: Annotated[Optional[StrictStr], Field(description="Selector specifying which fields to include in a partial response.")] = None,
        key: Annotated[Optional[StrictStr], Field(description="API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.")] = None,
        oauth_token: Annotated[Optional[StrictStr], Field(description="OAuth 2.0 token for the current user.")] = None,
        pretty_print: Annotated[Optional[StrictBool], Field(description="Returns response with indentations and line breaks.")] = None,
        quota_user: Annotated[Optional[StrictStr], Field(description="An opaque string that represents a user for quota purposes. Must not exceed 40 characters.")] = None,
        upload_type: Annotated[Optional[StrictStr], Field(description="Upload protocol for media (e.g. \"media\", \"multipart\", \"resumable\").")] = None,
        user_ip: Annotated[Optional[StrictStr], Field(description="Deprecated. Please use quotaUser instead.")] = None,
        generation: Annotated[Optional[StrictStr], Field(description="If present, selects a specific revision of this object (as opposed to the latest version, the default).")] = None,
        if_generation_match: Annotated[Optional[StrictStr], Field(description="Makes the operation conditional on whether the object's current generation matches the given value. Setting to 0 makes the operation succeed only if there are no live versions of the object.")] = None,
        if_generation_not_match: Annotated[Optional[StrictStr], Field(description="Makes the operation conditional on whether the object's current generation does not match the given value. If no live object exists, the precondition fails. Setting to 0 makes the operation succeed only if there is a live version of the object.")] = None,
        if_metageneration_match: Annotated[Optional[StrictStr], Field(description="Makes the operation conditional on whether the object's current metageneration matches the given value.")] = None,
        if_metageneration_not_match: Annotated[Optional[StrictStr], Field(description="Makes the operation conditional on whether the object's current metageneration does not match the given value.")] = None,
        override_unlocked_retention: Annotated[Optional[StrictBool], Field(description="Must be true to remove the retention configuration, reduce its unlocked retention period, or change its mode from unlocked to locked.")] = None,
        predefined_acl: Annotated[Optional[StrictStr], Field(description="Apply a predefined set of access controls to this object.")] = None,
        projection: Annotated[Optional[StrictStr], Field(description="Set of properties to return. Defaults to full.")] = None,
        user_project: Annotated[Optional[StrictStr], Field(description="The project to be billed for this request, for Requester Pays buckets.")] = None,
        object2: Optional[Object] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """storage_objects_patch

        Patches an object's metadata.

        :param bucket: Name of the bucket in which the object resides. (required)
        :type bucket: str
        :param object: Name of the object. For information about how to URL encode object names to be path safe, see [Encoding URI Path Parts](https://cloud.google.com/storage/docs/request-endpoints#encoding). (required)
        :type object: str
        :param alt: Data format for the response.
        :type alt: str
        :param fields: Selector specifying which fields to include in a partial response.
        :type fields: str
        :param key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :type key: str
        :param oauth_token: OAuth 2.0 token for the current user.
        :type oauth_token: str
        :param pretty_print: Returns response with indentations and line breaks.
        :type pretty_print: bool
        :param quota_user: An opaque string that represents a user for quota purposes. Must not exceed 40 characters.
        :type quota_user: str
        :param upload_type: Upload protocol for media (e.g. \"media\", \"multipart\", \"resumable\").
        :type upload_type: str
        :param user_ip: Deprecated. Please use quotaUser instead.
        :type user_ip: str
        :param generation: If present, selects a specific revision of this object (as opposed to the latest version, the default).
        :type generation: str
        :param if_generation_match: Makes the operation conditional on whether the object's current generation matches the given value. Setting to 0 makes the operation succeed only if there are no live versions of the object.
        :type if_generation_match: str
        :param if_generation_not_match: Makes the operation conditional on whether the object's current generation does not match the given value. If no live object exists, the precondition fails. Setting to 0 makes the operation succeed only if there is a live version of the object.
        :type if_generation_not_match: str
        :param if_metageneration_match: Makes the operation conditional on whether the object's current metageneration matches the given value.
        :type if_metageneration_match: str
        :param if_metageneration_not_match: Makes the operation conditional on whether the object's current metageneration does not match the given value.
        :type if_metageneration_not_match: str
        :param override_unlocked_retention: Must be true to remove the retention configuration, reduce its unlocked retention period, or change its mode from unlocked to locked.
        :type override_unlocked_retention: bool
        :param predefined_acl: Apply a predefined set of access controls to this object.
        :type predefined_acl: str
        :param projection: Set of properties to return. Defaults to full.
        :type projection: str
        :param user_project: The project to be billed for this request, for Requester Pays buckets.
        :type user_project: str
        :param object2:
        :type object2: Object
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._storage_objects_patch_serialize(
            bucket=bucket,
            object=object,
            alt=alt,
            fields=fields,
            key=key,
            oauth_token=oauth_token,
            pretty_print=pretty_print,
            quota_user=quota_user,
            upload_type=upload_type,
            user_ip=user_ip,
            generation=generation,
            if_generation_match=if_generation_match,
            if_generation_not_match=if_generation_not_match,
            if_metageneration_match=if_metageneration_match,
            if_metageneration_not_match=if_metageneration_not_match,
            override_unlocked_retention=override_unlocked_retention,
            predefined_acl=predefined_acl,
            projection=projection,
            user_project=user_project,
            object2=object2,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _storage_objects_patch_serialize(
        self,
        bucket,
        object,
        alt,
        fields,
        key,
        oauth_token,
        pretty_print,
        quota_user,
        upload_type,
        user_ip,
        generation,
        if_generation_match,
        if_generation_not_match,
        if_metageneration_match,
        if_metageneration_not_match,
        override_unlocked_retention,
        predefined_acl,
        projection,
        user_project,
        object2,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if bucket is not None:
            _path_params['bucket'] = bucket
        if object is not None:
            _path_params['object'] = object
        # process the query parameters
        if alt is not None:
            
            _query_params.append(('alt', alt))
            
        if fields is not None:
            
            _query_params.append(('fields', fields))
            
        if key is not None:
            
            _query_params.append(('key', key))
            
        if oauth_token is not None:
            
            _query_params.append(('oauth_token', oauth_token))
            
        if pretty_print is not None:
            
            _query_params.append(('prettyPrint', pretty_print))
            
        if quota_user is not None:
            
            _query_params.append(('quotaUser', quota_user))
            
        if upload_type is not None:
            
            _query_params.append(('uploadType', upload_type))
            
        if user_ip is not None:
            
            _query_params.append(('userIp', user_ip))
            
        if generation is not None:
            
            _query_params.append(('generation', generation))
            
        if if_generation_match is not None:
            
            _query_params.append(('ifGenerationMatch', if_generation_match))
            
        if if_generation_not_match is not None:
            
            _query_params.append(('ifGenerationNotMatch', if_generation_not_match))
            
        if if_metageneration_match is not None:
            
            _query_params.append(('ifMetagenerationMatch', if_metageneration_match))
            
        if if_metageneration_not_match is not None:
            
            _query_params.append(('ifMetagenerationNotMatch', if_metageneration_not_match))
            
        if override_unlocked_retention is not None:
            
            _query_params.append(('overrideUnlockedRetention', override_unlocked_retention))
            
        if predefined_acl is not None:
            
            _query_params.append(('predefinedAcl', predefined_acl))
            
        if projection is not None:
            
            _query_params.append(('projection', projection))
            
        if user_project is not None:
            
            _query_params.append(('userProject', user_project))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if object2 is not None:
            _body_params = object2


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'Oauth2c', 
            'Oauth2'
        ]

        return self.api_client.param_serialize(
            method='PATCH',
            resource_path='/b/{bucket}/o/{object}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def storage_objects_restore(
        self,
        bucket: Annotated[StrictStr, Field(description="Name of the bucket in which the object resides.")],
        object: Annotated[StrictStr, Field(description="Name of the object. For information about how to URL encode object names to be path safe, see Encoding URI Path Parts.")],
        generation: Annotated[StrictStr, Field(description="Selects a specific revision of this object.")],
        alt: Annotated[Optional[StrictStr], Field(description="Data format for the response.")] = None,
        fields: Annotated[Optional[StrictStr], Field(description="Selector specifying which fields to include in a partial response.")] = None,
        key: Annotated[Optional[StrictStr], Field(description="API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.")] = None,
        oauth_token: Annotated[Optional[StrictStr], Field(description="OAuth 2.0 token for the current user.")] = None,
        pretty_print: Annotated[Optional[StrictBool], Field(description="Returns response with indentations and line breaks.")] = None,
        quota_user: Annotated[Optional[StrictStr], Field(description="An opaque string that represents a user for quota purposes. Must not exceed 40 characters.")] = None,
        upload_type: Annotated[Optional[StrictStr], Field(description="Upload protocol for media (e.g. \"media\", \"multipart\", \"resumable\").")] = None,
        user_ip: Annotated[Optional[StrictStr], Field(description="Deprecated. Please use quotaUser instead.")] = None,
        copy_source_acl: Annotated[Optional[StrictBool], Field(description="If true, copies the source object's ACL; otherwise, uses the bucket's default object ACL. The default is false.")] = None,
        if_generation_match: Annotated[Optional[StrictStr], Field(description="Makes the operation conditional on whether the object's one live generation matches the given value. Setting to 0 makes the operation succeed only if there are no live versions of the object.")] = None,
        if_generation_not_match: Annotated[Optional[StrictStr], Field(description="Makes the operation conditional on whether none of the object's live generations match the given value. If no live object exists, the precondition fails. Setting to 0 makes the operation succeed only if there is a live version of the object.")] = None,
        if_metageneration_match: Annotated[Optional[StrictStr], Field(description="Makes the operation conditional on whether the object's one live metageneration matches the given value.")] = None,
        if_metageneration_not_match: Annotated[Optional[StrictStr], Field(description="Makes the operation conditional on whether none of the object's live metagenerations match the given value.")] = None,
        projection: Annotated[Optional[StrictStr], Field(description="Set of properties to return. Defaults to full.")] = None,
        user_project: Annotated[Optional[StrictStr], Field(description="The project to be billed for this request. Required for Requester Pays buckets.")] = None,
        object2: Optional[Object] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> Object:
        """storage_objects_restore

        Restores a soft-deleted object.

        :param bucket: Name of the bucket in which the object resides. (required)
        :type bucket: str
        :param object: Name of the object. For information about how to URL encode object names to be path safe, see Encoding URI Path Parts. (required)
        :type object: str
        :param generation: Selects a specific revision of this object. (required)
        :type generation: str
        :param alt: Data format for the response.
        :type alt: str
        :param fields: Selector specifying which fields to include in a partial response.
        :type fields: str
        :param key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :type key: str
        :param oauth_token: OAuth 2.0 token for the current user.
        :type oauth_token: str
        :param pretty_print: Returns response with indentations and line breaks.
        :type pretty_print: bool
        :param quota_user: An opaque string that represents a user for quota purposes. Must not exceed 40 characters.
        :type quota_user: str
        :param upload_type: Upload protocol for media (e.g. \"media\", \"multipart\", \"resumable\").
        :type upload_type: str
        :param user_ip: Deprecated. Please use quotaUser instead.
        :type user_ip: str
        :param copy_source_acl: If true, copies the source object's ACL; otherwise, uses the bucket's default object ACL. The default is false.
        :type copy_source_acl: bool
        :param if_generation_match: Makes the operation conditional on whether the object's one live generation matches the given value. Setting to 0 makes the operation succeed only if there are no live versions of the object.
        :type if_generation_match: str
        :param if_generation_not_match: Makes the operation conditional on whether none of the object's live generations match the given value. If no live object exists, the precondition fails. Setting to 0 makes the operation succeed only if there is a live version of the object.
        :type if_generation_not_match: str
        :param if_metageneration_match: Makes the operation conditional on whether the object's one live metageneration matches the given value.
        :type if_metageneration_match: str
        :param if_metageneration_not_match: Makes the operation conditional on whether none of the object's live metagenerations match the given value.
        :type if_metageneration_not_match: str
        :param projection: Set of properties to return. Defaults to full.
        :type projection: str
        :param user_project: The project to be billed for this request. Required for Requester Pays buckets.
        :type user_project: str
        :param object2:
        :type object2: Object
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._storage_objects_restore_serialize(
            bucket=bucket,
            object=object,
            generation=generation,
            alt=alt,
            fields=fields,
            key=key,
            oauth_token=oauth_token,
            pretty_print=pretty_print,
            quota_user=quota_user,
            upload_type=upload_type,
            user_ip=user_ip,
            copy_source_acl=copy_source_acl,
            if_generation_match=if_generation_match,
            if_generation_not_match=if_generation_not_match,
            if_metageneration_match=if_metageneration_match,
            if_metageneration_not_match=if_metageneration_not_match,
            projection=projection,
            user_project=user_project,
            object2=object2,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def storage_objects_restore_with_http_info(
        self,
        bucket: Annotated[StrictStr, Field(description="Name of the bucket in which the object resides.")],
        object: Annotated[StrictStr, Field(description="Name of the object. For information about how to URL encode object names to be path safe, see Encoding URI Path Parts.")],
        generation: Annotated[StrictStr, Field(description="Selects a specific revision of this object.")],
        alt: Annotated[Optional[StrictStr], Field(description="Data format for the response.")] = None,
        fields: Annotated[Optional[StrictStr], Field(description="Selector specifying which fields to include in a partial response.")] = None,
        key: Annotated[Optional[StrictStr], Field(description="API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.")] = None,
        oauth_token: Annotated[Optional[StrictStr], Field(description="OAuth 2.0 token for the current user.")] = None,
        pretty_print: Annotated[Optional[StrictBool], Field(description="Returns response with indentations and line breaks.")] = None,
        quota_user: Annotated[Optional[StrictStr], Field(description="An opaque string that represents a user for quota purposes. Must not exceed 40 characters.")] = None,
        upload_type: Annotated[Optional[StrictStr], Field(description="Upload protocol for media (e.g. \"media\", \"multipart\", \"resumable\").")] = None,
        user_ip: Annotated[Optional[StrictStr], Field(description="Deprecated. Please use quotaUser instead.")] = None,
        copy_source_acl: Annotated[Optional[StrictBool], Field(description="If true, copies the source object's ACL; otherwise, uses the bucket's default object ACL. The default is false.")] = None,
        if_generation_match: Annotated[Optional[StrictStr], Field(description="Makes the operation conditional on whether the object's one live generation matches the given value. Setting to 0 makes the operation succeed only if there are no live versions of the object.")] = None,
        if_generation_not_match: Annotated[Optional[StrictStr], Field(description="Makes the operation conditional on whether none of the object's live generations match the given value. If no live object exists, the precondition fails. Setting to 0 makes the operation succeed only if there is a live version of the object.")] = None,
        if_metageneration_match: Annotated[Optional[StrictStr], Field(description="Makes the operation conditional on whether the object's one live metageneration matches the given value.")] = None,
        if_metageneration_not_match: Annotated[Optional[StrictStr], Field(description="Makes the operation conditional on whether none of the object's live metagenerations match the given value.")] = None,
        projection: Annotated[Optional[StrictStr], Field(description="Set of properties to return. Defaults to full.")] = None,
        user_project: Annotated[Optional[StrictStr], Field(description="The project to be billed for this request. Required for Requester Pays buckets.")] = None,
        object2: Optional[Object] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[Object]:
        """storage_objects_restore

        Restores a soft-deleted object.

        :param bucket: Name of the bucket in which the object resides. (required)
        :type bucket: str
        :param object: Name of the object. For information about how to URL encode object names to be path safe, see Encoding URI Path Parts. (required)
        :type object: str
        :param generation: Selects a specific revision of this object. (required)
        :type generation: str
        :param alt: Data format for the response.
        :type alt: str
        :param fields: Selector specifying which fields to include in a partial response.
        :type fields: str
        :param key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :type key: str
        :param oauth_token: OAuth 2.0 token for the current user.
        :type oauth_token: str
        :param pretty_print: Returns response with indentations and line breaks.
        :type pretty_print: bool
        :param quota_user: An opaque string that represents a user for quota purposes. Must not exceed 40 characters.
        :type quota_user: str
        :param upload_type: Upload protocol for media (e.g. \"media\", \"multipart\", \"resumable\").
        :type upload_type: str
        :param user_ip: Deprecated. Please use quotaUser instead.
        :type user_ip: str
        :param copy_source_acl: If true, copies the source object's ACL; otherwise, uses the bucket's default object ACL. The default is false.
        :type copy_source_acl: bool
        :param if_generation_match: Makes the operation conditional on whether the object's one live generation matches the given value. Setting to 0 makes the operation succeed only if there are no live versions of the object.
        :type if_generation_match: str
        :param if_generation_not_match: Makes the operation conditional on whether none of the object's live generations match the given value. If no live object exists, the precondition fails. Setting to 0 makes the operation succeed only if there is a live version of the object.
        :type if_generation_not_match: str
        :param if_metageneration_match: Makes the operation conditional on whether the object's one live metageneration matches the given value.
        :type if_metageneration_match: str
        :param if_metageneration_not_match: Makes the operation conditional on whether none of the object's live metagenerations match the given value.
        :type if_metageneration_not_match: str
        :param projection: Set of properties to return. Defaults to full.
        :type projection: str
        :param user_project: The project to be billed for this request. Required for Requester Pays buckets.
        :type user_project: str
        :param object2:
        :type object2: Object
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._storage_objects_restore_serialize(
            bucket=bucket,
            object=object,
            generation=generation,
            alt=alt,
            fields=fields,
            key=key,
            oauth_token=oauth_token,
            pretty_print=pretty_print,
            quota_user=quota_user,
            upload_type=upload_type,
            user_ip=user_ip,
            copy_source_acl=copy_source_acl,
            if_generation_match=if_generation_match,
            if_generation_not_match=if_generation_not_match,
            if_metageneration_match=if_metageneration_match,
            if_metageneration_not_match=if_metageneration_not_match,
            projection=projection,
            user_project=user_project,
            object2=object2,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def storage_objects_restore_without_preload_content(
        self,
        bucket: Annotated[StrictStr, Field(description="Name of the bucket in which the object resides.")],
        object: Annotated[StrictStr, Field(description="Name of the object. For information about how to URL encode object names to be path safe, see Encoding URI Path Parts.")],
        generation: Annotated[StrictStr, Field(description="Selects a specific revision of this object.")],
        alt: Annotated[Optional[StrictStr], Field(description="Data format for the response.")] = None,
        fields: Annotated[Optional[StrictStr], Field(description="Selector specifying which fields to include in a partial response.")] = None,
        key: Annotated[Optional[StrictStr], Field(description="API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.")] = None,
        oauth_token: Annotated[Optional[StrictStr], Field(description="OAuth 2.0 token for the current user.")] = None,
        pretty_print: Annotated[Optional[StrictBool], Field(description="Returns response with indentations and line breaks.")] = None,
        quota_user: Annotated[Optional[StrictStr], Field(description="An opaque string that represents a user for quota purposes. Must not exceed 40 characters.")] = None,
        upload_type: Annotated[Optional[StrictStr], Field(description="Upload protocol for media (e.g. \"media\", \"multipart\", \"resumable\").")] = None,
        user_ip: Annotated[Optional[StrictStr], Field(description="Deprecated. Please use quotaUser instead.")] = None,
        copy_source_acl: Annotated[Optional[StrictBool], Field(description="If true, copies the source object's ACL; otherwise, uses the bucket's default object ACL. The default is false.")] = None,
        if_generation_match: Annotated[Optional[StrictStr], Field(description="Makes the operation conditional on whether the object's one live generation matches the given value. Setting to 0 makes the operation succeed only if there are no live versions of the object.")] = None,
        if_generation_not_match: Annotated[Optional[StrictStr], Field(description="Makes the operation conditional on whether none of the object's live generations match the given value. If no live object exists, the precondition fails. Setting to 0 makes the operation succeed only if there is a live version of the object.")] = None,
        if_metageneration_match: Annotated[Optional[StrictStr], Field(description="Makes the operation conditional on whether the object's one live metageneration matches the given value.")] = None,
        if_metageneration_not_match: Annotated[Optional[StrictStr], Field(description="Makes the operation conditional on whether none of the object's live metagenerations match the given value.")] = None,
        projection: Annotated[Optional[StrictStr], Field(description="Set of properties to return. Defaults to full.")] = None,
        user_project: Annotated[Optional[StrictStr], Field(description="The project to be billed for this request. Required for Requester Pays buckets.")] = None,
        object2: Optional[Object] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """storage_objects_restore

        Restores a soft-deleted object.

        :param bucket: Name of the bucket in which the object resides. (required)
        :type bucket: str
        :param object: Name of the object. For information about how to URL encode object names to be path safe, see Encoding URI Path Parts. (required)
        :type object: str
        :param generation: Selects a specific revision of this object. (required)
        :type generation: str
        :param alt: Data format for the response.
        :type alt: str
        :param fields: Selector specifying which fields to include in a partial response.
        :type fields: str
        :param key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :type key: str
        :param oauth_token: OAuth 2.0 token for the current user.
        :type oauth_token: str
        :param pretty_print: Returns response with indentations and line breaks.
        :type pretty_print: bool
        :param quota_user: An opaque string that represents a user for quota purposes. Must not exceed 40 characters.
        :type quota_user: str
        :param upload_type: Upload protocol for media (e.g. \"media\", \"multipart\", \"resumable\").
        :type upload_type: str
        :param user_ip: Deprecated. Please use quotaUser instead.
        :type user_ip: str
        :param copy_source_acl: If true, copies the source object's ACL; otherwise, uses the bucket's default object ACL. The default is false.
        :type copy_source_acl: bool
        :param if_generation_match: Makes the operation conditional on whether the object's one live generation matches the given value. Setting to 0 makes the operation succeed only if there are no live versions of the object.
        :type if_generation_match: str
        :param if_generation_not_match: Makes the operation conditional on whether none of the object's live generations match the given value. If no live object exists, the precondition fails. Setting to 0 makes the operation succeed only if there is a live version of the object.
        :type if_generation_not_match: str
        :param if_metageneration_match: Makes the operation conditional on whether the object's one live metageneration matches the given value.
        :type if_metageneration_match: str
        :param if_metageneration_not_match: Makes the operation conditional on whether none of the object's live metagenerations match the given value.
        :type if_metageneration_not_match: str
        :param projection: Set of properties to return. Defaults to full.
        :type projection: str
        :param user_project: The project to be billed for this request. Required for Requester Pays buckets.
        :type user_project: str
        :param object2:
        :type object2: Object
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._storage_objects_restore_serialize(
            bucket=bucket,
            object=object,
            generation=generation,
            alt=alt,
            fields=fields,
            key=key,
            oauth_token=oauth_token,
            pretty_print=pretty_print,
            quota_user=quota_user,
            upload_type=upload_type,
            user_ip=user_ip,
            copy_source_acl=copy_source_acl,
            if_generation_match=if_generation_match,
            if_generation_not_match=if_generation_not_match,
            if_metageneration_match=if_metageneration_match,
            if_metageneration_not_match=if_metageneration_not_match,
            projection=projection,
            user_project=user_project,
            object2=object2,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _storage_objects_restore_serialize(
        self,
        bucket,
        object,
        generation,
        alt,
        fields,
        key,
        oauth_token,
        pretty_print,
        quota_user,
        upload_type,
        user_ip,
        copy_source_acl,
        if_generation_match,
        if_generation_not_match,
        if_metageneration_match,
        if_metageneration_not_match,
        projection,
        user_project,
        object2,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if bucket is not None:
            _path_params['bucket'] = bucket
        if object is not None:
            _path_params['object'] = object
        # process the query parameters
        if alt is not None:
            
            _query_params.append(('alt', alt))
            
        if fields is not None:
            
            _query_params.append(('fields', fields))
            
        if key is not None:
            
            _query_params.append(('key', key))
            
        if oauth_token is not None:
            
            _query_params.append(('oauth_token', oauth_token))
            
        if pretty_print is not None:
            
            _query_params.append(('prettyPrint', pretty_print))
            
        if quota_user is not None:
            
            _query_params.append(('quotaUser', quota_user))
            
        if upload_type is not None:
            
            _query_params.append(('uploadType', upload_type))
            
        if user_ip is not None:
            
            _query_params.append(('userIp', user_ip))
            
        if copy_source_acl is not None:
            
            _query_params.append(('copySourceAcl', copy_source_acl))
            
        if generation is not None:
            
            _query_params.append(('generation', generation))
            
        if if_generation_match is not None:
            
            _query_params.append(('ifGenerationMatch', if_generation_match))
            
        if if_generation_not_match is not None:
            
            _query_params.append(('ifGenerationNotMatch', if_generation_not_match))
            
        if if_metageneration_match is not None:
            
            _query_params.append(('ifMetagenerationMatch', if_metageneration_match))
            
        if if_metageneration_not_match is not None:
            
            _query_params.append(('ifMetagenerationNotMatch', if_metageneration_not_match))
            
        if projection is not None:
            
            _query_params.append(('projection', projection))
            
        if user_project is not None:
            
            _query_params.append(('userProject', user_project))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if object2 is not None:
            _body_params = object2


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'Oauth2c', 
            'Oauth2'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/b/{bucket}/o/{object}/restore',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def storage_objects_rewrite(
        self,
        source_bucket: Annotated[StrictStr, Field(description="Name of the bucket in which to find the source object.")],
        source_object: Annotated[StrictStr, Field(description="Name of the source object. For information about how to URL encode object names to be path safe, see [Encoding URI Path Parts](https://cloud.google.com/storage/docs/request-endpoints#encoding).")],
        destination_bucket: Annotated[StrictStr, Field(description="Name of the bucket in which to store the new object. Overrides the provided object metadata's bucket value, if any.")],
        destination_object: Annotated[StrictStr, Field(description="Name of the new object. Required when the object metadata is not otherwise provided. Overrides the object metadata's name value, if any. For information about how to URL encode object names to be path safe, see [Encoding URI Path Parts](https://cloud.google.com/storage/docs/request-endpoints#encoding).")],
        alt: Annotated[Optional[StrictStr], Field(description="Data format for the response.")] = None,
        fields: Annotated[Optional[StrictStr], Field(description="Selector specifying which fields to include in a partial response.")] = None,
        key: Annotated[Optional[StrictStr], Field(description="API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.")] = None,
        oauth_token: Annotated[Optional[StrictStr], Field(description="OAuth 2.0 token for the current user.")] = None,
        pretty_print: Annotated[Optional[StrictBool], Field(description="Returns response with indentations and line breaks.")] = None,
        quota_user: Annotated[Optional[StrictStr], Field(description="An opaque string that represents a user for quota purposes. Must not exceed 40 characters.")] = None,
        upload_type: Annotated[Optional[StrictStr], Field(description="Upload protocol for media (e.g. \"media\", \"multipart\", \"resumable\").")] = None,
        user_ip: Annotated[Optional[StrictStr], Field(description="Deprecated. Please use quotaUser instead.")] = None,
        destination_kms_key_name: Annotated[Optional[StrictStr], Field(description="Resource name of the Cloud KMS key, of the form projects/my-project/locations/global/keyRings/my-kr/cryptoKeys/my-key, that will be used to encrypt the object. Overrides the object metadata's kms_key_name value, if any.")] = None,
        destination_predefined_acl: Annotated[Optional[StrictStr], Field(description="Apply a predefined set of access controls to the destination object.")] = None,
        if_generation_match: Annotated[Optional[StrictStr], Field(description="Makes the operation conditional on whether the object's current generation matches the given value. Setting to 0 makes the operation succeed only if there are no live versions of the object.")] = None,
        if_generation_not_match: Annotated[Optional[StrictStr], Field(description="Makes the operation conditional on whether the object's current generation does not match the given value. If no live object exists, the precondition fails. Setting to 0 makes the operation succeed only if there is a live version of the object.")] = None,
        if_metageneration_match: Annotated[Optional[StrictStr], Field(description="Makes the operation conditional on whether the destination object's current metageneration matches the given value.")] = None,
        if_metageneration_not_match: Annotated[Optional[StrictStr], Field(description="Makes the operation conditional on whether the destination object's current metageneration does not match the given value.")] = None,
        if_source_generation_match: Annotated[Optional[StrictStr], Field(description="Makes the operation conditional on whether the source object's current generation matches the given value.")] = None,
        if_source_generation_not_match: Annotated[Optional[StrictStr], Field(description="Makes the operation conditional on whether the source object's current generation does not match the given value.")] = None,
        if_source_metageneration_match: Annotated[Optional[StrictStr], Field(description="Makes the operation conditional on whether the source object's current metageneration matches the given value.")] = None,
        if_source_metageneration_not_match: Annotated[Optional[StrictStr], Field(description="Makes the operation conditional on whether the source object's current metageneration does not match the given value.")] = None,
        max_bytes_rewritten_per_call: Annotated[Optional[StrictStr], Field(description="The maximum number of bytes that will be rewritten per rewrite request. Most callers shouldn't need to specify this parameter - it is primarily in place to support testing. If specified the value must be an integral multiple of 1 MiB (1048576). Also, this only applies to requests where the source and destination span locations and/or storage classes. Finally, this value must not change across rewrite calls else you'll get an error that the rewriteToken is invalid.")] = None,
        projection: Annotated[Optional[StrictStr], Field(description="Set of properties to return. Defaults to noAcl, unless the object resource specifies the acl property, when it defaults to full.")] = None,
        rewrite_token: Annotated[Optional[StrictStr], Field(description="Include this field (from the previous rewrite response) on each rewrite request after the first one, until the rewrite response 'done' flag is true. Calls that provide a rewriteToken can omit all other request fields, but if included those fields must match the values provided in the first rewrite request.")] = None,
        source_generation: Annotated[Optional[StrictStr], Field(description="If present, selects a specific revision of the source object (as opposed to the latest version, the default).")] = None,
        user_project: Annotated[Optional[StrictStr], Field(description="The project to be billed for this request. Required for Requester Pays buckets.")] = None,
        object: Optional[Object] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RewriteResponse:
        """storage_objects_rewrite

        Rewrites a source object to a destination object. Optionally overrides metadata.

        :param source_bucket: Name of the bucket in which to find the source object. (required)
        :type source_bucket: str
        :param source_object: Name of the source object. For information about how to URL encode object names to be path safe, see [Encoding URI Path Parts](https://cloud.google.com/storage/docs/request-endpoints#encoding). (required)
        :type source_object: str
        :param destination_bucket: Name of the bucket in which to store the new object. Overrides the provided object metadata's bucket value, if any. (required)
        :type destination_bucket: str
        :param destination_object: Name of the new object. Required when the object metadata is not otherwise provided. Overrides the object metadata's name value, if any. For information about how to URL encode object names to be path safe, see [Encoding URI Path Parts](https://cloud.google.com/storage/docs/request-endpoints#encoding). (required)
        :type destination_object: str
        :param alt: Data format for the response.
        :type alt: str
        :param fields: Selector specifying which fields to include in a partial response.
        :type fields: str
        :param key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :type key: str
        :param oauth_token: OAuth 2.0 token for the current user.
        :type oauth_token: str
        :param pretty_print: Returns response with indentations and line breaks.
        :type pretty_print: bool
        :param quota_user: An opaque string that represents a user for quota purposes. Must not exceed 40 characters.
        :type quota_user: str
        :param upload_type: Upload protocol for media (e.g. \"media\", \"multipart\", \"resumable\").
        :type upload_type: str
        :param user_ip: Deprecated. Please use quotaUser instead.
        :type user_ip: str
        :param destination_kms_key_name: Resource name of the Cloud KMS key, of the form projects/my-project/locations/global/keyRings/my-kr/cryptoKeys/my-key, that will be used to encrypt the object. Overrides the object metadata's kms_key_name value, if any.
        :type destination_kms_key_name: str
        :param destination_predefined_acl: Apply a predefined set of access controls to the destination object.
        :type destination_predefined_acl: str
        :param if_generation_match: Makes the operation conditional on whether the object's current generation matches the given value. Setting to 0 makes the operation succeed only if there are no live versions of the object.
        :type if_generation_match: str
        :param if_generation_not_match: Makes the operation conditional on whether the object's current generation does not match the given value. If no live object exists, the precondition fails. Setting to 0 makes the operation succeed only if there is a live version of the object.
        :type if_generation_not_match: str
        :param if_metageneration_match: Makes the operation conditional on whether the destination object's current metageneration matches the given value.
        :type if_metageneration_match: str
        :param if_metageneration_not_match: Makes the operation conditional on whether the destination object's current metageneration does not match the given value.
        :type if_metageneration_not_match: str
        :param if_source_generation_match: Makes the operation conditional on whether the source object's current generation matches the given value.
        :type if_source_generation_match: str
        :param if_source_generation_not_match: Makes the operation conditional on whether the source object's current generation does not match the given value.
        :type if_source_generation_not_match: str
        :param if_source_metageneration_match: Makes the operation conditional on whether the source object's current metageneration matches the given value.
        :type if_source_metageneration_match: str
        :param if_source_metageneration_not_match: Makes the operation conditional on whether the source object's current metageneration does not match the given value.
        :type if_source_metageneration_not_match: str
        :param max_bytes_rewritten_per_call: The maximum number of bytes that will be rewritten per rewrite request. Most callers shouldn't need to specify this parameter - it is primarily in place to support testing. If specified the value must be an integral multiple of 1 MiB (1048576). Also, this only applies to requests where the source and destination span locations and/or storage classes. Finally, this value must not change across rewrite calls else you'll get an error that the rewriteToken is invalid.
        :type max_bytes_rewritten_per_call: str
        :param projection: Set of properties to return. Defaults to noAcl, unless the object resource specifies the acl property, when it defaults to full.
        :type projection: str
        :param rewrite_token: Include this field (from the previous rewrite response) on each rewrite request after the first one, until the rewrite response 'done' flag is true. Calls that provide a rewriteToken can omit all other request fields, but if included those fields must match the values provided in the first rewrite request.
        :type rewrite_token: str
        :param source_generation: If present, selects a specific revision of the source object (as opposed to the latest version, the default).
        :type source_generation: str
        :param user_project: The project to be billed for this request. Required for Requester Pays buckets.
        :type user_project: str
        :param object:
        :type object: Object
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._storage_objects_rewrite_serialize(
            source_bucket=source_bucket,
            source_object=source_object,
            destination_bucket=destination_bucket,
            destination_object=destination_object,
            alt=alt,
            fields=fields,
            key=key,
            oauth_token=oauth_token,
            pretty_print=pretty_print,
            quota_user=quota_user,
            upload_type=upload_type,
            user_ip=user_ip,
            destination_kms_key_name=destination_kms_key_name,
            destination_predefined_acl=destination_predefined_acl,
            if_generation_match=if_generation_match,
            if_generation_not_match=if_generation_not_match,
            if_metageneration_match=if_metageneration_match,
            if_metageneration_not_match=if_metageneration_not_match,
            if_source_generation_match=if_source_generation_match,
            if_source_generation_not_match=if_source_generation_not_match,
            if_source_metageneration_match=if_source_metageneration_match,
            if_source_metageneration_not_match=if_source_metageneration_not_match,
            max_bytes_rewritten_per_call=max_bytes_rewritten_per_call,
            projection=projection,
            rewrite_token=rewrite_token,
            source_generation=source_generation,
            user_project=user_project,
            object=object,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "RewriteResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def storage_objects_rewrite_with_http_info(
        self,
        source_bucket: Annotated[StrictStr, Field(description="Name of the bucket in which to find the source object.")],
        source_object: Annotated[StrictStr, Field(description="Name of the source object. For information about how to URL encode object names to be path safe, see [Encoding URI Path Parts](https://cloud.google.com/storage/docs/request-endpoints#encoding).")],
        destination_bucket: Annotated[StrictStr, Field(description="Name of the bucket in which to store the new object. Overrides the provided object metadata's bucket value, if any.")],
        destination_object: Annotated[StrictStr, Field(description="Name of the new object. Required when the object metadata is not otherwise provided. Overrides the object metadata's name value, if any. For information about how to URL encode object names to be path safe, see [Encoding URI Path Parts](https://cloud.google.com/storage/docs/request-endpoints#encoding).")],
        alt: Annotated[Optional[StrictStr], Field(description="Data format for the response.")] = None,
        fields: Annotated[Optional[StrictStr], Field(description="Selector specifying which fields to include in a partial response.")] = None,
        key: Annotated[Optional[StrictStr], Field(description="API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.")] = None,
        oauth_token: Annotated[Optional[StrictStr], Field(description="OAuth 2.0 token for the current user.")] = None,
        pretty_print: Annotated[Optional[StrictBool], Field(description="Returns response with indentations and line breaks.")] = None,
        quota_user: Annotated[Optional[StrictStr], Field(description="An opaque string that represents a user for quota purposes. Must not exceed 40 characters.")] = None,
        upload_type: Annotated[Optional[StrictStr], Field(description="Upload protocol for media (e.g. \"media\", \"multipart\", \"resumable\").")] = None,
        user_ip: Annotated[Optional[StrictStr], Field(description="Deprecated. Please use quotaUser instead.")] = None,
        destination_kms_key_name: Annotated[Optional[StrictStr], Field(description="Resource name of the Cloud KMS key, of the form projects/my-project/locations/global/keyRings/my-kr/cryptoKeys/my-key, that will be used to encrypt the object. Overrides the object metadata's kms_key_name value, if any.")] = None,
        destination_predefined_acl: Annotated[Optional[StrictStr], Field(description="Apply a predefined set of access controls to the destination object.")] = None,
        if_generation_match: Annotated[Optional[StrictStr], Field(description="Makes the operation conditional on whether the object's current generation matches the given value. Setting to 0 makes the operation succeed only if there are no live versions of the object.")] = None,
        if_generation_not_match: Annotated[Optional[StrictStr], Field(description="Makes the operation conditional on whether the object's current generation does not match the given value. If no live object exists, the precondition fails. Setting to 0 makes the operation succeed only if there is a live version of the object.")] = None,
        if_metageneration_match: Annotated[Optional[StrictStr], Field(description="Makes the operation conditional on whether the destination object's current metageneration matches the given value.")] = None,
        if_metageneration_not_match: Annotated[Optional[StrictStr], Field(description="Makes the operation conditional on whether the destination object's current metageneration does not match the given value.")] = None,
        if_source_generation_match: Annotated[Optional[StrictStr], Field(description="Makes the operation conditional on whether the source object's current generation matches the given value.")] = None,
        if_source_generation_not_match: Annotated[Optional[StrictStr], Field(description="Makes the operation conditional on whether the source object's current generation does not match the given value.")] = None,
        if_source_metageneration_match: Annotated[Optional[StrictStr], Field(description="Makes the operation conditional on whether the source object's current metageneration matches the given value.")] = None,
        if_source_metageneration_not_match: Annotated[Optional[StrictStr], Field(description="Makes the operation conditional on whether the source object's current metageneration does not match the given value.")] = None,
        max_bytes_rewritten_per_call: Annotated[Optional[StrictStr], Field(description="The maximum number of bytes that will be rewritten per rewrite request. Most callers shouldn't need to specify this parameter - it is primarily in place to support testing. If specified the value must be an integral multiple of 1 MiB (1048576). Also, this only applies to requests where the source and destination span locations and/or storage classes. Finally, this value must not change across rewrite calls else you'll get an error that the rewriteToken is invalid.")] = None,
        projection: Annotated[Optional[StrictStr], Field(description="Set of properties to return. Defaults to noAcl, unless the object resource specifies the acl property, when it defaults to full.")] = None,
        rewrite_token: Annotated[Optional[StrictStr], Field(description="Include this field (from the previous rewrite response) on each rewrite request after the first one, until the rewrite response 'done' flag is true. Calls that provide a rewriteToken can omit all other request fields, but if included those fields must match the values provided in the first rewrite request.")] = None,
        source_generation: Annotated[Optional[StrictStr], Field(description="If present, selects a specific revision of the source object (as opposed to the latest version, the default).")] = None,
        user_project: Annotated[Optional[StrictStr], Field(description="The project to be billed for this request. Required for Requester Pays buckets.")] = None,
        object: Optional[Object] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[RewriteResponse]:
        """storage_objects_rewrite

        Rewrites a source object to a destination object. Optionally overrides metadata.

        :param source_bucket: Name of the bucket in which to find the source object. (required)
        :type source_bucket: str
        :param source_object: Name of the source object. For information about how to URL encode object names to be path safe, see [Encoding URI Path Parts](https://cloud.google.com/storage/docs/request-endpoints#encoding). (required)
        :type source_object: str
        :param destination_bucket: Name of the bucket in which to store the new object. Overrides the provided object metadata's bucket value, if any. (required)
        :type destination_bucket: str
        :param destination_object: Name of the new object. Required when the object metadata is not otherwise provided. Overrides the object metadata's name value, if any. For information about how to URL encode object names to be path safe, see [Encoding URI Path Parts](https://cloud.google.com/storage/docs/request-endpoints#encoding). (required)
        :type destination_object: str
        :param alt: Data format for the response.
        :type alt: str
        :param fields: Selector specifying which fields to include in a partial response.
        :type fields: str
        :param key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :type key: str
        :param oauth_token: OAuth 2.0 token for the current user.
        :type oauth_token: str
        :param pretty_print: Returns response with indentations and line breaks.
        :type pretty_print: bool
        :param quota_user: An opaque string that represents a user for quota purposes. Must not exceed 40 characters.
        :type quota_user: str
        :param upload_type: Upload protocol for media (e.g. \"media\", \"multipart\", \"resumable\").
        :type upload_type: str
        :param user_ip: Deprecated. Please use quotaUser instead.
        :type user_ip: str
        :param destination_kms_key_name: Resource name of the Cloud KMS key, of the form projects/my-project/locations/global/keyRings/my-kr/cryptoKeys/my-key, that will be used to encrypt the object. Overrides the object metadata's kms_key_name value, if any.
        :type destination_kms_key_name: str
        :param destination_predefined_acl: Apply a predefined set of access controls to the destination object.
        :type destination_predefined_acl: str
        :param if_generation_match: Makes the operation conditional on whether the object's current generation matches the given value. Setting to 0 makes the operation succeed only if there are no live versions of the object.
        :type if_generation_match: str
        :param if_generation_not_match: Makes the operation conditional on whether the object's current generation does not match the given value. If no live object exists, the precondition fails. Setting to 0 makes the operation succeed only if there is a live version of the object.
        :type if_generation_not_match: str
        :param if_metageneration_match: Makes the operation conditional on whether the destination object's current metageneration matches the given value.
        :type if_metageneration_match: str
        :param if_metageneration_not_match: Makes the operation conditional on whether the destination object's current metageneration does not match the given value.
        :type if_metageneration_not_match: str
        :param if_source_generation_match: Makes the operation conditional on whether the source object's current generation matches the given value.
        :type if_source_generation_match: str
        :param if_source_generation_not_match: Makes the operation conditional on whether the source object's current generation does not match the given value.
        :type if_source_generation_not_match: str
        :param if_source_metageneration_match: Makes the operation conditional on whether the source object's current metageneration matches the given value.
        :type if_source_metageneration_match: str
        :param if_source_metageneration_not_match: Makes the operation conditional on whether the source object's current metageneration does not match the given value.
        :type if_source_metageneration_not_match: str
        :param max_bytes_rewritten_per_call: The maximum number of bytes that will be rewritten per rewrite request. Most callers shouldn't need to specify this parameter - it is primarily in place to support testing. If specified the value must be an integral multiple of 1 MiB (1048576). Also, this only applies to requests where the source and destination span locations and/or storage classes. Finally, this value must not change across rewrite calls else you'll get an error that the rewriteToken is invalid.
        :type max_bytes_rewritten_per_call: str
        :param projection: Set of properties to return. Defaults to noAcl, unless the object resource specifies the acl property, when it defaults to full.
        :type projection: str
        :param rewrite_token: Include this field (from the previous rewrite response) on each rewrite request after the first one, until the rewrite response 'done' flag is true. Calls that provide a rewriteToken can omit all other request fields, but if included those fields must match the values provided in the first rewrite request.
        :type rewrite_token: str
        :param source_generation: If present, selects a specific revision of the source object (as opposed to the latest version, the default).
        :type source_generation: str
        :param user_project: The project to be billed for this request. Required for Requester Pays buckets.
        :type user_project: str
        :param object:
        :type object: Object
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._storage_objects_rewrite_serialize(
            source_bucket=source_bucket,
            source_object=source_object,
            destination_bucket=destination_bucket,
            destination_object=destination_object,
            alt=alt,
            fields=fields,
            key=key,
            oauth_token=oauth_token,
            pretty_print=pretty_print,
            quota_user=quota_user,
            upload_type=upload_type,
            user_ip=user_ip,
            destination_kms_key_name=destination_kms_key_name,
            destination_predefined_acl=destination_predefined_acl,
            if_generation_match=if_generation_match,
            if_generation_not_match=if_generation_not_match,
            if_metageneration_match=if_metageneration_match,
            if_metageneration_not_match=if_metageneration_not_match,
            if_source_generation_match=if_source_generation_match,
            if_source_generation_not_match=if_source_generation_not_match,
            if_source_metageneration_match=if_source_metageneration_match,
            if_source_metageneration_not_match=if_source_metageneration_not_match,
            max_bytes_rewritten_per_call=max_bytes_rewritten_per_call,
            projection=projection,
            rewrite_token=rewrite_token,
            source_generation=source_generation,
            user_project=user_project,
            object=object,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "RewriteResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def storage_objects_rewrite_without_preload_content(
        self,
        source_bucket: Annotated[StrictStr, Field(description="Name of the bucket in which to find the source object.")],
        source_object: Annotated[StrictStr, Field(description="Name of the source object. For information about how to URL encode object names to be path safe, see [Encoding URI Path Parts](https://cloud.google.com/storage/docs/request-endpoints#encoding).")],
        destination_bucket: Annotated[StrictStr, Field(description="Name of the bucket in which to store the new object. Overrides the provided object metadata's bucket value, if any.")],
        destination_object: Annotated[StrictStr, Field(description="Name of the new object. Required when the object metadata is not otherwise provided. Overrides the object metadata's name value, if any. For information about how to URL encode object names to be path safe, see [Encoding URI Path Parts](https://cloud.google.com/storage/docs/request-endpoints#encoding).")],
        alt: Annotated[Optional[StrictStr], Field(description="Data format for the response.")] = None,
        fields: Annotated[Optional[StrictStr], Field(description="Selector specifying which fields to include in a partial response.")] = None,
        key: Annotated[Optional[StrictStr], Field(description="API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.")] = None,
        oauth_token: Annotated[Optional[StrictStr], Field(description="OAuth 2.0 token for the current user.")] = None,
        pretty_print: Annotated[Optional[StrictBool], Field(description="Returns response with indentations and line breaks.")] = None,
        quota_user: Annotated[Optional[StrictStr], Field(description="An opaque string that represents a user for quota purposes. Must not exceed 40 characters.")] = None,
        upload_type: Annotated[Optional[StrictStr], Field(description="Upload protocol for media (e.g. \"media\", \"multipart\", \"resumable\").")] = None,
        user_ip: Annotated[Optional[StrictStr], Field(description="Deprecated. Please use quotaUser instead.")] = None,
        destination_kms_key_name: Annotated[Optional[StrictStr], Field(description="Resource name of the Cloud KMS key, of the form projects/my-project/locations/global/keyRings/my-kr/cryptoKeys/my-key, that will be used to encrypt the object. Overrides the object metadata's kms_key_name value, if any.")] = None,
        destination_predefined_acl: Annotated[Optional[StrictStr], Field(description="Apply a predefined set of access controls to the destination object.")] = None,
        if_generation_match: Annotated[Optional[StrictStr], Field(description="Makes the operation conditional on whether the object's current generation matches the given value. Setting to 0 makes the operation succeed only if there are no live versions of the object.")] = None,
        if_generation_not_match: Annotated[Optional[StrictStr], Field(description="Makes the operation conditional on whether the object's current generation does not match the given value. If no live object exists, the precondition fails. Setting to 0 makes the operation succeed only if there is a live version of the object.")] = None,
        if_metageneration_match: Annotated[Optional[StrictStr], Field(description="Makes the operation conditional on whether the destination object's current metageneration matches the given value.")] = None,
        if_metageneration_not_match: Annotated[Optional[StrictStr], Field(description="Makes the operation conditional on whether the destination object's current metageneration does not match the given value.")] = None,
        if_source_generation_match: Annotated[Optional[StrictStr], Field(description="Makes the operation conditional on whether the source object's current generation matches the given value.")] = None,
        if_source_generation_not_match: Annotated[Optional[StrictStr], Field(description="Makes the operation conditional on whether the source object's current generation does not match the given value.")] = None,
        if_source_metageneration_match: Annotated[Optional[StrictStr], Field(description="Makes the operation conditional on whether the source object's current metageneration matches the given value.")] = None,
        if_source_metageneration_not_match: Annotated[Optional[StrictStr], Field(description="Makes the operation conditional on whether the source object's current metageneration does not match the given value.")] = None,
        max_bytes_rewritten_per_call: Annotated[Optional[StrictStr], Field(description="The maximum number of bytes that will be rewritten per rewrite request. Most callers shouldn't need to specify this parameter - it is primarily in place to support testing. If specified the value must be an integral multiple of 1 MiB (1048576). Also, this only applies to requests where the source and destination span locations and/or storage classes. Finally, this value must not change across rewrite calls else you'll get an error that the rewriteToken is invalid.")] = None,
        projection: Annotated[Optional[StrictStr], Field(description="Set of properties to return. Defaults to noAcl, unless the object resource specifies the acl property, when it defaults to full.")] = None,
        rewrite_token: Annotated[Optional[StrictStr], Field(description="Include this field (from the previous rewrite response) on each rewrite request after the first one, until the rewrite response 'done' flag is true. Calls that provide a rewriteToken can omit all other request fields, but if included those fields must match the values provided in the first rewrite request.")] = None,
        source_generation: Annotated[Optional[StrictStr], Field(description="If present, selects a specific revision of the source object (as opposed to the latest version, the default).")] = None,
        user_project: Annotated[Optional[StrictStr], Field(description="The project to be billed for this request. Required for Requester Pays buckets.")] = None,
        object: Optional[Object] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """storage_objects_rewrite

        Rewrites a source object to a destination object. Optionally overrides metadata.

        :param source_bucket: Name of the bucket in which to find the source object. (required)
        :type source_bucket: str
        :param source_object: Name of the source object. For information about how to URL encode object names to be path safe, see [Encoding URI Path Parts](https://cloud.google.com/storage/docs/request-endpoints#encoding). (required)
        :type source_object: str
        :param destination_bucket: Name of the bucket in which to store the new object. Overrides the provided object metadata's bucket value, if any. (required)
        :type destination_bucket: str
        :param destination_object: Name of the new object. Required when the object metadata is not otherwise provided. Overrides the object metadata's name value, if any. For information about how to URL encode object names to be path safe, see [Encoding URI Path Parts](https://cloud.google.com/storage/docs/request-endpoints#encoding). (required)
        :type destination_object: str
        :param alt: Data format for the response.
        :type alt: str
        :param fields: Selector specifying which fields to include in a partial response.
        :type fields: str
        :param key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :type key: str
        :param oauth_token: OAuth 2.0 token for the current user.
        :type oauth_token: str
        :param pretty_print: Returns response with indentations and line breaks.
        :type pretty_print: bool
        :param quota_user: An opaque string that represents a user for quota purposes. Must not exceed 40 characters.
        :type quota_user: str
        :param upload_type: Upload protocol for media (e.g. \"media\", \"multipart\", \"resumable\").
        :type upload_type: str
        :param user_ip: Deprecated. Please use quotaUser instead.
        :type user_ip: str
        :param destination_kms_key_name: Resource name of the Cloud KMS key, of the form projects/my-project/locations/global/keyRings/my-kr/cryptoKeys/my-key, that will be used to encrypt the object. Overrides the object metadata's kms_key_name value, if any.
        :type destination_kms_key_name: str
        :param destination_predefined_acl: Apply a predefined set of access controls to the destination object.
        :type destination_predefined_acl: str
        :param if_generation_match: Makes the operation conditional on whether the object's current generation matches the given value. Setting to 0 makes the operation succeed only if there are no live versions of the object.
        :type if_generation_match: str
        :param if_generation_not_match: Makes the operation conditional on whether the object's current generation does not match the given value. If no live object exists, the precondition fails. Setting to 0 makes the operation succeed only if there is a live version of the object.
        :type if_generation_not_match: str
        :param if_metageneration_match: Makes the operation conditional on whether the destination object's current metageneration matches the given value.
        :type if_metageneration_match: str
        :param if_metageneration_not_match: Makes the operation conditional on whether the destination object's current metageneration does not match the given value.
        :type if_metageneration_not_match: str
        :param if_source_generation_match: Makes the operation conditional on whether the source object's current generation matches the given value.
        :type if_source_generation_match: str
        :param if_source_generation_not_match: Makes the operation conditional on whether the source object's current generation does not match the given value.
        :type if_source_generation_not_match: str
        :param if_source_metageneration_match: Makes the operation conditional on whether the source object's current metageneration matches the given value.
        :type if_source_metageneration_match: str
        :param if_source_metageneration_not_match: Makes the operation conditional on whether the source object's current metageneration does not match the given value.
        :type if_source_metageneration_not_match: str
        :param max_bytes_rewritten_per_call: The maximum number of bytes that will be rewritten per rewrite request. Most callers shouldn't need to specify this parameter - it is primarily in place to support testing. If specified the value must be an integral multiple of 1 MiB (1048576). Also, this only applies to requests where the source and destination span locations and/or storage classes. Finally, this value must not change across rewrite calls else you'll get an error that the rewriteToken is invalid.
        :type max_bytes_rewritten_per_call: str
        :param projection: Set of properties to return. Defaults to noAcl, unless the object resource specifies the acl property, when it defaults to full.
        :type projection: str
        :param rewrite_token: Include this field (from the previous rewrite response) on each rewrite request after the first one, until the rewrite response 'done' flag is true. Calls that provide a rewriteToken can omit all other request fields, but if included those fields must match the values provided in the first rewrite request.
        :type rewrite_token: str
        :param source_generation: If present, selects a specific revision of the source object (as opposed to the latest version, the default).
        :type source_generation: str
        :param user_project: The project to be billed for this request. Required for Requester Pays buckets.
        :type user_project: str
        :param object:
        :type object: Object
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._storage_objects_rewrite_serialize(
            source_bucket=source_bucket,
            source_object=source_object,
            destination_bucket=destination_bucket,
            destination_object=destination_object,
            alt=alt,
            fields=fields,
            key=key,
            oauth_token=oauth_token,
            pretty_print=pretty_print,
            quota_user=quota_user,
            upload_type=upload_type,
            user_ip=user_ip,
            destination_kms_key_name=destination_kms_key_name,
            destination_predefined_acl=destination_predefined_acl,
            if_generation_match=if_generation_match,
            if_generation_not_match=if_generation_not_match,
            if_metageneration_match=if_metageneration_match,
            if_metageneration_not_match=if_metageneration_not_match,
            if_source_generation_match=if_source_generation_match,
            if_source_generation_not_match=if_source_generation_not_match,
            if_source_metageneration_match=if_source_metageneration_match,
            if_source_metageneration_not_match=if_source_metageneration_not_match,
            max_bytes_rewritten_per_call=max_bytes_rewritten_per_call,
            projection=projection,
            rewrite_token=rewrite_token,
            source_generation=source_generation,
            user_project=user_project,
            object=object,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "RewriteResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _storage_objects_rewrite_serialize(
        self,
        source_bucket,
        source_object,
        destination_bucket,
        destination_object,
        alt,
        fields,
        key,
        oauth_token,
        pretty_print,
        quota_user,
        upload_type,
        user_ip,
        destination_kms_key_name,
        destination_predefined_acl,
        if_generation_match,
        if_generation_not_match,
        if_metageneration_match,
        if_metageneration_not_match,
        if_source_generation_match,
        if_source_generation_not_match,
        if_source_metageneration_match,
        if_source_metageneration_not_match,
        max_bytes_rewritten_per_call,
        projection,
        rewrite_token,
        source_generation,
        user_project,
        object,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if source_bucket is not None:
            _path_params['sourceBucket'] = source_bucket
        if source_object is not None:
            _path_params['sourceObject'] = source_object
        if destination_bucket is not None:
            _path_params['destinationBucket'] = destination_bucket
        if destination_object is not None:
            _path_params['destinationObject'] = destination_object
        # process the query parameters
        if alt is not None:
            
            _query_params.append(('alt', alt))
            
        if fields is not None:
            
            _query_params.append(('fields', fields))
            
        if key is not None:
            
            _query_params.append(('key', key))
            
        if oauth_token is not None:
            
            _query_params.append(('oauth_token', oauth_token))
            
        if pretty_print is not None:
            
            _query_params.append(('prettyPrint', pretty_print))
            
        if quota_user is not None:
            
            _query_params.append(('quotaUser', quota_user))
            
        if upload_type is not None:
            
            _query_params.append(('uploadType', upload_type))
            
        if user_ip is not None:
            
            _query_params.append(('userIp', user_ip))
            
        if destination_kms_key_name is not None:
            
            _query_params.append(('destinationKmsKeyName', destination_kms_key_name))
            
        if destination_predefined_acl is not None:
            
            _query_params.append(('destinationPredefinedAcl', destination_predefined_acl))
            
        if if_generation_match is not None:
            
            _query_params.append(('ifGenerationMatch', if_generation_match))
            
        if if_generation_not_match is not None:
            
            _query_params.append(('ifGenerationNotMatch', if_generation_not_match))
            
        if if_metageneration_match is not None:
            
            _query_params.append(('ifMetagenerationMatch', if_metageneration_match))
            
        if if_metageneration_not_match is not None:
            
            _query_params.append(('ifMetagenerationNotMatch', if_metageneration_not_match))
            
        if if_source_generation_match is not None:
            
            _query_params.append(('ifSourceGenerationMatch', if_source_generation_match))
            
        if if_source_generation_not_match is not None:
            
            _query_params.append(('ifSourceGenerationNotMatch', if_source_generation_not_match))
            
        if if_source_metageneration_match is not None:
            
            _query_params.append(('ifSourceMetagenerationMatch', if_source_metageneration_match))
            
        if if_source_metageneration_not_match is not None:
            
            _query_params.append(('ifSourceMetagenerationNotMatch', if_source_metageneration_not_match))
            
        if max_bytes_rewritten_per_call is not None:
            
            _query_params.append(('maxBytesRewrittenPerCall', max_bytes_rewritten_per_call))
            
        if projection is not None:
            
            _query_params.append(('projection', projection))
            
        if rewrite_token is not None:
            
            _query_params.append(('rewriteToken', rewrite_token))
            
        if source_generation is not None:
            
            _query_params.append(('sourceGeneration', source_generation))
            
        if user_project is not None:
            
            _query_params.append(('userProject', user_project))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if object is not None:
            _body_params = object


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'Oauth2c', 
            'Oauth2'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/b/{sourceBucket}/o/{sourceObject}/rewriteTo/b/{destinationBucket}/o/{destinationObject}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def storage_objects_set_iam_policy(
        self,
        bucket: Annotated[StrictStr, Field(description="Name of the bucket in which the object resides.")],
        object: Annotated[StrictStr, Field(description="Name of the object. For information about how to URL encode object names to be path safe, see [Encoding URI Path Parts](https://cloud.google.com/storage/docs/request-endpoints#encoding).")],
        alt: Annotated[Optional[StrictStr], Field(description="Data format for the response.")] = None,
        fields: Annotated[Optional[StrictStr], Field(description="Selector specifying which fields to include in a partial response.")] = None,
        key: Annotated[Optional[StrictStr], Field(description="API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.")] = None,
        oauth_token: Annotated[Optional[StrictStr], Field(description="OAuth 2.0 token for the current user.")] = None,
        pretty_print: Annotated[Optional[StrictBool], Field(description="Returns response with indentations and line breaks.")] = None,
        quota_user: Annotated[Optional[StrictStr], Field(description="An opaque string that represents a user for quota purposes. Must not exceed 40 characters.")] = None,
        upload_type: Annotated[Optional[StrictStr], Field(description="Upload protocol for media (e.g. \"media\", \"multipart\", \"resumable\").")] = None,
        user_ip: Annotated[Optional[StrictStr], Field(description="Deprecated. Please use quotaUser instead.")] = None,
        generation: Annotated[Optional[StrictStr], Field(description="If present, selects a specific revision of this object (as opposed to the latest version, the default).")] = None,
        user_project: Annotated[Optional[StrictStr], Field(description="The project to be billed for this request. Required for Requester Pays buckets.")] = None,
        policy: Optional[Policy] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> Policy:
        """storage_objects_set_iam_policy

        Updates an IAM policy for the specified object.

        :param bucket: Name of the bucket in which the object resides. (required)
        :type bucket: str
        :param object: Name of the object. For information about how to URL encode object names to be path safe, see [Encoding URI Path Parts](https://cloud.google.com/storage/docs/request-endpoints#encoding). (required)
        :type object: str
        :param alt: Data format for the response.
        :type alt: str
        :param fields: Selector specifying which fields to include in a partial response.
        :type fields: str
        :param key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :type key: str
        :param oauth_token: OAuth 2.0 token for the current user.
        :type oauth_token: str
        :param pretty_print: Returns response with indentations and line breaks.
        :type pretty_print: bool
        :param quota_user: An opaque string that represents a user for quota purposes. Must not exceed 40 characters.
        :type quota_user: str
        :param upload_type: Upload protocol for media (e.g. \"media\", \"multipart\", \"resumable\").
        :type upload_type: str
        :param user_ip: Deprecated. Please use quotaUser instead.
        :type user_ip: str
        :param generation: If present, selects a specific revision of this object (as opposed to the latest version, the default).
        :type generation: str
        :param user_project: The project to be billed for this request. Required for Requester Pays buckets.
        :type user_project: str
        :param policy:
        :type policy: Policy
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._storage_objects_set_iam_policy_serialize(
            bucket=bucket,
            object=object,
            alt=alt,
            fields=fields,
            key=key,
            oauth_token=oauth_token,
            pretty_print=pretty_print,
            quota_user=quota_user,
            upload_type=upload_type,
            user_ip=user_ip,
            generation=generation,
            user_project=user_project,
            policy=policy,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Policy",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def storage_objects_set_iam_policy_with_http_info(
        self,
        bucket: Annotated[StrictStr, Field(description="Name of the bucket in which the object resides.")],
        object: Annotated[StrictStr, Field(description="Name of the object. For information about how to URL encode object names to be path safe, see [Encoding URI Path Parts](https://cloud.google.com/storage/docs/request-endpoints#encoding).")],
        alt: Annotated[Optional[StrictStr], Field(description="Data format for the response.")] = None,
        fields: Annotated[Optional[StrictStr], Field(description="Selector specifying which fields to include in a partial response.")] = None,
        key: Annotated[Optional[StrictStr], Field(description="API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.")] = None,
        oauth_token: Annotated[Optional[StrictStr], Field(description="OAuth 2.0 token for the current user.")] = None,
        pretty_print: Annotated[Optional[StrictBool], Field(description="Returns response with indentations and line breaks.")] = None,
        quota_user: Annotated[Optional[StrictStr], Field(description="An opaque string that represents a user for quota purposes. Must not exceed 40 characters.")] = None,
        upload_type: Annotated[Optional[StrictStr], Field(description="Upload protocol for media (e.g. \"media\", \"multipart\", \"resumable\").")] = None,
        user_ip: Annotated[Optional[StrictStr], Field(description="Deprecated. Please use quotaUser instead.")] = None,
        generation: Annotated[Optional[StrictStr], Field(description="If present, selects a specific revision of this object (as opposed to the latest version, the default).")] = None,
        user_project: Annotated[Optional[StrictStr], Field(description="The project to be billed for this request. Required for Requester Pays buckets.")] = None,
        policy: Optional[Policy] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[Policy]:
        """storage_objects_set_iam_policy

        Updates an IAM policy for the specified object.

        :param bucket: Name of the bucket in which the object resides. (required)
        :type bucket: str
        :param object: Name of the object. For information about how to URL encode object names to be path safe, see [Encoding URI Path Parts](https://cloud.google.com/storage/docs/request-endpoints#encoding). (required)
        :type object: str
        :param alt: Data format for the response.
        :type alt: str
        :param fields: Selector specifying which fields to include in a partial response.
        :type fields: str
        :param key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :type key: str
        :param oauth_token: OAuth 2.0 token for the current user.
        :type oauth_token: str
        :param pretty_print: Returns response with indentations and line breaks.
        :type pretty_print: bool
        :param quota_user: An opaque string that represents a user for quota purposes. Must not exceed 40 characters.
        :type quota_user: str
        :param upload_type: Upload protocol for media (e.g. \"media\", \"multipart\", \"resumable\").
        :type upload_type: str
        :param user_ip: Deprecated. Please use quotaUser instead.
        :type user_ip: str
        :param generation: If present, selects a specific revision of this object (as opposed to the latest version, the default).
        :type generation: str
        :param user_project: The project to be billed for this request. Required for Requester Pays buckets.
        :type user_project: str
        :param policy:
        :type policy: Policy
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._storage_objects_set_iam_policy_serialize(
            bucket=bucket,
            object=object,
            alt=alt,
            fields=fields,
            key=key,
            oauth_token=oauth_token,
            pretty_print=pretty_print,
            quota_user=quota_user,
            upload_type=upload_type,
            user_ip=user_ip,
            generation=generation,
            user_project=user_project,
            policy=policy,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Policy",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def storage_objects_set_iam_policy_without_preload_content(
        self,
        bucket: Annotated[StrictStr, Field(description="Name of the bucket in which the object resides.")],
        object: Annotated[StrictStr, Field(description="Name of the object. For information about how to URL encode object names to be path safe, see [Encoding URI Path Parts](https://cloud.google.com/storage/docs/request-endpoints#encoding).")],
        alt: Annotated[Optional[StrictStr], Field(description="Data format for the response.")] = None,
        fields: Annotated[Optional[StrictStr], Field(description="Selector specifying which fields to include in a partial response.")] = None,
        key: Annotated[Optional[StrictStr], Field(description="API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.")] = None,
        oauth_token: Annotated[Optional[StrictStr], Field(description="OAuth 2.0 token for the current user.")] = None,
        pretty_print: Annotated[Optional[StrictBool], Field(description="Returns response with indentations and line breaks.")] = None,
        quota_user: Annotated[Optional[StrictStr], Field(description="An opaque string that represents a user for quota purposes. Must not exceed 40 characters.")] = None,
        upload_type: Annotated[Optional[StrictStr], Field(description="Upload protocol for media (e.g. \"media\", \"multipart\", \"resumable\").")] = None,
        user_ip: Annotated[Optional[StrictStr], Field(description="Deprecated. Please use quotaUser instead.")] = None,
        generation: Annotated[Optional[StrictStr], Field(description="If present, selects a specific revision of this object (as opposed to the latest version, the default).")] = None,
        user_project: Annotated[Optional[StrictStr], Field(description="The project to be billed for this request. Required for Requester Pays buckets.")] = None,
        policy: Optional[Policy] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """storage_objects_set_iam_policy

        Updates an IAM policy for the specified object.

        :param bucket: Name of the bucket in which the object resides. (required)
        :type bucket: str
        :param object: Name of the object. For information about how to URL encode object names to be path safe, see [Encoding URI Path Parts](https://cloud.google.com/storage/docs/request-endpoints#encoding). (required)
        :type object: str
        :param alt: Data format for the response.
        :type alt: str
        :param fields: Selector specifying which fields to include in a partial response.
        :type fields: str
        :param key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :type key: str
        :param oauth_token: OAuth 2.0 token for the current user.
        :type oauth_token: str
        :param pretty_print: Returns response with indentations and line breaks.
        :type pretty_print: bool
        :param quota_user: An opaque string that represents a user for quota purposes. Must not exceed 40 characters.
        :type quota_user: str
        :param upload_type: Upload protocol for media (e.g. \"media\", \"multipart\", \"resumable\").
        :type upload_type: str
        :param user_ip: Deprecated. Please use quotaUser instead.
        :type user_ip: str
        :param generation: If present, selects a specific revision of this object (as opposed to the latest version, the default).
        :type generation: str
        :param user_project: The project to be billed for this request. Required for Requester Pays buckets.
        :type user_project: str
        :param policy:
        :type policy: Policy
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._storage_objects_set_iam_policy_serialize(
            bucket=bucket,
            object=object,
            alt=alt,
            fields=fields,
            key=key,
            oauth_token=oauth_token,
            pretty_print=pretty_print,
            quota_user=quota_user,
            upload_type=upload_type,
            user_ip=user_ip,
            generation=generation,
            user_project=user_project,
            policy=policy,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Policy",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _storage_objects_set_iam_policy_serialize(
        self,
        bucket,
        object,
        alt,
        fields,
        key,
        oauth_token,
        pretty_print,
        quota_user,
        upload_type,
        user_ip,
        generation,
        user_project,
        policy,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if bucket is not None:
            _path_params['bucket'] = bucket
        if object is not None:
            _path_params['object'] = object
        # process the query parameters
        if alt is not None:
            
            _query_params.append(('alt', alt))
            
        if fields is not None:
            
            _query_params.append(('fields', fields))
            
        if key is not None:
            
            _query_params.append(('key', key))
            
        if oauth_token is not None:
            
            _query_params.append(('oauth_token', oauth_token))
            
        if pretty_print is not None:
            
            _query_params.append(('prettyPrint', pretty_print))
            
        if quota_user is not None:
            
            _query_params.append(('quotaUser', quota_user))
            
        if upload_type is not None:
            
            _query_params.append(('uploadType', upload_type))
            
        if user_ip is not None:
            
            _query_params.append(('userIp', user_ip))
            
        if generation is not None:
            
            _query_params.append(('generation', generation))
            
        if user_project is not None:
            
            _query_params.append(('userProject', user_project))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if policy is not None:
            _body_params = policy


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'Oauth2c', 
            'Oauth2'
        ]

        return self.api_client.param_serialize(
            method='PUT',
            resource_path='/b/{bucket}/o/{object}/iam',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def storage_objects_test_iam_permissions(
        self,
        bucket: Annotated[StrictStr, Field(description="Name of the bucket in which the object resides.")],
        object: Annotated[StrictStr, Field(description="Name of the object. For information about how to URL encode object names to be path safe, see [Encoding URI Path Parts](https://cloud.google.com/storage/docs/request-endpoints#encoding).")],
        permissions: Annotated[List[StrictStr], Field(description="Permissions to test.")],
        alt: Annotated[Optional[StrictStr], Field(description="Data format for the response.")] = None,
        fields: Annotated[Optional[StrictStr], Field(description="Selector specifying which fields to include in a partial response.")] = None,
        key: Annotated[Optional[StrictStr], Field(description="API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.")] = None,
        oauth_token: Annotated[Optional[StrictStr], Field(description="OAuth 2.0 token for the current user.")] = None,
        pretty_print: Annotated[Optional[StrictBool], Field(description="Returns response with indentations and line breaks.")] = None,
        quota_user: Annotated[Optional[StrictStr], Field(description="An opaque string that represents a user for quota purposes. Must not exceed 40 characters.")] = None,
        upload_type: Annotated[Optional[StrictStr], Field(description="Upload protocol for media (e.g. \"media\", \"multipart\", \"resumable\").")] = None,
        user_ip: Annotated[Optional[StrictStr], Field(description="Deprecated. Please use quotaUser instead.")] = None,
        generation: Annotated[Optional[StrictStr], Field(description="If present, selects a specific revision of this object (as opposed to the latest version, the default).")] = None,
        user_project: Annotated[Optional[StrictStr], Field(description="The project to be billed for this request. Required for Requester Pays buckets.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> TestIamPermissionsResponse:
        """storage_objects_test_iam_permissions

        Tests a set of permissions on the given object to see which, if any, are held by the caller.

        :param bucket: Name of the bucket in which the object resides. (required)
        :type bucket: str
        :param object: Name of the object. For information about how to URL encode object names to be path safe, see [Encoding URI Path Parts](https://cloud.google.com/storage/docs/request-endpoints#encoding). (required)
        :type object: str
        :param permissions: Permissions to test. (required)
        :type permissions: List[str]
        :param alt: Data format for the response.
        :type alt: str
        :param fields: Selector specifying which fields to include in a partial response.
        :type fields: str
        :param key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :type key: str
        :param oauth_token: OAuth 2.0 token for the current user.
        :type oauth_token: str
        :param pretty_print: Returns response with indentations and line breaks.
        :type pretty_print: bool
        :param quota_user: An opaque string that represents a user for quota purposes. Must not exceed 40 characters.
        :type quota_user: str
        :param upload_type: Upload protocol for media (e.g. \"media\", \"multipart\", \"resumable\").
        :type upload_type: str
        :param user_ip: Deprecated. Please use quotaUser instead.
        :type user_ip: str
        :param generation: If present, selects a specific revision of this object (as opposed to the latest version, the default).
        :type generation: str
        :param user_project: The project to be billed for this request. Required for Requester Pays buckets.
        :type user_project: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._storage_objects_test_iam_permissions_serialize(
            bucket=bucket,
            object=object,
            permissions=permissions,
            alt=alt,
            fields=fields,
            key=key,
            oauth_token=oauth_token,
            pretty_print=pretty_print,
            quota_user=quota_user,
            upload_type=upload_type,
            user_ip=user_ip,
            generation=generation,
            user_project=user_project,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TestIamPermissionsResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def storage_objects_test_iam_permissions_with_http_info(
        self,
        bucket: Annotated[StrictStr, Field(description="Name of the bucket in which the object resides.")],
        object: Annotated[StrictStr, Field(description="Name of the object. For information about how to URL encode object names to be path safe, see [Encoding URI Path Parts](https://cloud.google.com/storage/docs/request-endpoints#encoding).")],
        permissions: Annotated[List[StrictStr], Field(description="Permissions to test.")],
        alt: Annotated[Optional[StrictStr], Field(description="Data format for the response.")] = None,
        fields: Annotated[Optional[StrictStr], Field(description="Selector specifying which fields to include in a partial response.")] = None,
        key: Annotated[Optional[StrictStr], Field(description="API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.")] = None,
        oauth_token: Annotated[Optional[StrictStr], Field(description="OAuth 2.0 token for the current user.")] = None,
        pretty_print: Annotated[Optional[StrictBool], Field(description="Returns response with indentations and line breaks.")] = None,
        quota_user: Annotated[Optional[StrictStr], Field(description="An opaque string that represents a user for quota purposes. Must not exceed 40 characters.")] = None,
        upload_type: Annotated[Optional[StrictStr], Field(description="Upload protocol for media (e.g. \"media\", \"multipart\", \"resumable\").")] = None,
        user_ip: Annotated[Optional[StrictStr], Field(description="Deprecated. Please use quotaUser instead.")] = None,
        generation: Annotated[Optional[StrictStr], Field(description="If present, selects a specific revision of this object (as opposed to the latest version, the default).")] = None,
        user_project: Annotated[Optional[StrictStr], Field(description="The project to be billed for this request. Required for Requester Pays buckets.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[TestIamPermissionsResponse]:
        """storage_objects_test_iam_permissions

        Tests a set of permissions on the given object to see which, if any, are held by the caller.

        :param bucket: Name of the bucket in which the object resides. (required)
        :type bucket: str
        :param object: Name of the object. For information about how to URL encode object names to be path safe, see [Encoding URI Path Parts](https://cloud.google.com/storage/docs/request-endpoints#encoding). (required)
        :type object: str
        :param permissions: Permissions to test. (required)
        :type permissions: List[str]
        :param alt: Data format for the response.
        :type alt: str
        :param fields: Selector specifying which fields to include in a partial response.
        :type fields: str
        :param key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :type key: str
        :param oauth_token: OAuth 2.0 token for the current user.
        :type oauth_token: str
        :param pretty_print: Returns response with indentations and line breaks.
        :type pretty_print: bool
        :param quota_user: An opaque string that represents a user for quota purposes. Must not exceed 40 characters.
        :type quota_user: str
        :param upload_type: Upload protocol for media (e.g. \"media\", \"multipart\", \"resumable\").
        :type upload_type: str
        :param user_ip: Deprecated. Please use quotaUser instead.
        :type user_ip: str
        :param generation: If present, selects a specific revision of this object (as opposed to the latest version, the default).
        :type generation: str
        :param user_project: The project to be billed for this request. Required for Requester Pays buckets.
        :type user_project: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._storage_objects_test_iam_permissions_serialize(
            bucket=bucket,
            object=object,
            permissions=permissions,
            alt=alt,
            fields=fields,
            key=key,
            oauth_token=oauth_token,
            pretty_print=pretty_print,
            quota_user=quota_user,
            upload_type=upload_type,
            user_ip=user_ip,
            generation=generation,
            user_project=user_project,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TestIamPermissionsResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def storage_objects_test_iam_permissions_without_preload_content(
        self,
        bucket: Annotated[StrictStr, Field(description="Name of the bucket in which the object resides.")],
        object: Annotated[StrictStr, Field(description="Name of the object. For information about how to URL encode object names to be path safe, see [Encoding URI Path Parts](https://cloud.google.com/storage/docs/request-endpoints#encoding).")],
        permissions: Annotated[List[StrictStr], Field(description="Permissions to test.")],
        alt: Annotated[Optional[StrictStr], Field(description="Data format for the response.")] = None,
        fields: Annotated[Optional[StrictStr], Field(description="Selector specifying which fields to include in a partial response.")] = None,
        key: Annotated[Optional[StrictStr], Field(description="API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.")] = None,
        oauth_token: Annotated[Optional[StrictStr], Field(description="OAuth 2.0 token for the current user.")] = None,
        pretty_print: Annotated[Optional[StrictBool], Field(description="Returns response with indentations and line breaks.")] = None,
        quota_user: Annotated[Optional[StrictStr], Field(description="An opaque string that represents a user for quota purposes. Must not exceed 40 characters.")] = None,
        upload_type: Annotated[Optional[StrictStr], Field(description="Upload protocol for media (e.g. \"media\", \"multipart\", \"resumable\").")] = None,
        user_ip: Annotated[Optional[StrictStr], Field(description="Deprecated. Please use quotaUser instead.")] = None,
        generation: Annotated[Optional[StrictStr], Field(description="If present, selects a specific revision of this object (as opposed to the latest version, the default).")] = None,
        user_project: Annotated[Optional[StrictStr], Field(description="The project to be billed for this request. Required for Requester Pays buckets.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """storage_objects_test_iam_permissions

        Tests a set of permissions on the given object to see which, if any, are held by the caller.

        :param bucket: Name of the bucket in which the object resides. (required)
        :type bucket: str
        :param object: Name of the object. For information about how to URL encode object names to be path safe, see [Encoding URI Path Parts](https://cloud.google.com/storage/docs/request-endpoints#encoding). (required)
        :type object: str
        :param permissions: Permissions to test. (required)
        :type permissions: List[str]
        :param alt: Data format for the response.
        :type alt: str
        :param fields: Selector specifying which fields to include in a partial response.
        :type fields: str
        :param key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :type key: str
        :param oauth_token: OAuth 2.0 token for the current user.
        :type oauth_token: str
        :param pretty_print: Returns response with indentations and line breaks.
        :type pretty_print: bool
        :param quota_user: An opaque string that represents a user for quota purposes. Must not exceed 40 characters.
        :type quota_user: str
        :param upload_type: Upload protocol for media (e.g. \"media\", \"multipart\", \"resumable\").
        :type upload_type: str
        :param user_ip: Deprecated. Please use quotaUser instead.
        :type user_ip: str
        :param generation: If present, selects a specific revision of this object (as opposed to the latest version, the default).
        :type generation: str
        :param user_project: The project to be billed for this request. Required for Requester Pays buckets.
        :type user_project: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._storage_objects_test_iam_permissions_serialize(
            bucket=bucket,
            object=object,
            permissions=permissions,
            alt=alt,
            fields=fields,
            key=key,
            oauth_token=oauth_token,
            pretty_print=pretty_print,
            quota_user=quota_user,
            upload_type=upload_type,
            user_ip=user_ip,
            generation=generation,
            user_project=user_project,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TestIamPermissionsResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _storage_objects_test_iam_permissions_serialize(
        self,
        bucket,
        object,
        permissions,
        alt,
        fields,
        key,
        oauth_token,
        pretty_print,
        quota_user,
        upload_type,
        user_ip,
        generation,
        user_project,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'permissions': 'multi',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if bucket is not None:
            _path_params['bucket'] = bucket
        if object is not None:
            _path_params['object'] = object
        # process the query parameters
        if alt is not None:
            
            _query_params.append(('alt', alt))
            
        if fields is not None:
            
            _query_params.append(('fields', fields))
            
        if key is not None:
            
            _query_params.append(('key', key))
            
        if oauth_token is not None:
            
            _query_params.append(('oauth_token', oauth_token))
            
        if pretty_print is not None:
            
            _query_params.append(('prettyPrint', pretty_print))
            
        if quota_user is not None:
            
            _query_params.append(('quotaUser', quota_user))
            
        if upload_type is not None:
            
            _query_params.append(('uploadType', upload_type))
            
        if user_ip is not None:
            
            _query_params.append(('userIp', user_ip))
            
        if permissions is not None:
            
            _query_params.append(('permissions', permissions))
            
        if generation is not None:
            
            _query_params.append(('generation', generation))
            
        if user_project is not None:
            
            _query_params.append(('userProject', user_project))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'Oauth2c', 
            'Oauth2'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/b/{bucket}/o/{object}/iam/testPermissions',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def storage_objects_update(
        self,
        bucket: Annotated[StrictStr, Field(description="Name of the bucket in which the object resides.")],
        object: Annotated[StrictStr, Field(description="Name of the object. For information about how to URL encode object names to be path safe, see [Encoding URI Path Parts](https://cloud.google.com/storage/docs/request-endpoints#encoding).")],
        alt: Annotated[Optional[StrictStr], Field(description="Data format for the response.")] = None,
        fields: Annotated[Optional[StrictStr], Field(description="Selector specifying which fields to include in a partial response.")] = None,
        key: Annotated[Optional[StrictStr], Field(description="API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.")] = None,
        oauth_token: Annotated[Optional[StrictStr], Field(description="OAuth 2.0 token for the current user.")] = None,
        pretty_print: Annotated[Optional[StrictBool], Field(description="Returns response with indentations and line breaks.")] = None,
        quota_user: Annotated[Optional[StrictStr], Field(description="An opaque string that represents a user for quota purposes. Must not exceed 40 characters.")] = None,
        upload_type: Annotated[Optional[StrictStr], Field(description="Upload protocol for media (e.g. \"media\", \"multipart\", \"resumable\").")] = None,
        user_ip: Annotated[Optional[StrictStr], Field(description="Deprecated. Please use quotaUser instead.")] = None,
        generation: Annotated[Optional[StrictStr], Field(description="If present, selects a specific revision of this object (as opposed to the latest version, the default).")] = None,
        if_generation_match: Annotated[Optional[StrictStr], Field(description="Makes the operation conditional on whether the object's current generation matches the given value. Setting to 0 makes the operation succeed only if there are no live versions of the object.")] = None,
        if_generation_not_match: Annotated[Optional[StrictStr], Field(description="Makes the operation conditional on whether the object's current generation does not match the given value. If no live object exists, the precondition fails. Setting to 0 makes the operation succeed only if there is a live version of the object.")] = None,
        if_metageneration_match: Annotated[Optional[StrictStr], Field(description="Makes the operation conditional on whether the object's current metageneration matches the given value.")] = None,
        if_metageneration_not_match: Annotated[Optional[StrictStr], Field(description="Makes the operation conditional on whether the object's current metageneration does not match the given value.")] = None,
        override_unlocked_retention: Annotated[Optional[StrictBool], Field(description="Must be true to remove the retention configuration, reduce its unlocked retention period, or change its mode from unlocked to locked.")] = None,
        predefined_acl: Annotated[Optional[StrictStr], Field(description="Apply a predefined set of access controls to this object.")] = None,
        projection: Annotated[Optional[StrictStr], Field(description="Set of properties to return. Defaults to full.")] = None,
        user_project: Annotated[Optional[StrictStr], Field(description="The project to be billed for this request. Required for Requester Pays buckets.")] = None,
        object2: Optional[Object] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> Object:
        """storage_objects_update

        Updates an object's metadata.

        :param bucket: Name of the bucket in which the object resides. (required)
        :type bucket: str
        :param object: Name of the object. For information about how to URL encode object names to be path safe, see [Encoding URI Path Parts](https://cloud.google.com/storage/docs/request-endpoints#encoding). (required)
        :type object: str
        :param alt: Data format for the response.
        :type alt: str
        :param fields: Selector specifying which fields to include in a partial response.
        :type fields: str
        :param key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :type key: str
        :param oauth_token: OAuth 2.0 token for the current user.
        :type oauth_token: str
        :param pretty_print: Returns response with indentations and line breaks.
        :type pretty_print: bool
        :param quota_user: An opaque string that represents a user for quota purposes. Must not exceed 40 characters.
        :type quota_user: str
        :param upload_type: Upload protocol for media (e.g. \"media\", \"multipart\", \"resumable\").
        :type upload_type: str
        :param user_ip: Deprecated. Please use quotaUser instead.
        :type user_ip: str
        :param generation: If present, selects a specific revision of this object (as opposed to the latest version, the default).
        :type generation: str
        :param if_generation_match: Makes the operation conditional on whether the object's current generation matches the given value. Setting to 0 makes the operation succeed only if there are no live versions of the object.
        :type if_generation_match: str
        :param if_generation_not_match: Makes the operation conditional on whether the object's current generation does not match the given value. If no live object exists, the precondition fails. Setting to 0 makes the operation succeed only if there is a live version of the object.
        :type if_generation_not_match: str
        :param if_metageneration_match: Makes the operation conditional on whether the object's current metageneration matches the given value.
        :type if_metageneration_match: str
        :param if_metageneration_not_match: Makes the operation conditional on whether the object's current metageneration does not match the given value.
        :type if_metageneration_not_match: str
        :param override_unlocked_retention: Must be true to remove the retention configuration, reduce its unlocked retention period, or change its mode from unlocked to locked.
        :type override_unlocked_retention: bool
        :param predefined_acl: Apply a predefined set of access controls to this object.
        :type predefined_acl: str
        :param projection: Set of properties to return. Defaults to full.
        :type projection: str
        :param user_project: The project to be billed for this request. Required for Requester Pays buckets.
        :type user_project: str
        :param object2:
        :type object2: Object
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._storage_objects_update_serialize(
            bucket=bucket,
            object=object,
            alt=alt,
            fields=fields,
            key=key,
            oauth_token=oauth_token,
            pretty_print=pretty_print,
            quota_user=quota_user,
            upload_type=upload_type,
            user_ip=user_ip,
            generation=generation,
            if_generation_match=if_generation_match,
            if_generation_not_match=if_generation_not_match,
            if_metageneration_match=if_metageneration_match,
            if_metageneration_not_match=if_metageneration_not_match,
            override_unlocked_retention=override_unlocked_retention,
            predefined_acl=predefined_acl,
            projection=projection,
            user_project=user_project,
            object2=object2,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def storage_objects_update_with_http_info(
        self,
        bucket: Annotated[StrictStr, Field(description="Name of the bucket in which the object resides.")],
        object: Annotated[StrictStr, Field(description="Name of the object. For information about how to URL encode object names to be path safe, see [Encoding URI Path Parts](https://cloud.google.com/storage/docs/request-endpoints#encoding).")],
        alt: Annotated[Optional[StrictStr], Field(description="Data format for the response.")] = None,
        fields: Annotated[Optional[StrictStr], Field(description="Selector specifying which fields to include in a partial response.")] = None,
        key: Annotated[Optional[StrictStr], Field(description="API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.")] = None,
        oauth_token: Annotated[Optional[StrictStr], Field(description="OAuth 2.0 token for the current user.")] = None,
        pretty_print: Annotated[Optional[StrictBool], Field(description="Returns response with indentations and line breaks.")] = None,
        quota_user: Annotated[Optional[StrictStr], Field(description="An opaque string that represents a user for quota purposes. Must not exceed 40 characters.")] = None,
        upload_type: Annotated[Optional[StrictStr], Field(description="Upload protocol for media (e.g. \"media\", \"multipart\", \"resumable\").")] = None,
        user_ip: Annotated[Optional[StrictStr], Field(description="Deprecated. Please use quotaUser instead.")] = None,
        generation: Annotated[Optional[StrictStr], Field(description="If present, selects a specific revision of this object (as opposed to the latest version, the default).")] = None,
        if_generation_match: Annotated[Optional[StrictStr], Field(description="Makes the operation conditional on whether the object's current generation matches the given value. Setting to 0 makes the operation succeed only if there are no live versions of the object.")] = None,
        if_generation_not_match: Annotated[Optional[StrictStr], Field(description="Makes the operation conditional on whether the object's current generation does not match the given value. If no live object exists, the precondition fails. Setting to 0 makes the operation succeed only if there is a live version of the object.")] = None,
        if_metageneration_match: Annotated[Optional[StrictStr], Field(description="Makes the operation conditional on whether the object's current metageneration matches the given value.")] = None,
        if_metageneration_not_match: Annotated[Optional[StrictStr], Field(description="Makes the operation conditional on whether the object's current metageneration does not match the given value.")] = None,
        override_unlocked_retention: Annotated[Optional[StrictBool], Field(description="Must be true to remove the retention configuration, reduce its unlocked retention period, or change its mode from unlocked to locked.")] = None,
        predefined_acl: Annotated[Optional[StrictStr], Field(description="Apply a predefined set of access controls to this object.")] = None,
        projection: Annotated[Optional[StrictStr], Field(description="Set of properties to return. Defaults to full.")] = None,
        user_project: Annotated[Optional[StrictStr], Field(description="The project to be billed for this request. Required for Requester Pays buckets.")] = None,
        object2: Optional[Object] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[Object]:
        """storage_objects_update

        Updates an object's metadata.

        :param bucket: Name of the bucket in which the object resides. (required)
        :type bucket: str
        :param object: Name of the object. For information about how to URL encode object names to be path safe, see [Encoding URI Path Parts](https://cloud.google.com/storage/docs/request-endpoints#encoding). (required)
        :type object: str
        :param alt: Data format for the response.
        :type alt: str
        :param fields: Selector specifying which fields to include in a partial response.
        :type fields: str
        :param key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :type key: str
        :param oauth_token: OAuth 2.0 token for the current user.
        :type oauth_token: str
        :param pretty_print: Returns response with indentations and line breaks.
        :type pretty_print: bool
        :param quota_user: An opaque string that represents a user for quota purposes. Must not exceed 40 characters.
        :type quota_user: str
        :param upload_type: Upload protocol for media (e.g. \"media\", \"multipart\", \"resumable\").
        :type upload_type: str
        :param user_ip: Deprecated. Please use quotaUser instead.
        :type user_ip: str
        :param generation: If present, selects a specific revision of this object (as opposed to the latest version, the default).
        :type generation: str
        :param if_generation_match: Makes the operation conditional on whether the object's current generation matches the given value. Setting to 0 makes the operation succeed only if there are no live versions of the object.
        :type if_generation_match: str
        :param if_generation_not_match: Makes the operation conditional on whether the object's current generation does not match the given value. If no live object exists, the precondition fails. Setting to 0 makes the operation succeed only if there is a live version of the object.
        :type if_generation_not_match: str
        :param if_metageneration_match: Makes the operation conditional on whether the object's current metageneration matches the given value.
        :type if_metageneration_match: str
        :param if_metageneration_not_match: Makes the operation conditional on whether the object's current metageneration does not match the given value.
        :type if_metageneration_not_match: str
        :param override_unlocked_retention: Must be true to remove the retention configuration, reduce its unlocked retention period, or change its mode from unlocked to locked.
        :type override_unlocked_retention: bool
        :param predefined_acl: Apply a predefined set of access controls to this object.
        :type predefined_acl: str
        :param projection: Set of properties to return. Defaults to full.
        :type projection: str
        :param user_project: The project to be billed for this request. Required for Requester Pays buckets.
        :type user_project: str
        :param object2:
        :type object2: Object
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._storage_objects_update_serialize(
            bucket=bucket,
            object=object,
            alt=alt,
            fields=fields,
            key=key,
            oauth_token=oauth_token,
            pretty_print=pretty_print,
            quota_user=quota_user,
            upload_type=upload_type,
            user_ip=user_ip,
            generation=generation,
            if_generation_match=if_generation_match,
            if_generation_not_match=if_generation_not_match,
            if_metageneration_match=if_metageneration_match,
            if_metageneration_not_match=if_metageneration_not_match,
            override_unlocked_retention=override_unlocked_retention,
            predefined_acl=predefined_acl,
            projection=projection,
            user_project=user_project,
            object2=object2,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def storage_objects_update_without_preload_content(
        self,
        bucket: Annotated[StrictStr, Field(description="Name of the bucket in which the object resides.")],
        object: Annotated[StrictStr, Field(description="Name of the object. For information about how to URL encode object names to be path safe, see [Encoding URI Path Parts](https://cloud.google.com/storage/docs/request-endpoints#encoding).")],
        alt: Annotated[Optional[StrictStr], Field(description="Data format for the response.")] = None,
        fields: Annotated[Optional[StrictStr], Field(description="Selector specifying which fields to include in a partial response.")] = None,
        key: Annotated[Optional[StrictStr], Field(description="API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.")] = None,
        oauth_token: Annotated[Optional[StrictStr], Field(description="OAuth 2.0 token for the current user.")] = None,
        pretty_print: Annotated[Optional[StrictBool], Field(description="Returns response with indentations and line breaks.")] = None,
        quota_user: Annotated[Optional[StrictStr], Field(description="An opaque string that represents a user for quota purposes. Must not exceed 40 characters.")] = None,
        upload_type: Annotated[Optional[StrictStr], Field(description="Upload protocol for media (e.g. \"media\", \"multipart\", \"resumable\").")] = None,
        user_ip: Annotated[Optional[StrictStr], Field(description="Deprecated. Please use quotaUser instead.")] = None,
        generation: Annotated[Optional[StrictStr], Field(description="If present, selects a specific revision of this object (as opposed to the latest version, the default).")] = None,
        if_generation_match: Annotated[Optional[StrictStr], Field(description="Makes the operation conditional on whether the object's current generation matches the given value. Setting to 0 makes the operation succeed only if there are no live versions of the object.")] = None,
        if_generation_not_match: Annotated[Optional[StrictStr], Field(description="Makes the operation conditional on whether the object's current generation does not match the given value. If no live object exists, the precondition fails. Setting to 0 makes the operation succeed only if there is a live version of the object.")] = None,
        if_metageneration_match: Annotated[Optional[StrictStr], Field(description="Makes the operation conditional on whether the object's current metageneration matches the given value.")] = None,
        if_metageneration_not_match: Annotated[Optional[StrictStr], Field(description="Makes the operation conditional on whether the object's current metageneration does not match the given value.")] = None,
        override_unlocked_retention: Annotated[Optional[StrictBool], Field(description="Must be true to remove the retention configuration, reduce its unlocked retention period, or change its mode from unlocked to locked.")] = None,
        predefined_acl: Annotated[Optional[StrictStr], Field(description="Apply a predefined set of access controls to this object.")] = None,
        projection: Annotated[Optional[StrictStr], Field(description="Set of properties to return. Defaults to full.")] = None,
        user_project: Annotated[Optional[StrictStr], Field(description="The project to be billed for this request. Required for Requester Pays buckets.")] = None,
        object2: Optional[Object] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """storage_objects_update

        Updates an object's metadata.

        :param bucket: Name of the bucket in which the object resides. (required)
        :type bucket: str
        :param object: Name of the object. For information about how to URL encode object names to be path safe, see [Encoding URI Path Parts](https://cloud.google.com/storage/docs/request-endpoints#encoding). (required)
        :type object: str
        :param alt: Data format for the response.
        :type alt: str
        :param fields: Selector specifying which fields to include in a partial response.
        :type fields: str
        :param key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :type key: str
        :param oauth_token: OAuth 2.0 token for the current user.
        :type oauth_token: str
        :param pretty_print: Returns response with indentations and line breaks.
        :type pretty_print: bool
        :param quota_user: An opaque string that represents a user for quota purposes. Must not exceed 40 characters.
        :type quota_user: str
        :param upload_type: Upload protocol for media (e.g. \"media\", \"multipart\", \"resumable\").
        :type upload_type: str
        :param user_ip: Deprecated. Please use quotaUser instead.
        :type user_ip: str
        :param generation: If present, selects a specific revision of this object (as opposed to the latest version, the default).
        :type generation: str
        :param if_generation_match: Makes the operation conditional on whether the object's current generation matches the given value. Setting to 0 makes the operation succeed only if there are no live versions of the object.
        :type if_generation_match: str
        :param if_generation_not_match: Makes the operation conditional on whether the object's current generation does not match the given value. If no live object exists, the precondition fails. Setting to 0 makes the operation succeed only if there is a live version of the object.
        :type if_generation_not_match: str
        :param if_metageneration_match: Makes the operation conditional on whether the object's current metageneration matches the given value.
        :type if_metageneration_match: str
        :param if_metageneration_not_match: Makes the operation conditional on whether the object's current metageneration does not match the given value.
        :type if_metageneration_not_match: str
        :param override_unlocked_retention: Must be true to remove the retention configuration, reduce its unlocked retention period, or change its mode from unlocked to locked.
        :type override_unlocked_retention: bool
        :param predefined_acl: Apply a predefined set of access controls to this object.
        :type predefined_acl: str
        :param projection: Set of properties to return. Defaults to full.
        :type projection: str
        :param user_project: The project to be billed for this request. Required for Requester Pays buckets.
        :type user_project: str
        :param object2:
        :type object2: Object
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._storage_objects_update_serialize(
            bucket=bucket,
            object=object,
            alt=alt,
            fields=fields,
            key=key,
            oauth_token=oauth_token,
            pretty_print=pretty_print,
            quota_user=quota_user,
            upload_type=upload_type,
            user_ip=user_ip,
            generation=generation,
            if_generation_match=if_generation_match,
            if_generation_not_match=if_generation_not_match,
            if_metageneration_match=if_metageneration_match,
            if_metageneration_not_match=if_metageneration_not_match,
            override_unlocked_retention=override_unlocked_retention,
            predefined_acl=predefined_acl,
            projection=projection,
            user_project=user_project,
            object2=object2,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _storage_objects_update_serialize(
        self,
        bucket,
        object,
        alt,
        fields,
        key,
        oauth_token,
        pretty_print,
        quota_user,
        upload_type,
        user_ip,
        generation,
        if_generation_match,
        if_generation_not_match,
        if_metageneration_match,
        if_metageneration_not_match,
        override_unlocked_retention,
        predefined_acl,
        projection,
        user_project,
        object2,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if bucket is not None:
            _path_params['bucket'] = bucket
        if object is not None:
            _path_params['object'] = object
        # process the query parameters
        if alt is not None:
            
            _query_params.append(('alt', alt))
            
        if fields is not None:
            
            _query_params.append(('fields', fields))
            
        if key is not None:
            
            _query_params.append(('key', key))
            
        if oauth_token is not None:
            
            _query_params.append(('oauth_token', oauth_token))
            
        if pretty_print is not None:
            
            _query_params.append(('prettyPrint', pretty_print))
            
        if quota_user is not None:
            
            _query_params.append(('quotaUser', quota_user))
            
        if upload_type is not None:
            
            _query_params.append(('uploadType', upload_type))
            
        if user_ip is not None:
            
            _query_params.append(('userIp', user_ip))
            
        if generation is not None:
            
            _query_params.append(('generation', generation))
            
        if if_generation_match is not None:
            
            _query_params.append(('ifGenerationMatch', if_generation_match))
            
        if if_generation_not_match is not None:
            
            _query_params.append(('ifGenerationNotMatch', if_generation_not_match))
            
        if if_metageneration_match is not None:
            
            _query_params.append(('ifMetagenerationMatch', if_metageneration_match))
            
        if if_metageneration_not_match is not None:
            
            _query_params.append(('ifMetagenerationNotMatch', if_metageneration_not_match))
            
        if override_unlocked_retention is not None:
            
            _query_params.append(('overrideUnlockedRetention', override_unlocked_retention))
            
        if predefined_acl is not None:
            
            _query_params.append(('predefinedAcl', predefined_acl))
            
        if projection is not None:
            
            _query_params.append(('projection', projection))
            
        if user_project is not None:
            
            _query_params.append(('userProject', user_project))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if object2 is not None:
            _body_params = object2


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'Oauth2c', 
            'Oauth2'
        ]

        return self.api_client.param_serialize(
            method='PUT',
            resource_path='/b/{bucket}/o/{object}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def storage_objects_watch_all(
        self,
        bucket: Annotated[StrictStr, Field(description="Name of the bucket in which to look for objects.")],
        alt: Annotated[Optional[StrictStr], Field(description="Data format for the response.")] = None,
        fields: Annotated[Optional[StrictStr], Field(description="Selector specifying which fields to include in a partial response.")] = None,
        key: Annotated[Optional[StrictStr], Field(description="API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.")] = None,
        oauth_token: Annotated[Optional[StrictStr], Field(description="OAuth 2.0 token for the current user.")] = None,
        pretty_print: Annotated[Optional[StrictBool], Field(description="Returns response with indentations and line breaks.")] = None,
        quota_user: Annotated[Optional[StrictStr], Field(description="An opaque string that represents a user for quota purposes. Must not exceed 40 characters.")] = None,
        upload_type: Annotated[Optional[StrictStr], Field(description="Upload protocol for media (e.g. \"media\", \"multipart\", \"resumable\").")] = None,
        user_ip: Annotated[Optional[StrictStr], Field(description="Deprecated. Please use quotaUser instead.")] = None,
        delimiter: Annotated[Optional[StrictStr], Field(description="Returns results in a directory-like mode. items will contain only objects whose names, aside from the prefix, do not contain delimiter. Objects whose names, aside from the prefix, contain delimiter will have their name, truncated after the delimiter, returned in prefixes. Duplicate prefixes are omitted.")] = None,
        end_offset: Annotated[Optional[StrictStr], Field(description="Filter results to objects whose names are lexicographically before endOffset. If startOffset is also set, the objects listed will have names between startOffset (inclusive) and endOffset (exclusive).")] = None,
        include_trailing_delimiter: Annotated[Optional[StrictBool], Field(description="If true, objects that end in exactly one instance of delimiter will have their metadata included in items in addition to prefixes.")] = None,
        max_results: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Maximum number of items plus prefixes to return in a single page of responses. As duplicate prefixes are omitted, fewer total results may be returned than requested. The service will use this parameter or 1,000 items, whichever is smaller.")] = None,
        page_token: Annotated[Optional[StrictStr], Field(description="A previously-returned page token representing part of the larger set of results to view.")] = None,
        prefix: Annotated[Optional[StrictStr], Field(description="Filter results to objects whose names begin with this prefix.")] = None,
        projection: Annotated[Optional[StrictStr], Field(description="Set of properties to return. Defaults to noAcl.")] = None,
        start_offset: Annotated[Optional[StrictStr], Field(description="Filter results to objects whose names are lexicographically equal to or after startOffset. If endOffset is also set, the objects listed will have names between startOffset (inclusive) and endOffset (exclusive).")] = None,
        user_project: Annotated[Optional[StrictStr], Field(description="The project to be billed for this request. Required for Requester Pays buckets.")] = None,
        versions: Annotated[Optional[StrictBool], Field(description="If true, lists all versions of an object as distinct results. The default is false. For more information, see Object Versioning.")] = None,
        channel: Optional[Channel] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> Channel:
        """storage_objects_watch_all

        Watch for changes on all objects in a bucket.

        :param bucket: Name of the bucket in which to look for objects. (required)
        :type bucket: str
        :param alt: Data format for the response.
        :type alt: str
        :param fields: Selector specifying which fields to include in a partial response.
        :type fields: str
        :param key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :type key: str
        :param oauth_token: OAuth 2.0 token for the current user.
        :type oauth_token: str
        :param pretty_print: Returns response with indentations and line breaks.
        :type pretty_print: bool
        :param quota_user: An opaque string that represents a user for quota purposes. Must not exceed 40 characters.
        :type quota_user: str
        :param upload_type: Upload protocol for media (e.g. \"media\", \"multipart\", \"resumable\").
        :type upload_type: str
        :param user_ip: Deprecated. Please use quotaUser instead.
        :type user_ip: str
        :param delimiter: Returns results in a directory-like mode. items will contain only objects whose names, aside from the prefix, do not contain delimiter. Objects whose names, aside from the prefix, contain delimiter will have their name, truncated after the delimiter, returned in prefixes. Duplicate prefixes are omitted.
        :type delimiter: str
        :param end_offset: Filter results to objects whose names are lexicographically before endOffset. If startOffset is also set, the objects listed will have names between startOffset (inclusive) and endOffset (exclusive).
        :type end_offset: str
        :param include_trailing_delimiter: If true, objects that end in exactly one instance of delimiter will have their metadata included in items in addition to prefixes.
        :type include_trailing_delimiter: bool
        :param max_results: Maximum number of items plus prefixes to return in a single page of responses. As duplicate prefixes are omitted, fewer total results may be returned than requested. The service will use this parameter or 1,000 items, whichever is smaller.
        :type max_results: int
        :param page_token: A previously-returned page token representing part of the larger set of results to view.
        :type page_token: str
        :param prefix: Filter results to objects whose names begin with this prefix.
        :type prefix: str
        :param projection: Set of properties to return. Defaults to noAcl.
        :type projection: str
        :param start_offset: Filter results to objects whose names are lexicographically equal to or after startOffset. If endOffset is also set, the objects listed will have names between startOffset (inclusive) and endOffset (exclusive).
        :type start_offset: str
        :param user_project: The project to be billed for this request. Required for Requester Pays buckets.
        :type user_project: str
        :param versions: If true, lists all versions of an object as distinct results. The default is false. For more information, see Object Versioning.
        :type versions: bool
        :param channel:
        :type channel: Channel
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._storage_objects_watch_all_serialize(
            bucket=bucket,
            alt=alt,
            fields=fields,
            key=key,
            oauth_token=oauth_token,
            pretty_print=pretty_print,
            quota_user=quota_user,
            upload_type=upload_type,
            user_ip=user_ip,
            delimiter=delimiter,
            end_offset=end_offset,
            include_trailing_delimiter=include_trailing_delimiter,
            max_results=max_results,
            page_token=page_token,
            prefix=prefix,
            projection=projection,
            start_offset=start_offset,
            user_project=user_project,
            versions=versions,
            channel=channel,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Channel",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def storage_objects_watch_all_with_http_info(
        self,
        bucket: Annotated[StrictStr, Field(description="Name of the bucket in which to look for objects.")],
        alt: Annotated[Optional[StrictStr], Field(description="Data format for the response.")] = None,
        fields: Annotated[Optional[StrictStr], Field(description="Selector specifying which fields to include in a partial response.")] = None,
        key: Annotated[Optional[StrictStr], Field(description="API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.")] = None,
        oauth_token: Annotated[Optional[StrictStr], Field(description="OAuth 2.0 token for the current user.")] = None,
        pretty_print: Annotated[Optional[StrictBool], Field(description="Returns response with indentations and line breaks.")] = None,
        quota_user: Annotated[Optional[StrictStr], Field(description="An opaque string that represents a user for quota purposes. Must not exceed 40 characters.")] = None,
        upload_type: Annotated[Optional[StrictStr], Field(description="Upload protocol for media (e.g. \"media\", \"multipart\", \"resumable\").")] = None,
        user_ip: Annotated[Optional[StrictStr], Field(description="Deprecated. Please use quotaUser instead.")] = None,
        delimiter: Annotated[Optional[StrictStr], Field(description="Returns results in a directory-like mode. items will contain only objects whose names, aside from the prefix, do not contain delimiter. Objects whose names, aside from the prefix, contain delimiter will have their name, truncated after the delimiter, returned in prefixes. Duplicate prefixes are omitted.")] = None,
        end_offset: Annotated[Optional[StrictStr], Field(description="Filter results to objects whose names are lexicographically before endOffset. If startOffset is also set, the objects listed will have names between startOffset (inclusive) and endOffset (exclusive).")] = None,
        include_trailing_delimiter: Annotated[Optional[StrictBool], Field(description="If true, objects that end in exactly one instance of delimiter will have their metadata included in items in addition to prefixes.")] = None,
        max_results: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Maximum number of items plus prefixes to return in a single page of responses. As duplicate prefixes are omitted, fewer total results may be returned than requested. The service will use this parameter or 1,000 items, whichever is smaller.")] = None,
        page_token: Annotated[Optional[StrictStr], Field(description="A previously-returned page token representing part of the larger set of results to view.")] = None,
        prefix: Annotated[Optional[StrictStr], Field(description="Filter results to objects whose names begin with this prefix.")] = None,
        projection: Annotated[Optional[StrictStr], Field(description="Set of properties to return. Defaults to noAcl.")] = None,
        start_offset: Annotated[Optional[StrictStr], Field(description="Filter results to objects whose names are lexicographically equal to or after startOffset. If endOffset is also set, the objects listed will have names between startOffset (inclusive) and endOffset (exclusive).")] = None,
        user_project: Annotated[Optional[StrictStr], Field(description="The project to be billed for this request. Required for Requester Pays buckets.")] = None,
        versions: Annotated[Optional[StrictBool], Field(description="If true, lists all versions of an object as distinct results. The default is false. For more information, see Object Versioning.")] = None,
        channel: Optional[Channel] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[Channel]:
        """storage_objects_watch_all

        Watch for changes on all objects in a bucket.

        :param bucket: Name of the bucket in which to look for objects. (required)
        :type bucket: str
        :param alt: Data format for the response.
        :type alt: str
        :param fields: Selector specifying which fields to include in a partial response.
        :type fields: str
        :param key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :type key: str
        :param oauth_token: OAuth 2.0 token for the current user.
        :type oauth_token: str
        :param pretty_print: Returns response with indentations and line breaks.
        :type pretty_print: bool
        :param quota_user: An opaque string that represents a user for quota purposes. Must not exceed 40 characters.
        :type quota_user: str
        :param upload_type: Upload protocol for media (e.g. \"media\", \"multipart\", \"resumable\").
        :type upload_type: str
        :param user_ip: Deprecated. Please use quotaUser instead.
        :type user_ip: str
        :param delimiter: Returns results in a directory-like mode. items will contain only objects whose names, aside from the prefix, do not contain delimiter. Objects whose names, aside from the prefix, contain delimiter will have their name, truncated after the delimiter, returned in prefixes. Duplicate prefixes are omitted.
        :type delimiter: str
        :param end_offset: Filter results to objects whose names are lexicographically before endOffset. If startOffset is also set, the objects listed will have names between startOffset (inclusive) and endOffset (exclusive).
        :type end_offset: str
        :param include_trailing_delimiter: If true, objects that end in exactly one instance of delimiter will have their metadata included in items in addition to prefixes.
        :type include_trailing_delimiter: bool
        :param max_results: Maximum number of items plus prefixes to return in a single page of responses. As duplicate prefixes are omitted, fewer total results may be returned than requested. The service will use this parameter or 1,000 items, whichever is smaller.
        :type max_results: int
        :param page_token: A previously-returned page token representing part of the larger set of results to view.
        :type page_token: str
        :param prefix: Filter results to objects whose names begin with this prefix.
        :type prefix: str
        :param projection: Set of properties to return. Defaults to noAcl.
        :type projection: str
        :param start_offset: Filter results to objects whose names are lexicographically equal to or after startOffset. If endOffset is also set, the objects listed will have names between startOffset (inclusive) and endOffset (exclusive).
        :type start_offset: str
        :param user_project: The project to be billed for this request. Required for Requester Pays buckets.
        :type user_project: str
        :param versions: If true, lists all versions of an object as distinct results. The default is false. For more information, see Object Versioning.
        :type versions: bool
        :param channel:
        :type channel: Channel
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._storage_objects_watch_all_serialize(
            bucket=bucket,
            alt=alt,
            fields=fields,
            key=key,
            oauth_token=oauth_token,
            pretty_print=pretty_print,
            quota_user=quota_user,
            upload_type=upload_type,
            user_ip=user_ip,
            delimiter=delimiter,
            end_offset=end_offset,
            include_trailing_delimiter=include_trailing_delimiter,
            max_results=max_results,
            page_token=page_token,
            prefix=prefix,
            projection=projection,
            start_offset=start_offset,
            user_project=user_project,
            versions=versions,
            channel=channel,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Channel",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def storage_objects_watch_all_without_preload_content(
        self,
        bucket: Annotated[StrictStr, Field(description="Name of the bucket in which to look for objects.")],
        alt: Annotated[Optional[StrictStr], Field(description="Data format for the response.")] = None,
        fields: Annotated[Optional[StrictStr], Field(description="Selector specifying which fields to include in a partial response.")] = None,
        key: Annotated[Optional[StrictStr], Field(description="API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.")] = None,
        oauth_token: Annotated[Optional[StrictStr], Field(description="OAuth 2.0 token for the current user.")] = None,
        pretty_print: Annotated[Optional[StrictBool], Field(description="Returns response with indentations and line breaks.")] = None,
        quota_user: Annotated[Optional[StrictStr], Field(description="An opaque string that represents a user for quota purposes. Must not exceed 40 characters.")] = None,
        upload_type: Annotated[Optional[StrictStr], Field(description="Upload protocol for media (e.g. \"media\", \"multipart\", \"resumable\").")] = None,
        user_ip: Annotated[Optional[StrictStr], Field(description="Deprecated. Please use quotaUser instead.")] = None,
        delimiter: Annotated[Optional[StrictStr], Field(description="Returns results in a directory-like mode. items will contain only objects whose names, aside from the prefix, do not contain delimiter. Objects whose names, aside from the prefix, contain delimiter will have their name, truncated after the delimiter, returned in prefixes. Duplicate prefixes are omitted.")] = None,
        end_offset: Annotated[Optional[StrictStr], Field(description="Filter results to objects whose names are lexicographically before endOffset. If startOffset is also set, the objects listed will have names between startOffset (inclusive) and endOffset (exclusive).")] = None,
        include_trailing_delimiter: Annotated[Optional[StrictBool], Field(description="If true, objects that end in exactly one instance of delimiter will have their metadata included in items in addition to prefixes.")] = None,
        max_results: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Maximum number of items plus prefixes to return in a single page of responses. As duplicate prefixes are omitted, fewer total results may be returned than requested. The service will use this parameter or 1,000 items, whichever is smaller.")] = None,
        page_token: Annotated[Optional[StrictStr], Field(description="A previously-returned page token representing part of the larger set of results to view.")] = None,
        prefix: Annotated[Optional[StrictStr], Field(description="Filter results to objects whose names begin with this prefix.")] = None,
        projection: Annotated[Optional[StrictStr], Field(description="Set of properties to return. Defaults to noAcl.")] = None,
        start_offset: Annotated[Optional[StrictStr], Field(description="Filter results to objects whose names are lexicographically equal to or after startOffset. If endOffset is also set, the objects listed will have names between startOffset (inclusive) and endOffset (exclusive).")] = None,
        user_project: Annotated[Optional[StrictStr], Field(description="The project to be billed for this request. Required for Requester Pays buckets.")] = None,
        versions: Annotated[Optional[StrictBool], Field(description="If true, lists all versions of an object as distinct results. The default is false. For more information, see Object Versioning.")] = None,
        channel: Optional[Channel] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """storage_objects_watch_all

        Watch for changes on all objects in a bucket.

        :param bucket: Name of the bucket in which to look for objects. (required)
        :type bucket: str
        :param alt: Data format for the response.
        :type alt: str
        :param fields: Selector specifying which fields to include in a partial response.
        :type fields: str
        :param key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :type key: str
        :param oauth_token: OAuth 2.0 token for the current user.
        :type oauth_token: str
        :param pretty_print: Returns response with indentations and line breaks.
        :type pretty_print: bool
        :param quota_user: An opaque string that represents a user for quota purposes. Must not exceed 40 characters.
        :type quota_user: str
        :param upload_type: Upload protocol for media (e.g. \"media\", \"multipart\", \"resumable\").
        :type upload_type: str
        :param user_ip: Deprecated. Please use quotaUser instead.
        :type user_ip: str
        :param delimiter: Returns results in a directory-like mode. items will contain only objects whose names, aside from the prefix, do not contain delimiter. Objects whose names, aside from the prefix, contain delimiter will have their name, truncated after the delimiter, returned in prefixes. Duplicate prefixes are omitted.
        :type delimiter: str
        :param end_offset: Filter results to objects whose names are lexicographically before endOffset. If startOffset is also set, the objects listed will have names between startOffset (inclusive) and endOffset (exclusive).
        :type end_offset: str
        :param include_trailing_delimiter: If true, objects that end in exactly one instance of delimiter will have their metadata included in items in addition to prefixes.
        :type include_trailing_delimiter: bool
        :param max_results: Maximum number of items plus prefixes to return in a single page of responses. As duplicate prefixes are omitted, fewer total results may be returned than requested. The service will use this parameter or 1,000 items, whichever is smaller.
        :type max_results: int
        :param page_token: A previously-returned page token representing part of the larger set of results to view.
        :type page_token: str
        :param prefix: Filter results to objects whose names begin with this prefix.
        :type prefix: str
        :param projection: Set of properties to return. Defaults to noAcl.
        :type projection: str
        :param start_offset: Filter results to objects whose names are lexicographically equal to or after startOffset. If endOffset is also set, the objects listed will have names between startOffset (inclusive) and endOffset (exclusive).
        :type start_offset: str
        :param user_project: The project to be billed for this request. Required for Requester Pays buckets.
        :type user_project: str
        :param versions: If true, lists all versions of an object as distinct results. The default is false. For more information, see Object Versioning.
        :type versions: bool
        :param channel:
        :type channel: Channel
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._storage_objects_watch_all_serialize(
            bucket=bucket,
            alt=alt,
            fields=fields,
            key=key,
            oauth_token=oauth_token,
            pretty_print=pretty_print,
            quota_user=quota_user,
            upload_type=upload_type,
            user_ip=user_ip,
            delimiter=delimiter,
            end_offset=end_offset,
            include_trailing_delimiter=include_trailing_delimiter,
            max_results=max_results,
            page_token=page_token,
            prefix=prefix,
            projection=projection,
            start_offset=start_offset,
            user_project=user_project,
            versions=versions,
            channel=channel,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Channel",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _storage_objects_watch_all_serialize(
        self,
        bucket,
        alt,
        fields,
        key,
        oauth_token,
        pretty_print,
        quota_user,
        upload_type,
        user_ip,
        delimiter,
        end_offset,
        include_trailing_delimiter,
        max_results,
        page_token,
        prefix,
        projection,
        start_offset,
        user_project,
        versions,
        channel,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if bucket is not None:
            _path_params['bucket'] = bucket
        # process the query parameters
        if alt is not None:
            
            _query_params.append(('alt', alt))
            
        if fields is not None:
            
            _query_params.append(('fields', fields))
            
        if key is not None:
            
            _query_params.append(('key', key))
            
        if oauth_token is not None:
            
            _query_params.append(('oauth_token', oauth_token))
            
        if pretty_print is not None:
            
            _query_params.append(('prettyPrint', pretty_print))
            
        if quota_user is not None:
            
            _query_params.append(('quotaUser', quota_user))
            
        if upload_type is not None:
            
            _query_params.append(('uploadType', upload_type))
            
        if user_ip is not None:
            
            _query_params.append(('userIp', user_ip))
            
        if delimiter is not None:
            
            _query_params.append(('delimiter', delimiter))
            
        if end_offset is not None:
            
            _query_params.append(('endOffset', end_offset))
            
        if include_trailing_delimiter is not None:
            
            _query_params.append(('includeTrailingDelimiter', include_trailing_delimiter))
            
        if max_results is not None:
            
            _query_params.append(('maxResults', max_results))
            
        if page_token is not None:
            
            _query_params.append(('pageToken', page_token))
            
        if prefix is not None:
            
            _query_params.append(('prefix', prefix))
            
        if projection is not None:
            
            _query_params.append(('projection', projection))
            
        if start_offset is not None:
            
            _query_params.append(('startOffset', start_offset))
            
        if user_project is not None:
            
            _query_params.append(('userProject', user_project))
            
        if versions is not None:
            
            _query_params.append(('versions', versions))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if channel is not None:
            _body_params = channel


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'Oauth2c', 
            'Oauth2'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/b/{bucket}/o/watch',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )


