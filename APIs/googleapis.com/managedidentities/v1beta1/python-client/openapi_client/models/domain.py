# coding: utf-8

"""
    Managed Service for Microsoft Active Directory API

    The Managed Service for Microsoft Active Directory API is used for managing a highly available, hardened service running Microsoft Active Directory (AD).

    The version of the OpenAPI document: v1beta1
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictStr, field_validator
from typing import Any, ClassVar, Dict, List, Optional
from openapi_client.models.trust import Trust
from typing import Optional, Set
from typing_extensions import Self

class Domain(BaseModel):
    """
    Represents a managed Microsoft Active Directory domain. If the domain is being changed, it will be placed into the UPDATING state, which indicates that the resource is being reconciled. At this point, Get will reflect an intermediate state.
    """ # noqa: E501
    admin: Optional[StrictStr] = Field(default=None, description="Optional. The name of delegated administrator account used to perform Active Directory operations. If not specified, `setupadmin` will be used.")
    audit_logs_enabled: Optional[StrictBool] = Field(default=None, description="Optional. Configuration for audit logs. True if audit logs are enabled, else false. Default is audit logs disabled.", alias="auditLogsEnabled")
    authorized_networks: Optional[List[StrictStr]] = Field(default=None, description="Optional. The full names of the Google Compute Engine [networks](/compute/docs/networks-and-firewalls#networks) the domain instance is connected to. Networks can be added using UpdateDomain. The domain is only available on networks listed in `authorized_networks`. If CIDR subnets overlap between networks, domain creation will fail.", alias="authorizedNetworks")
    create_time: Optional[StrictStr] = Field(default=None, description="Output only. The time the instance was created.", alias="createTime")
    fqdn: Optional[StrictStr] = Field(default=None, description="Output only. The fully-qualified domain name of the exposed domain used by clients to connect to the service. Similar to what would be chosen for an Active Directory set up on an internal network.")
    labels: Optional[Dict[str, StrictStr]] = Field(default=None, description="Optional. Resource labels that can contain user-provided metadata.")
    locations: Optional[List[StrictStr]] = Field(default=None, description="Required. Locations where domain needs to be provisioned. regions e.g. us-west1 or us-east4 Service supports up to 4 locations at once. Each location will use a /26 block.")
    name: Optional[StrictStr] = Field(default=None, description="Output only. The unique name of the domain using the form: `projects/{project_id}/locations/global/domains/{domain_name}`.")
    reserved_ip_range: Optional[StrictStr] = Field(default=None, description="Required. The CIDR range of internal addresses that are reserved for this domain. Reserved networks must be /24 or larger. Ranges must be unique and non-overlapping with existing subnets in [Domain].[authorized_networks].", alias="reservedIpRange")
    state: Optional[StrictStr] = Field(default=None, description="Output only. The current state of this domain.")
    status_message: Optional[StrictStr] = Field(default=None, description="Output only. Additional information about the current status of this domain, if available.", alias="statusMessage")
    trusts: Optional[List[Trust]] = Field(default=None, description="Output only. The current trusts associated with the domain.")
    update_time: Optional[StrictStr] = Field(default=None, description="Output only. The last update time.", alias="updateTime")
    __properties: ClassVar[List[str]] = ["admin", "auditLogsEnabled", "authorizedNetworks", "createTime", "fqdn", "labels", "locations", "name", "reservedIpRange", "state", "statusMessage", "trusts", "updateTime"]

    @field_validator('state')
    def state_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['STATE_UNSPECIFIED', 'CREATING', 'READY', 'UPDATING', 'DELETING', 'REPAIRING', 'PERFORMING_MAINTENANCE', 'UNAVAILABLE']):
            raise ValueError("must be one of enum values ('STATE_UNSPECIFIED', 'CREATING', 'READY', 'UPDATING', 'DELETING', 'REPAIRING', 'PERFORMING_MAINTENANCE', 'UNAVAILABLE')")
        return value

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of Domain from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        """
        excluded_fields: Set[str] = set([
            "create_time",
            "fqdn",
            "name",
            "state",
            "status_message",
            "trusts",
            "update_time",
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of each item in trusts (list)
        _items = []
        if self.trusts:
            for _item_trusts in self.trusts:
                if _item_trusts:
                    _items.append(_item_trusts.to_dict())
            _dict['trusts'] = _items
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of Domain from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "admin": obj.get("admin"),
            "auditLogsEnabled": obj.get("auditLogsEnabled"),
            "authorizedNetworks": obj.get("authorizedNetworks"),
            "createTime": obj.get("createTime"),
            "fqdn": obj.get("fqdn"),
            "labels": obj.get("labels"),
            "locations": obj.get("locations"),
            "name": obj.get("name"),
            "reservedIpRange": obj.get("reservedIpRange"),
            "state": obj.get("state"),
            "statusMessage": obj.get("statusMessage"),
            "trusts": [Trust.from_dict(_item) for _item in obj["trusts"]] if obj.get("trusts") is not None else None,
            "updateTime": obj.get("updateTime")
        })
        return _obj


