# coding: utf-8

"""
    Managed Service for Microsoft Active Directory API

    The Managed Service for Microsoft Active Directory API is used for managing a highly available, hardened service running Microsoft Active Directory (AD).

    The version of the OpenAPI document: v1beta1
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field
from typing import Any, ClassVar, Dict, List, Optional
from openapi_client.models.google_cloud_saasaccelerator_management_providers_v1_slo_eligibility import GoogleCloudSaasacceleratorManagementProvidersV1SloEligibility
from typing import Optional, Set
from typing_extensions import Self

class GoogleCloudSaasacceleratorManagementProvidersV1PerSliSloEligibility(BaseModel):
    """
    PerSliSloEligibility is a mapping from an SLI name to eligibility.
    """ # noqa: E501
    eligibilities: Optional[Dict[str, GoogleCloudSaasacceleratorManagementProvidersV1SloEligibility]] = Field(default=None, description="An entry in the eligibilities map specifies an eligibility for a particular SLI for the given instance. The SLI key in the name must be a valid SLI name specified in the Eligibility Exporter binary flags otherwise an error will be emitted by Eligibility Exporter and the oncaller will be alerted. If an SLI has been defined in the binary flags but the eligibilities map does not contain it, the corresponding SLI time series will not be emitted by the Eligibility Exporter. This ensures a smooth rollout and compatibility between the data produced by different versions of the Eligibility Exporters. If eligibilities map contains a key for an SLI which has not been declared in the binary flags, there will be an error message emitted in the Eligibility Exporter log and the metric for the SLI in question will not be emitted.")
    __properties: ClassVar[List[str]] = ["eligibilities"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of GoogleCloudSaasacceleratorManagementProvidersV1PerSliSloEligibility from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of each value in eligibilities (dict)
        _field_dict = {}
        if self.eligibilities:
            for _key_eligibilities in self.eligibilities:
                if self.eligibilities[_key_eligibilities]:
                    _field_dict[_key_eligibilities] = self.eligibilities[_key_eligibilities].to_dict()
            _dict['eligibilities'] = _field_dict
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of GoogleCloudSaasacceleratorManagementProvidersV1PerSliSloEligibility from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "eligibilities": dict(
                (_k, GoogleCloudSaasacceleratorManagementProvidersV1SloEligibility.from_dict(_v))
                for _k, _v in obj["eligibilities"].items()
            )
            if obj.get("eligibilities") is not None
            else None
        })
        return _obj


