# coding: utf-8

"""
    Search Ads 360 Reporting API

    The Search Ads 360 API allows developers to automate downloading reports from Search Ads 360.

    The version of the OpenAPI document: v0
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictStr, field_validator
from typing import Any, ClassVar, Dict, List, Optional
from typing import Optional, Set
from typing_extensions import Self

class GoogleAdsSearchads360V0ErrorsErrorCode(BaseModel):
    """
    The error reason represented by type and enum.
    """ # noqa: E501
    authentication_error: Optional[StrictStr] = Field(default=None, description="Indicates failure to properly authenticate user.", alias="authenticationError")
    authorization_error: Optional[StrictStr] = Field(default=None, description="An error encountered when trying to authorize a user.", alias="authorizationError")
    custom_column_error: Optional[StrictStr] = Field(default=None, description="The reasons for the custom column error", alias="customColumnError")
    date_error: Optional[StrictStr] = Field(default=None, description="The reasons for the date error", alias="dateError")
    date_range_error: Optional[StrictStr] = Field(default=None, description="The reasons for the date range error", alias="dateRangeError")
    distinct_error: Optional[StrictStr] = Field(default=None, description="The reasons for the distinct error", alias="distinctError")
    header_error: Optional[StrictStr] = Field(default=None, description="The reasons for the header error.", alias="headerError")
    internal_error: Optional[StrictStr] = Field(default=None, description="An unexpected server-side error.", alias="internalError")
    invalid_parameter_error: Optional[StrictStr] = Field(default=None, description="The reasons for invalid parameter errors.", alias="invalidParameterError")
    query_error: Optional[StrictStr] = Field(default=None, description="An error with the query", alias="queryError")
    quota_error: Optional[StrictStr] = Field(default=None, description="An error with the amount of quota remaining.", alias="quotaError")
    request_error: Optional[StrictStr] = Field(default=None, description="An error caused by the request", alias="requestError")
    size_limit_error: Optional[StrictStr] = Field(default=None, description="The reasons for the size limit error", alias="sizeLimitError")
    __properties: ClassVar[List[str]] = ["authenticationError", "authorizationError", "customColumnError", "dateError", "dateRangeError", "distinctError", "headerError", "internalError", "invalidParameterError", "queryError", "quotaError", "requestError", "sizeLimitError"]

    @field_validator('authentication_error')
    def authentication_error_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['UNSPECIFIED', 'UNKNOWN', 'AUTHENTICATION_ERROR', 'CLIENT_CUSTOMER_ID_INVALID', 'CUSTOMER_NOT_FOUND', 'GOOGLE_ACCOUNT_DELETED', 'GOOGLE_ACCOUNT_COOKIE_INVALID', 'GOOGLE_ACCOUNT_AUTHENTICATION_FAILED', 'GOOGLE_ACCOUNT_USER_AND_ADS_USER_MISMATCH', 'LOGIN_COOKIE_REQUIRED', 'NOT_ADS_USER', 'OAUTH_TOKEN_INVALID', 'OAUTH_TOKEN_EXPIRED', 'OAUTH_TOKEN_DISABLED', 'OAUTH_TOKEN_REVOKED', 'OAUTH_TOKEN_HEADER_INVALID', 'LOGIN_COOKIE_INVALID', 'USER_ID_INVALID', 'TWO_STEP_VERIFICATION_NOT_ENROLLED', 'ADVANCED_PROTECTION_NOT_ENROLLED']):
            raise ValueError("must be one of enum values ('UNSPECIFIED', 'UNKNOWN', 'AUTHENTICATION_ERROR', 'CLIENT_CUSTOMER_ID_INVALID', 'CUSTOMER_NOT_FOUND', 'GOOGLE_ACCOUNT_DELETED', 'GOOGLE_ACCOUNT_COOKIE_INVALID', 'GOOGLE_ACCOUNT_AUTHENTICATION_FAILED', 'GOOGLE_ACCOUNT_USER_AND_ADS_USER_MISMATCH', 'LOGIN_COOKIE_REQUIRED', 'NOT_ADS_USER', 'OAUTH_TOKEN_INVALID', 'OAUTH_TOKEN_EXPIRED', 'OAUTH_TOKEN_DISABLED', 'OAUTH_TOKEN_REVOKED', 'OAUTH_TOKEN_HEADER_INVALID', 'LOGIN_COOKIE_INVALID', 'USER_ID_INVALID', 'TWO_STEP_VERIFICATION_NOT_ENROLLED', 'ADVANCED_PROTECTION_NOT_ENROLLED')")
        return value

    @field_validator('authorization_error')
    def authorization_error_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['UNSPECIFIED', 'UNKNOWN', 'USER_PERMISSION_DENIED', 'PROJECT_DISABLED', 'AUTHORIZATION_ERROR', 'ACTION_NOT_PERMITTED', 'INCOMPLETE_SIGNUP', 'CUSTOMER_NOT_ENABLED', 'MISSING_TOS', 'INVALID_LOGIN_CUSTOMER_ID_SERVING_CUSTOMER_ID_COMBINATION', 'SERVICE_ACCESS_DENIED', 'ACCESS_DENIED_FOR_ACCOUNT_TYPE', 'METRIC_ACCESS_DENIED']):
            raise ValueError("must be one of enum values ('UNSPECIFIED', 'UNKNOWN', 'USER_PERMISSION_DENIED', 'PROJECT_DISABLED', 'AUTHORIZATION_ERROR', 'ACTION_NOT_PERMITTED', 'INCOMPLETE_SIGNUP', 'CUSTOMER_NOT_ENABLED', 'MISSING_TOS', 'INVALID_LOGIN_CUSTOMER_ID_SERVING_CUSTOMER_ID_COMBINATION', 'SERVICE_ACCESS_DENIED', 'ACCESS_DENIED_FOR_ACCOUNT_TYPE', 'METRIC_ACCESS_DENIED')")
        return value

    @field_validator('custom_column_error')
    def custom_column_error_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['UNSPECIFIED', 'UNKNOWN', 'CUSTOM_COLUMN_NOT_FOUND', 'CUSTOM_COLUMN_NOT_AVAILABLE']):
            raise ValueError("must be one of enum values ('UNSPECIFIED', 'UNKNOWN', 'CUSTOM_COLUMN_NOT_FOUND', 'CUSTOM_COLUMN_NOT_AVAILABLE')")
        return value

    @field_validator('date_error')
    def date_error_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['UNSPECIFIED', 'UNKNOWN', 'INVALID_FIELD_VALUES_IN_DATE', 'INVALID_FIELD_VALUES_IN_DATE_TIME', 'INVALID_STRING_DATE', 'INVALID_STRING_DATE_TIME_MICROS', 'INVALID_STRING_DATE_TIME_SECONDS', 'INVALID_STRING_DATE_TIME_SECONDS_WITH_OFFSET', 'EARLIER_THAN_MINIMUM_DATE', 'LATER_THAN_MAXIMUM_DATE', 'DATE_RANGE_MINIMUM_DATE_LATER_THAN_MAXIMUM_DATE', 'DATE_RANGE_MINIMUM_AND_MAXIMUM_DATES_BOTH_NULL']):
            raise ValueError("must be one of enum values ('UNSPECIFIED', 'UNKNOWN', 'INVALID_FIELD_VALUES_IN_DATE', 'INVALID_FIELD_VALUES_IN_DATE_TIME', 'INVALID_STRING_DATE', 'INVALID_STRING_DATE_TIME_MICROS', 'INVALID_STRING_DATE_TIME_SECONDS', 'INVALID_STRING_DATE_TIME_SECONDS_WITH_OFFSET', 'EARLIER_THAN_MINIMUM_DATE', 'LATER_THAN_MAXIMUM_DATE', 'DATE_RANGE_MINIMUM_DATE_LATER_THAN_MAXIMUM_DATE', 'DATE_RANGE_MINIMUM_AND_MAXIMUM_DATES_BOTH_NULL')")
        return value

    @field_validator('date_range_error')
    def date_range_error_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['UNSPECIFIED', 'UNKNOWN', 'INVALID_DATE', 'START_DATE_AFTER_END_DATE', 'CANNOT_SET_DATE_TO_PAST', 'AFTER_MAXIMUM_ALLOWABLE_DATE', 'CANNOT_MODIFY_START_DATE_IF_ALREADY_STARTED']):
            raise ValueError("must be one of enum values ('UNSPECIFIED', 'UNKNOWN', 'INVALID_DATE', 'START_DATE_AFTER_END_DATE', 'CANNOT_SET_DATE_TO_PAST', 'AFTER_MAXIMUM_ALLOWABLE_DATE', 'CANNOT_MODIFY_START_DATE_IF_ALREADY_STARTED')")
        return value

    @field_validator('distinct_error')
    def distinct_error_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['UNSPECIFIED', 'UNKNOWN', 'DUPLICATE_ELEMENT', 'DUPLICATE_TYPE']):
            raise ValueError("must be one of enum values ('UNSPECIFIED', 'UNKNOWN', 'DUPLICATE_ELEMENT', 'DUPLICATE_TYPE')")
        return value

    @field_validator('header_error')
    def header_error_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['UNSPECIFIED', 'UNKNOWN', 'INVALID_USER_SELECTED_CUSTOMER_ID', 'INVALID_LOGIN_CUSTOMER_ID']):
            raise ValueError("must be one of enum values ('UNSPECIFIED', 'UNKNOWN', 'INVALID_USER_SELECTED_CUSTOMER_ID', 'INVALID_LOGIN_CUSTOMER_ID')")
        return value

    @field_validator('internal_error')
    def internal_error_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['UNSPECIFIED', 'UNKNOWN', 'INTERNAL_ERROR', 'ERROR_CODE_NOT_PUBLISHED', 'TRANSIENT_ERROR', 'DEADLINE_EXCEEDED']):
            raise ValueError("must be one of enum values ('UNSPECIFIED', 'UNKNOWN', 'INTERNAL_ERROR', 'ERROR_CODE_NOT_PUBLISHED', 'TRANSIENT_ERROR', 'DEADLINE_EXCEEDED')")
        return value

    @field_validator('invalid_parameter_error')
    def invalid_parameter_error_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['UNSPECIFIED', 'UNKNOWN', 'INVALID_CURRENCY_CODE']):
            raise ValueError("must be one of enum values ('UNSPECIFIED', 'UNKNOWN', 'INVALID_CURRENCY_CODE')")
        return value

    @field_validator('query_error')
    def query_error_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['UNSPECIFIED', 'UNKNOWN', 'QUERY_ERROR', 'BAD_ENUM_CONSTANT', 'BAD_ESCAPE_SEQUENCE', 'BAD_FIELD_NAME', 'BAD_LIMIT_VALUE', 'BAD_NUMBER', 'BAD_OPERATOR', 'BAD_PARAMETER_NAME', 'BAD_PARAMETER_VALUE', 'BAD_RESOURCE_TYPE_IN_FROM_CLAUSE', 'BAD_SYMBOL', 'BAD_VALUE', 'DATE_RANGE_TOO_WIDE', 'DATE_RANGE_TOO_NARROW', 'EXPECTED_AND', 'EXPECTED_BY', 'EXPECTED_DIMENSION_FIELD_IN_SELECT_CLAUSE', 'EXPECTED_FILTERS_ON_DATE_RANGE', 'EXPECTED_FROM', 'EXPECTED_LIST', 'EXPECTED_REFERENCED_FIELD_IN_SELECT_CLAUSE', 'EXPECTED_SELECT', 'EXPECTED_SINGLE_VALUE', 'EXPECTED_VALUE_WITH_BETWEEN_OPERATOR', 'INVALID_DATE_FORMAT', 'MISALIGNED_DATE_FOR_FILTER', 'INVALID_STRING_VALUE', 'INVALID_VALUE_WITH_BETWEEN_OPERATOR', 'INVALID_VALUE_WITH_DURING_OPERATOR', 'INVALID_VALUE_WITH_LIKE_OPERATOR', 'OPERATOR_FIELD_MISMATCH', 'PROHIBITED_EMPTY_LIST_IN_CONDITION', 'PROHIBITED_ENUM_CONSTANT', 'PROHIBITED_FIELD_COMBINATION_IN_SELECT_CLAUSE', 'PROHIBITED_FIELD_IN_ORDER_BY_CLAUSE', 'PROHIBITED_FIELD_IN_SELECT_CLAUSE', 'PROHIBITED_FIELD_IN_WHERE_CLAUSE', 'PROHIBITED_RESOURCE_TYPE_IN_FROM_CLAUSE', 'PROHIBITED_RESOURCE_TYPE_IN_SELECT_CLAUSE', 'PROHIBITED_RESOURCE_TYPE_IN_WHERE_CLAUSE', 'PROHIBITED_METRIC_IN_SELECT_OR_WHERE_CLAUSE', 'PROHIBITED_SEGMENT_IN_SELECT_OR_WHERE_CLAUSE', 'PROHIBITED_SEGMENT_WITH_METRIC_IN_SELECT_OR_WHERE_CLAUSE', 'LIMIT_VALUE_TOO_LOW', 'PROHIBITED_NEWLINE_IN_STRING', 'PROHIBITED_VALUE_COMBINATION_IN_LIST', 'PROHIBITED_VALUE_COMBINATION_WITH_BETWEEN_OPERATOR', 'STRING_NOT_TERMINATED', 'TOO_MANY_SEGMENTS', 'UNEXPECTED_END_OF_QUERY', 'UNEXPECTED_FROM_CLAUSE', 'UNRECOGNIZED_FIELD', 'UNEXPECTED_INPUT', 'REQUESTED_METRICS_FOR_MANAGER', 'FILTER_HAS_TOO_MANY_VALUES']):
            raise ValueError("must be one of enum values ('UNSPECIFIED', 'UNKNOWN', 'QUERY_ERROR', 'BAD_ENUM_CONSTANT', 'BAD_ESCAPE_SEQUENCE', 'BAD_FIELD_NAME', 'BAD_LIMIT_VALUE', 'BAD_NUMBER', 'BAD_OPERATOR', 'BAD_PARAMETER_NAME', 'BAD_PARAMETER_VALUE', 'BAD_RESOURCE_TYPE_IN_FROM_CLAUSE', 'BAD_SYMBOL', 'BAD_VALUE', 'DATE_RANGE_TOO_WIDE', 'DATE_RANGE_TOO_NARROW', 'EXPECTED_AND', 'EXPECTED_BY', 'EXPECTED_DIMENSION_FIELD_IN_SELECT_CLAUSE', 'EXPECTED_FILTERS_ON_DATE_RANGE', 'EXPECTED_FROM', 'EXPECTED_LIST', 'EXPECTED_REFERENCED_FIELD_IN_SELECT_CLAUSE', 'EXPECTED_SELECT', 'EXPECTED_SINGLE_VALUE', 'EXPECTED_VALUE_WITH_BETWEEN_OPERATOR', 'INVALID_DATE_FORMAT', 'MISALIGNED_DATE_FOR_FILTER', 'INVALID_STRING_VALUE', 'INVALID_VALUE_WITH_BETWEEN_OPERATOR', 'INVALID_VALUE_WITH_DURING_OPERATOR', 'INVALID_VALUE_WITH_LIKE_OPERATOR', 'OPERATOR_FIELD_MISMATCH', 'PROHIBITED_EMPTY_LIST_IN_CONDITION', 'PROHIBITED_ENUM_CONSTANT', 'PROHIBITED_FIELD_COMBINATION_IN_SELECT_CLAUSE', 'PROHIBITED_FIELD_IN_ORDER_BY_CLAUSE', 'PROHIBITED_FIELD_IN_SELECT_CLAUSE', 'PROHIBITED_FIELD_IN_WHERE_CLAUSE', 'PROHIBITED_RESOURCE_TYPE_IN_FROM_CLAUSE', 'PROHIBITED_RESOURCE_TYPE_IN_SELECT_CLAUSE', 'PROHIBITED_RESOURCE_TYPE_IN_WHERE_CLAUSE', 'PROHIBITED_METRIC_IN_SELECT_OR_WHERE_CLAUSE', 'PROHIBITED_SEGMENT_IN_SELECT_OR_WHERE_CLAUSE', 'PROHIBITED_SEGMENT_WITH_METRIC_IN_SELECT_OR_WHERE_CLAUSE', 'LIMIT_VALUE_TOO_LOW', 'PROHIBITED_NEWLINE_IN_STRING', 'PROHIBITED_VALUE_COMBINATION_IN_LIST', 'PROHIBITED_VALUE_COMBINATION_WITH_BETWEEN_OPERATOR', 'STRING_NOT_TERMINATED', 'TOO_MANY_SEGMENTS', 'UNEXPECTED_END_OF_QUERY', 'UNEXPECTED_FROM_CLAUSE', 'UNRECOGNIZED_FIELD', 'UNEXPECTED_INPUT', 'REQUESTED_METRICS_FOR_MANAGER', 'FILTER_HAS_TOO_MANY_VALUES')")
        return value

    @field_validator('quota_error')
    def quota_error_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['UNSPECIFIED', 'UNKNOWN', 'RESOURCE_EXHAUSTED', 'RESOURCE_TEMPORARILY_EXHAUSTED']):
            raise ValueError("must be one of enum values ('UNSPECIFIED', 'UNKNOWN', 'RESOURCE_EXHAUSTED', 'RESOURCE_TEMPORARILY_EXHAUSTED')")
        return value

    @field_validator('request_error')
    def request_error_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['UNSPECIFIED', 'UNKNOWN', 'RESOURCE_NAME_MISSING', 'RESOURCE_NAME_MALFORMED', 'BAD_RESOURCE_ID', 'INVALID_PRODUCT_NAME', 'INVALID_CUSTOMER_ID', 'OPERATION_REQUIRED', 'RESOURCE_NOT_FOUND', 'INVALID_PAGE_TOKEN', 'EXPIRED_PAGE_TOKEN', 'INVALID_PAGE_SIZE', 'REQUIRED_FIELD_MISSING', 'IMMUTABLE_FIELD', 'TOO_MANY_MUTATE_OPERATIONS', 'CANNOT_BE_EXECUTED_BY_MANAGER_ACCOUNT', 'CANNOT_MODIFY_FOREIGN_FIELD', 'INVALID_ENUM_VALUE', 'LOGIN_CUSTOMER_ID_PARAMETER_MISSING', 'LOGIN_OR_LINKED_CUSTOMER_ID_PARAMETER_REQUIRED', 'VALIDATE_ONLY_REQUEST_HAS_PAGE_TOKEN', 'CANNOT_RETURN_SUMMARY_ROW_FOR_REQUEST_WITHOUT_METRICS', 'CANNOT_RETURN_SUMMARY_ROW_FOR_VALIDATE_ONLY_REQUESTS', 'INCONSISTENT_RETURN_SUMMARY_ROW_VALUE', 'TOTAL_RESULTS_COUNT_NOT_ORIGINALLY_REQUESTED', 'RPC_DEADLINE_TOO_SHORT', 'PRODUCT_NOT_SUPPORTED']):
            raise ValueError("must be one of enum values ('UNSPECIFIED', 'UNKNOWN', 'RESOURCE_NAME_MISSING', 'RESOURCE_NAME_MALFORMED', 'BAD_RESOURCE_ID', 'INVALID_PRODUCT_NAME', 'INVALID_CUSTOMER_ID', 'OPERATION_REQUIRED', 'RESOURCE_NOT_FOUND', 'INVALID_PAGE_TOKEN', 'EXPIRED_PAGE_TOKEN', 'INVALID_PAGE_SIZE', 'REQUIRED_FIELD_MISSING', 'IMMUTABLE_FIELD', 'TOO_MANY_MUTATE_OPERATIONS', 'CANNOT_BE_EXECUTED_BY_MANAGER_ACCOUNT', 'CANNOT_MODIFY_FOREIGN_FIELD', 'INVALID_ENUM_VALUE', 'LOGIN_CUSTOMER_ID_PARAMETER_MISSING', 'LOGIN_OR_LINKED_CUSTOMER_ID_PARAMETER_REQUIRED', 'VALIDATE_ONLY_REQUEST_HAS_PAGE_TOKEN', 'CANNOT_RETURN_SUMMARY_ROW_FOR_REQUEST_WITHOUT_METRICS', 'CANNOT_RETURN_SUMMARY_ROW_FOR_VALIDATE_ONLY_REQUESTS', 'INCONSISTENT_RETURN_SUMMARY_ROW_VALUE', 'TOTAL_RESULTS_COUNT_NOT_ORIGINALLY_REQUESTED', 'RPC_DEADLINE_TOO_SHORT', 'PRODUCT_NOT_SUPPORTED')")
        return value

    @field_validator('size_limit_error')
    def size_limit_error_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['UNSPECIFIED', 'UNKNOWN', 'REQUEST_SIZE_LIMIT_EXCEEDED', 'RESPONSE_SIZE_LIMIT_EXCEEDED']):
            raise ValueError("must be one of enum values ('UNSPECIFIED', 'UNKNOWN', 'REQUEST_SIZE_LIMIT_EXCEEDED', 'RESPONSE_SIZE_LIMIT_EXCEEDED')")
        return value

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of GoogleAdsSearchads360V0ErrorsErrorCode from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of GoogleAdsSearchads360V0ErrorsErrorCode from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "authenticationError": obj.get("authenticationError"),
            "authorizationError": obj.get("authorizationError"),
            "customColumnError": obj.get("customColumnError"),
            "dateError": obj.get("dateError"),
            "dateRangeError": obj.get("dateRangeError"),
            "distinctError": obj.get("distinctError"),
            "headerError": obj.get("headerError"),
            "internalError": obj.get("internalError"),
            "invalidParameterError": obj.get("invalidParameterError"),
            "queryError": obj.get("queryError"),
            "quotaError": obj.get("quotaError"),
            "requestError": obj.get("requestError"),
            "sizeLimitError": obj.get("sizeLimitError")
        })
        return _obj


