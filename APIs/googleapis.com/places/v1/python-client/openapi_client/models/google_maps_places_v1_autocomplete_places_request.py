# coding: utf-8

"""
    Places API (New)

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

    The version of the OpenAPI document: v1
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictInt, StrictStr
from typing import Any, ClassVar, Dict, List, Optional
from openapi_client.models.google_maps_places_v1_autocomplete_places_request_location_bias import GoogleMapsPlacesV1AutocompletePlacesRequestLocationBias
from openapi_client.models.google_maps_places_v1_autocomplete_places_request_location_restriction import GoogleMapsPlacesV1AutocompletePlacesRequestLocationRestriction
from openapi_client.models.google_type_lat_lng import GoogleTypeLatLng
from typing import Optional, Set
from typing_extensions import Self

class GoogleMapsPlacesV1AutocompletePlacesRequest(BaseModel):
    """
    Request proto for AutocompletePlaces.
    """ # noqa: E501
    include_query_predictions: Optional[StrictBool] = Field(default=None, description="Optional. If true, the response will include both Place and query predictions. Otherwise the response will only return Place predictions.", alias="includeQueryPredictions")
    included_primary_types: Optional[List[StrictStr]] = Field(default=None, description="Optional. Included primary Place type (for example, \"restaurant\" or \"gas_station\") from https://developers.google.com/maps/documentation/places/web-service/place-types. A Place is only returned if its primary type is included in this list. Up to 5 values can be specified. If no types are specified, all Place types are returned.", alias="includedPrimaryTypes")
    included_region_codes: Optional[List[StrictStr]] = Field(default=None, description="Optional. Only include results in the specified regions, specified as up to 15 CLDR two-character region codes. An empty set will not restrict the results. If both `location_restriction` and `included_region_codes` are set, the results will be located in the area of intersection.", alias="includedRegionCodes")
    input: Optional[StrictStr] = Field(default=None, description="Required. The text string on which to search.")
    input_offset: Optional[StrictInt] = Field(default=None, description="Optional. A zero-based Unicode character offset of `input` indicating the cursor position in `input`. The cursor position may influence what predictions are returned. If empty, defaults to the length of `input`.", alias="inputOffset")
    language_code: Optional[StrictStr] = Field(default=None, description="Optional. The language in which to return results. Defaults to en-US. The results may be in mixed languages if the language used in `input` is different from `language_code` or if the returned Place does not have a translation from the local language to `language_code`.", alias="languageCode")
    location_bias: Optional[GoogleMapsPlacesV1AutocompletePlacesRequestLocationBias] = Field(default=None, alias="locationBias")
    location_restriction: Optional[GoogleMapsPlacesV1AutocompletePlacesRequestLocationRestriction] = Field(default=None, alias="locationRestriction")
    origin: Optional[GoogleTypeLatLng] = None
    region_code: Optional[StrictStr] = Field(default=None, description="Optional. The region code, specified as a CLDR two-character region code. This affects address formatting, result ranking, and may influence what results are returned. This does not restrict results to the specified region. To restrict results to a region, use `region_code_restriction`.", alias="regionCode")
    session_token: Optional[StrictStr] = Field(default=None, description="Optional. A string which identifies an Autocomplete session for billing purposes. Must be a URL and filename safe base64 string with at most 36 ASCII characters in length. Otherwise an INVALID_ARGUMENT error is returned. The session begins when the user starts typing a query, and concludes when they select a place and a call to Place Details or Address Validation is made. Each session can have multiple queries, followed by one Place Details or Address Validation request. The credentials used for each request within a session must belong to the same Google Cloud Console project. Once a session has concluded, the token is no longer valid; your app must generate a fresh token for each session. If the `session_token` parameter is omitted, or if you reuse a session token, the session is charged as if no session token was provided (each request is billed separately). We recommend the following guidelines: * Use session tokens for all Place Autocomplete calls. * Generate a fresh token for each session. Using a version 4 UUID is recommended. * Ensure that the credentials used for all Place Autocomplete, Place Details, and Address Validation requests within a session belong to the same Cloud Console project. * Be sure to pass a unique session token for each new session. Using the same token for more than one session will result in each request being billed individually.", alias="sessionToken")
    __properties: ClassVar[List[str]] = ["includeQueryPredictions", "includedPrimaryTypes", "includedRegionCodes", "input", "inputOffset", "languageCode", "locationBias", "locationRestriction", "origin", "regionCode", "sessionToken"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of GoogleMapsPlacesV1AutocompletePlacesRequest from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of location_bias
        if self.location_bias:
            _dict['locationBias'] = self.location_bias.to_dict()
        # override the default output from pydantic by calling `to_dict()` of location_restriction
        if self.location_restriction:
            _dict['locationRestriction'] = self.location_restriction.to_dict()
        # override the default output from pydantic by calling `to_dict()` of origin
        if self.origin:
            _dict['origin'] = self.origin.to_dict()
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of GoogleMapsPlacesV1AutocompletePlacesRequest from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "includeQueryPredictions": obj.get("includeQueryPredictions"),
            "includedPrimaryTypes": obj.get("includedPrimaryTypes"),
            "includedRegionCodes": obj.get("includedRegionCodes"),
            "input": obj.get("input"),
            "inputOffset": obj.get("inputOffset"),
            "languageCode": obj.get("languageCode"),
            "locationBias": GoogleMapsPlacesV1AutocompletePlacesRequestLocationBias.from_dict(obj["locationBias"]) if obj.get("locationBias") is not None else None,
            "locationRestriction": GoogleMapsPlacesV1AutocompletePlacesRequestLocationRestriction.from_dict(obj["locationRestriction"]) if obj.get("locationRestriction") is not None else None,
            "origin": GoogleTypeLatLng.from_dict(obj["origin"]) if obj.get("origin") is not None else None,
            "regionCode": obj.get("regionCode"),
            "sessionToken": obj.get("sessionToken")
        })
        return _obj


