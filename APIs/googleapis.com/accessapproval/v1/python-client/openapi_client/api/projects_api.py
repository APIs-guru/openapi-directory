# coding: utf-8

"""
    Access Approval API

    An API for controlling access to data by Google personnel.

    The version of the OpenAPI document: v1
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501

import warnings
from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
from typing import Any, Dict, List, Optional, Tuple, Union
from typing_extensions import Annotated

from pydantic import Field, StrictBool, StrictInt, StrictStr, field_validator
from typing import Any, Dict, Optional
from typing_extensions import Annotated
from openapi_client.models.access_approval_settings import AccessApprovalSettings
from openapi_client.models.approval_request import ApprovalRequest
from openapi_client.models.approve_approval_request_message import ApproveApprovalRequestMessage
from openapi_client.models.list_approval_requests_response import ListApprovalRequestsResponse

from openapi_client.api_client import ApiClient, RequestSerialized
from openapi_client.api_response import ApiResponse
from openapi_client.rest import RESTResponseType


class ProjectsApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client


    @validate_call
    def accessapproval_projects_approval_requests_approve(
        self,
        name: Annotated[StrictStr, Field(description="Name of the approval request to approve.")],
        xgafv: Annotated[Optional[StrictStr], Field(description="V1 error format.")] = None,
        access_token: Annotated[Optional[StrictStr], Field(description="OAuth access token.")] = None,
        alt: Annotated[Optional[StrictStr], Field(description="Data format for response.")] = None,
        param_callback: Annotated[Optional[StrictStr], Field(description="JSONP")] = None,
        fields: Annotated[Optional[StrictStr], Field(description="Selector specifying which fields to include in a partial response.")] = None,
        key: Annotated[Optional[StrictStr], Field(description="API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.")] = None,
        oauth_token: Annotated[Optional[StrictStr], Field(description="OAuth 2.0 token for the current user.")] = None,
        pretty_print: Annotated[Optional[StrictBool], Field(description="Returns response with indentations and line breaks.")] = None,
        quota_user: Annotated[Optional[StrictStr], Field(description="Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.")] = None,
        upload_protocol: Annotated[Optional[StrictStr], Field(description="Upload protocol for media (e.g. \"raw\", \"multipart\").")] = None,
        upload_type: Annotated[Optional[StrictStr], Field(description="Legacy upload protocol for media (e.g. \"media\", \"multipart\").")] = None,
        approve_approval_request_message: Optional[ApproveApprovalRequestMessage] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApprovalRequest:
        """accessapproval_projects_approval_requests_approve

        Approves a request and returns the updated ApprovalRequest. Returns NOT_FOUND if the request does not exist. Returns FAILED_PRECONDITION if the request exists but is not in a pending state.

        :param name: Name of the approval request to approve. (required)
        :type name: str
        :param xgafv: V1 error format.
        :type xgafv: str
        :param access_token: OAuth access token.
        :type access_token: str
        :param alt: Data format for response.
        :type alt: str
        :param param_callback: JSONP
        :type param_callback: str
        :param fields: Selector specifying which fields to include in a partial response.
        :type fields: str
        :param key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :type key: str
        :param oauth_token: OAuth 2.0 token for the current user.
        :type oauth_token: str
        :param pretty_print: Returns response with indentations and line breaks.
        :type pretty_print: bool
        :param quota_user: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
        :type quota_user: str
        :param upload_protocol: Upload protocol for media (e.g. \"raw\", \"multipart\").
        :type upload_protocol: str
        :param upload_type: Legacy upload protocol for media (e.g. \"media\", \"multipart\").
        :type upload_type: str
        :param approve_approval_request_message:
        :type approve_approval_request_message: ApproveApprovalRequestMessage
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._accessapproval_projects_approval_requests_approve_serialize(
            name=name,
            xgafv=xgafv,
            access_token=access_token,
            alt=alt,
            param_callback=param_callback,
            fields=fields,
            key=key,
            oauth_token=oauth_token,
            pretty_print=pretty_print,
            quota_user=quota_user,
            upload_protocol=upload_protocol,
            upload_type=upload_type,
            approve_approval_request_message=approve_approval_request_message,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ApprovalRequest",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def accessapproval_projects_approval_requests_approve_with_http_info(
        self,
        name: Annotated[StrictStr, Field(description="Name of the approval request to approve.")],
        xgafv: Annotated[Optional[StrictStr], Field(description="V1 error format.")] = None,
        access_token: Annotated[Optional[StrictStr], Field(description="OAuth access token.")] = None,
        alt: Annotated[Optional[StrictStr], Field(description="Data format for response.")] = None,
        param_callback: Annotated[Optional[StrictStr], Field(description="JSONP")] = None,
        fields: Annotated[Optional[StrictStr], Field(description="Selector specifying which fields to include in a partial response.")] = None,
        key: Annotated[Optional[StrictStr], Field(description="API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.")] = None,
        oauth_token: Annotated[Optional[StrictStr], Field(description="OAuth 2.0 token for the current user.")] = None,
        pretty_print: Annotated[Optional[StrictBool], Field(description="Returns response with indentations and line breaks.")] = None,
        quota_user: Annotated[Optional[StrictStr], Field(description="Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.")] = None,
        upload_protocol: Annotated[Optional[StrictStr], Field(description="Upload protocol for media (e.g. \"raw\", \"multipart\").")] = None,
        upload_type: Annotated[Optional[StrictStr], Field(description="Legacy upload protocol for media (e.g. \"media\", \"multipart\").")] = None,
        approve_approval_request_message: Optional[ApproveApprovalRequestMessage] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[ApprovalRequest]:
        """accessapproval_projects_approval_requests_approve

        Approves a request and returns the updated ApprovalRequest. Returns NOT_FOUND if the request does not exist. Returns FAILED_PRECONDITION if the request exists but is not in a pending state.

        :param name: Name of the approval request to approve. (required)
        :type name: str
        :param xgafv: V1 error format.
        :type xgafv: str
        :param access_token: OAuth access token.
        :type access_token: str
        :param alt: Data format for response.
        :type alt: str
        :param param_callback: JSONP
        :type param_callback: str
        :param fields: Selector specifying which fields to include in a partial response.
        :type fields: str
        :param key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :type key: str
        :param oauth_token: OAuth 2.0 token for the current user.
        :type oauth_token: str
        :param pretty_print: Returns response with indentations and line breaks.
        :type pretty_print: bool
        :param quota_user: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
        :type quota_user: str
        :param upload_protocol: Upload protocol for media (e.g. \"raw\", \"multipart\").
        :type upload_protocol: str
        :param upload_type: Legacy upload protocol for media (e.g. \"media\", \"multipart\").
        :type upload_type: str
        :param approve_approval_request_message:
        :type approve_approval_request_message: ApproveApprovalRequestMessage
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._accessapproval_projects_approval_requests_approve_serialize(
            name=name,
            xgafv=xgafv,
            access_token=access_token,
            alt=alt,
            param_callback=param_callback,
            fields=fields,
            key=key,
            oauth_token=oauth_token,
            pretty_print=pretty_print,
            quota_user=quota_user,
            upload_protocol=upload_protocol,
            upload_type=upload_type,
            approve_approval_request_message=approve_approval_request_message,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ApprovalRequest",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def accessapproval_projects_approval_requests_approve_without_preload_content(
        self,
        name: Annotated[StrictStr, Field(description="Name of the approval request to approve.")],
        xgafv: Annotated[Optional[StrictStr], Field(description="V1 error format.")] = None,
        access_token: Annotated[Optional[StrictStr], Field(description="OAuth access token.")] = None,
        alt: Annotated[Optional[StrictStr], Field(description="Data format for response.")] = None,
        param_callback: Annotated[Optional[StrictStr], Field(description="JSONP")] = None,
        fields: Annotated[Optional[StrictStr], Field(description="Selector specifying which fields to include in a partial response.")] = None,
        key: Annotated[Optional[StrictStr], Field(description="API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.")] = None,
        oauth_token: Annotated[Optional[StrictStr], Field(description="OAuth 2.0 token for the current user.")] = None,
        pretty_print: Annotated[Optional[StrictBool], Field(description="Returns response with indentations and line breaks.")] = None,
        quota_user: Annotated[Optional[StrictStr], Field(description="Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.")] = None,
        upload_protocol: Annotated[Optional[StrictStr], Field(description="Upload protocol for media (e.g. \"raw\", \"multipart\").")] = None,
        upload_type: Annotated[Optional[StrictStr], Field(description="Legacy upload protocol for media (e.g. \"media\", \"multipart\").")] = None,
        approve_approval_request_message: Optional[ApproveApprovalRequestMessage] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """accessapproval_projects_approval_requests_approve

        Approves a request and returns the updated ApprovalRequest. Returns NOT_FOUND if the request does not exist. Returns FAILED_PRECONDITION if the request exists but is not in a pending state.

        :param name: Name of the approval request to approve. (required)
        :type name: str
        :param xgafv: V1 error format.
        :type xgafv: str
        :param access_token: OAuth access token.
        :type access_token: str
        :param alt: Data format for response.
        :type alt: str
        :param param_callback: JSONP
        :type param_callback: str
        :param fields: Selector specifying which fields to include in a partial response.
        :type fields: str
        :param key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :type key: str
        :param oauth_token: OAuth 2.0 token for the current user.
        :type oauth_token: str
        :param pretty_print: Returns response with indentations and line breaks.
        :type pretty_print: bool
        :param quota_user: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
        :type quota_user: str
        :param upload_protocol: Upload protocol for media (e.g. \"raw\", \"multipart\").
        :type upload_protocol: str
        :param upload_type: Legacy upload protocol for media (e.g. \"media\", \"multipart\").
        :type upload_type: str
        :param approve_approval_request_message:
        :type approve_approval_request_message: ApproveApprovalRequestMessage
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._accessapproval_projects_approval_requests_approve_serialize(
            name=name,
            xgafv=xgafv,
            access_token=access_token,
            alt=alt,
            param_callback=param_callback,
            fields=fields,
            key=key,
            oauth_token=oauth_token,
            pretty_print=pretty_print,
            quota_user=quota_user,
            upload_protocol=upload_protocol,
            upload_type=upload_type,
            approve_approval_request_message=approve_approval_request_message,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ApprovalRequest",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _accessapproval_projects_approval_requests_approve_serialize(
        self,
        name,
        xgafv,
        access_token,
        alt,
        param_callback,
        fields,
        key,
        oauth_token,
        pretty_print,
        quota_user,
        upload_protocol,
        upload_type,
        approve_approval_request_message,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if name is not None:
            _path_params['name'] = name
        # process the query parameters
        if xgafv is not None:
            
            _query_params.append(('$.xgafv', xgafv))
            
        if access_token is not None:
            
            _query_params.append(('access_token', access_token))
            
        if alt is not None:
            
            _query_params.append(('alt', alt))
            
        if param_callback is not None:
            
            _query_params.append(('callback', param_callback))
            
        if fields is not None:
            
            _query_params.append(('fields', fields))
            
        if key is not None:
            
            _query_params.append(('key', key))
            
        if oauth_token is not None:
            
            _query_params.append(('oauth_token', oauth_token))
            
        if pretty_print is not None:
            
            _query_params.append(('prettyPrint', pretty_print))
            
        if quota_user is not None:
            
            _query_params.append(('quotaUser', quota_user))
            
        if upload_protocol is not None:
            
            _query_params.append(('upload_protocol', upload_protocol))
            
        if upload_type is not None:
            
            _query_params.append(('uploadType', upload_type))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if approve_approval_request_message is not None:
            _body_params = approve_approval_request_message


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'Oauth2c', 
            'Oauth2'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/v1/{name}:approve',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def accessapproval_projects_approval_requests_dismiss(
        self,
        name: Annotated[StrictStr, Field(description="Name of the ApprovalRequest to dismiss.")],
        xgafv: Annotated[Optional[StrictStr], Field(description="V1 error format.")] = None,
        access_token: Annotated[Optional[StrictStr], Field(description="OAuth access token.")] = None,
        alt: Annotated[Optional[StrictStr], Field(description="Data format for response.")] = None,
        param_callback: Annotated[Optional[StrictStr], Field(description="JSONP")] = None,
        fields: Annotated[Optional[StrictStr], Field(description="Selector specifying which fields to include in a partial response.")] = None,
        key: Annotated[Optional[StrictStr], Field(description="API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.")] = None,
        oauth_token: Annotated[Optional[StrictStr], Field(description="OAuth 2.0 token for the current user.")] = None,
        pretty_print: Annotated[Optional[StrictBool], Field(description="Returns response with indentations and line breaks.")] = None,
        quota_user: Annotated[Optional[StrictStr], Field(description="Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.")] = None,
        upload_protocol: Annotated[Optional[StrictStr], Field(description="Upload protocol for media (e.g. \"raw\", \"multipart\").")] = None,
        upload_type: Annotated[Optional[StrictStr], Field(description="Legacy upload protocol for media (e.g. \"media\", \"multipart\").")] = None,
        body: Optional[Dict[str, Any]] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApprovalRequest:
        """accessapproval_projects_approval_requests_dismiss

        Dismisses a request. Returns the updated ApprovalRequest. NOTE: This does not deny access to the resource if another request has been made and approved. It is equivalent in effect to ignoring the request altogether. Returns NOT_FOUND if the request does not exist. Returns FAILED_PRECONDITION if the request exists but is not in a pending state.

        :param name: Name of the ApprovalRequest to dismiss. (required)
        :type name: str
        :param xgafv: V1 error format.
        :type xgafv: str
        :param access_token: OAuth access token.
        :type access_token: str
        :param alt: Data format for response.
        :type alt: str
        :param param_callback: JSONP
        :type param_callback: str
        :param fields: Selector specifying which fields to include in a partial response.
        :type fields: str
        :param key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :type key: str
        :param oauth_token: OAuth 2.0 token for the current user.
        :type oauth_token: str
        :param pretty_print: Returns response with indentations and line breaks.
        :type pretty_print: bool
        :param quota_user: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
        :type quota_user: str
        :param upload_protocol: Upload protocol for media (e.g. \"raw\", \"multipart\").
        :type upload_protocol: str
        :param upload_type: Legacy upload protocol for media (e.g. \"media\", \"multipart\").
        :type upload_type: str
        :param body:
        :type body: object
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._accessapproval_projects_approval_requests_dismiss_serialize(
            name=name,
            xgafv=xgafv,
            access_token=access_token,
            alt=alt,
            param_callback=param_callback,
            fields=fields,
            key=key,
            oauth_token=oauth_token,
            pretty_print=pretty_print,
            quota_user=quota_user,
            upload_protocol=upload_protocol,
            upload_type=upload_type,
            body=body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ApprovalRequest",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def accessapproval_projects_approval_requests_dismiss_with_http_info(
        self,
        name: Annotated[StrictStr, Field(description="Name of the ApprovalRequest to dismiss.")],
        xgafv: Annotated[Optional[StrictStr], Field(description="V1 error format.")] = None,
        access_token: Annotated[Optional[StrictStr], Field(description="OAuth access token.")] = None,
        alt: Annotated[Optional[StrictStr], Field(description="Data format for response.")] = None,
        param_callback: Annotated[Optional[StrictStr], Field(description="JSONP")] = None,
        fields: Annotated[Optional[StrictStr], Field(description="Selector specifying which fields to include in a partial response.")] = None,
        key: Annotated[Optional[StrictStr], Field(description="API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.")] = None,
        oauth_token: Annotated[Optional[StrictStr], Field(description="OAuth 2.0 token for the current user.")] = None,
        pretty_print: Annotated[Optional[StrictBool], Field(description="Returns response with indentations and line breaks.")] = None,
        quota_user: Annotated[Optional[StrictStr], Field(description="Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.")] = None,
        upload_protocol: Annotated[Optional[StrictStr], Field(description="Upload protocol for media (e.g. \"raw\", \"multipart\").")] = None,
        upload_type: Annotated[Optional[StrictStr], Field(description="Legacy upload protocol for media (e.g. \"media\", \"multipart\").")] = None,
        body: Optional[Dict[str, Any]] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[ApprovalRequest]:
        """accessapproval_projects_approval_requests_dismiss

        Dismisses a request. Returns the updated ApprovalRequest. NOTE: This does not deny access to the resource if another request has been made and approved. It is equivalent in effect to ignoring the request altogether. Returns NOT_FOUND if the request does not exist. Returns FAILED_PRECONDITION if the request exists but is not in a pending state.

        :param name: Name of the ApprovalRequest to dismiss. (required)
        :type name: str
        :param xgafv: V1 error format.
        :type xgafv: str
        :param access_token: OAuth access token.
        :type access_token: str
        :param alt: Data format for response.
        :type alt: str
        :param param_callback: JSONP
        :type param_callback: str
        :param fields: Selector specifying which fields to include in a partial response.
        :type fields: str
        :param key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :type key: str
        :param oauth_token: OAuth 2.0 token for the current user.
        :type oauth_token: str
        :param pretty_print: Returns response with indentations and line breaks.
        :type pretty_print: bool
        :param quota_user: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
        :type quota_user: str
        :param upload_protocol: Upload protocol for media (e.g. \"raw\", \"multipart\").
        :type upload_protocol: str
        :param upload_type: Legacy upload protocol for media (e.g. \"media\", \"multipart\").
        :type upload_type: str
        :param body:
        :type body: object
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._accessapproval_projects_approval_requests_dismiss_serialize(
            name=name,
            xgafv=xgafv,
            access_token=access_token,
            alt=alt,
            param_callback=param_callback,
            fields=fields,
            key=key,
            oauth_token=oauth_token,
            pretty_print=pretty_print,
            quota_user=quota_user,
            upload_protocol=upload_protocol,
            upload_type=upload_type,
            body=body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ApprovalRequest",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def accessapproval_projects_approval_requests_dismiss_without_preload_content(
        self,
        name: Annotated[StrictStr, Field(description="Name of the ApprovalRequest to dismiss.")],
        xgafv: Annotated[Optional[StrictStr], Field(description="V1 error format.")] = None,
        access_token: Annotated[Optional[StrictStr], Field(description="OAuth access token.")] = None,
        alt: Annotated[Optional[StrictStr], Field(description="Data format for response.")] = None,
        param_callback: Annotated[Optional[StrictStr], Field(description="JSONP")] = None,
        fields: Annotated[Optional[StrictStr], Field(description="Selector specifying which fields to include in a partial response.")] = None,
        key: Annotated[Optional[StrictStr], Field(description="API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.")] = None,
        oauth_token: Annotated[Optional[StrictStr], Field(description="OAuth 2.0 token for the current user.")] = None,
        pretty_print: Annotated[Optional[StrictBool], Field(description="Returns response with indentations and line breaks.")] = None,
        quota_user: Annotated[Optional[StrictStr], Field(description="Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.")] = None,
        upload_protocol: Annotated[Optional[StrictStr], Field(description="Upload protocol for media (e.g. \"raw\", \"multipart\").")] = None,
        upload_type: Annotated[Optional[StrictStr], Field(description="Legacy upload protocol for media (e.g. \"media\", \"multipart\").")] = None,
        body: Optional[Dict[str, Any]] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """accessapproval_projects_approval_requests_dismiss

        Dismisses a request. Returns the updated ApprovalRequest. NOTE: This does not deny access to the resource if another request has been made and approved. It is equivalent in effect to ignoring the request altogether. Returns NOT_FOUND if the request does not exist. Returns FAILED_PRECONDITION if the request exists but is not in a pending state.

        :param name: Name of the ApprovalRequest to dismiss. (required)
        :type name: str
        :param xgafv: V1 error format.
        :type xgafv: str
        :param access_token: OAuth access token.
        :type access_token: str
        :param alt: Data format for response.
        :type alt: str
        :param param_callback: JSONP
        :type param_callback: str
        :param fields: Selector specifying which fields to include in a partial response.
        :type fields: str
        :param key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :type key: str
        :param oauth_token: OAuth 2.0 token for the current user.
        :type oauth_token: str
        :param pretty_print: Returns response with indentations and line breaks.
        :type pretty_print: bool
        :param quota_user: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
        :type quota_user: str
        :param upload_protocol: Upload protocol for media (e.g. \"raw\", \"multipart\").
        :type upload_protocol: str
        :param upload_type: Legacy upload protocol for media (e.g. \"media\", \"multipart\").
        :type upload_type: str
        :param body:
        :type body: object
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._accessapproval_projects_approval_requests_dismiss_serialize(
            name=name,
            xgafv=xgafv,
            access_token=access_token,
            alt=alt,
            param_callback=param_callback,
            fields=fields,
            key=key,
            oauth_token=oauth_token,
            pretty_print=pretty_print,
            quota_user=quota_user,
            upload_protocol=upload_protocol,
            upload_type=upload_type,
            body=body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ApprovalRequest",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _accessapproval_projects_approval_requests_dismiss_serialize(
        self,
        name,
        xgafv,
        access_token,
        alt,
        param_callback,
        fields,
        key,
        oauth_token,
        pretty_print,
        quota_user,
        upload_protocol,
        upload_type,
        body,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if name is not None:
            _path_params['name'] = name
        # process the query parameters
        if xgafv is not None:
            
            _query_params.append(('$.xgafv', xgafv))
            
        if access_token is not None:
            
            _query_params.append(('access_token', access_token))
            
        if alt is not None:
            
            _query_params.append(('alt', alt))
            
        if param_callback is not None:
            
            _query_params.append(('callback', param_callback))
            
        if fields is not None:
            
            _query_params.append(('fields', fields))
            
        if key is not None:
            
            _query_params.append(('key', key))
            
        if oauth_token is not None:
            
            _query_params.append(('oauth_token', oauth_token))
            
        if pretty_print is not None:
            
            _query_params.append(('prettyPrint', pretty_print))
            
        if quota_user is not None:
            
            _query_params.append(('quotaUser', quota_user))
            
        if upload_protocol is not None:
            
            _query_params.append(('upload_protocol', upload_protocol))
            
        if upload_type is not None:
            
            _query_params.append(('uploadType', upload_type))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if body is not None:
            _body_params = body


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'Oauth2c', 
            'Oauth2'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/v1/{name}:dismiss',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def accessapproval_projects_approval_requests_get(
        self,
        name: Annotated[StrictStr, Field(description="The name of the approval request to retrieve. Format: \"{projects|folders|organizations}/{id}/approvalRequests/{approval_request}\"")],
        xgafv: Annotated[Optional[StrictStr], Field(description="V1 error format.")] = None,
        access_token: Annotated[Optional[StrictStr], Field(description="OAuth access token.")] = None,
        alt: Annotated[Optional[StrictStr], Field(description="Data format for response.")] = None,
        param_callback: Annotated[Optional[StrictStr], Field(description="JSONP")] = None,
        fields: Annotated[Optional[StrictStr], Field(description="Selector specifying which fields to include in a partial response.")] = None,
        key: Annotated[Optional[StrictStr], Field(description="API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.")] = None,
        oauth_token: Annotated[Optional[StrictStr], Field(description="OAuth 2.0 token for the current user.")] = None,
        pretty_print: Annotated[Optional[StrictBool], Field(description="Returns response with indentations and line breaks.")] = None,
        quota_user: Annotated[Optional[StrictStr], Field(description="Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.")] = None,
        upload_protocol: Annotated[Optional[StrictStr], Field(description="Upload protocol for media (e.g. \"raw\", \"multipart\").")] = None,
        upload_type: Annotated[Optional[StrictStr], Field(description="Legacy upload protocol for media (e.g. \"media\", \"multipart\").")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApprovalRequest:
        """accessapproval_projects_approval_requests_get

        Gets an approval request. Returns NOT_FOUND if the request does not exist.

        :param name: The name of the approval request to retrieve. Format: \"{projects|folders|organizations}/{id}/approvalRequests/{approval_request}\" (required)
        :type name: str
        :param xgafv: V1 error format.
        :type xgafv: str
        :param access_token: OAuth access token.
        :type access_token: str
        :param alt: Data format for response.
        :type alt: str
        :param param_callback: JSONP
        :type param_callback: str
        :param fields: Selector specifying which fields to include in a partial response.
        :type fields: str
        :param key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :type key: str
        :param oauth_token: OAuth 2.0 token for the current user.
        :type oauth_token: str
        :param pretty_print: Returns response with indentations and line breaks.
        :type pretty_print: bool
        :param quota_user: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
        :type quota_user: str
        :param upload_protocol: Upload protocol for media (e.g. \"raw\", \"multipart\").
        :type upload_protocol: str
        :param upload_type: Legacy upload protocol for media (e.g. \"media\", \"multipart\").
        :type upload_type: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._accessapproval_projects_approval_requests_get_serialize(
            name=name,
            xgafv=xgafv,
            access_token=access_token,
            alt=alt,
            param_callback=param_callback,
            fields=fields,
            key=key,
            oauth_token=oauth_token,
            pretty_print=pretty_print,
            quota_user=quota_user,
            upload_protocol=upload_protocol,
            upload_type=upload_type,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ApprovalRequest",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def accessapproval_projects_approval_requests_get_with_http_info(
        self,
        name: Annotated[StrictStr, Field(description="The name of the approval request to retrieve. Format: \"{projects|folders|organizations}/{id}/approvalRequests/{approval_request}\"")],
        xgafv: Annotated[Optional[StrictStr], Field(description="V1 error format.")] = None,
        access_token: Annotated[Optional[StrictStr], Field(description="OAuth access token.")] = None,
        alt: Annotated[Optional[StrictStr], Field(description="Data format for response.")] = None,
        param_callback: Annotated[Optional[StrictStr], Field(description="JSONP")] = None,
        fields: Annotated[Optional[StrictStr], Field(description="Selector specifying which fields to include in a partial response.")] = None,
        key: Annotated[Optional[StrictStr], Field(description="API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.")] = None,
        oauth_token: Annotated[Optional[StrictStr], Field(description="OAuth 2.0 token for the current user.")] = None,
        pretty_print: Annotated[Optional[StrictBool], Field(description="Returns response with indentations and line breaks.")] = None,
        quota_user: Annotated[Optional[StrictStr], Field(description="Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.")] = None,
        upload_protocol: Annotated[Optional[StrictStr], Field(description="Upload protocol for media (e.g. \"raw\", \"multipart\").")] = None,
        upload_type: Annotated[Optional[StrictStr], Field(description="Legacy upload protocol for media (e.g. \"media\", \"multipart\").")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[ApprovalRequest]:
        """accessapproval_projects_approval_requests_get

        Gets an approval request. Returns NOT_FOUND if the request does not exist.

        :param name: The name of the approval request to retrieve. Format: \"{projects|folders|organizations}/{id}/approvalRequests/{approval_request}\" (required)
        :type name: str
        :param xgafv: V1 error format.
        :type xgafv: str
        :param access_token: OAuth access token.
        :type access_token: str
        :param alt: Data format for response.
        :type alt: str
        :param param_callback: JSONP
        :type param_callback: str
        :param fields: Selector specifying which fields to include in a partial response.
        :type fields: str
        :param key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :type key: str
        :param oauth_token: OAuth 2.0 token for the current user.
        :type oauth_token: str
        :param pretty_print: Returns response with indentations and line breaks.
        :type pretty_print: bool
        :param quota_user: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
        :type quota_user: str
        :param upload_protocol: Upload protocol for media (e.g. \"raw\", \"multipart\").
        :type upload_protocol: str
        :param upload_type: Legacy upload protocol for media (e.g. \"media\", \"multipart\").
        :type upload_type: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._accessapproval_projects_approval_requests_get_serialize(
            name=name,
            xgafv=xgafv,
            access_token=access_token,
            alt=alt,
            param_callback=param_callback,
            fields=fields,
            key=key,
            oauth_token=oauth_token,
            pretty_print=pretty_print,
            quota_user=quota_user,
            upload_protocol=upload_protocol,
            upload_type=upload_type,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ApprovalRequest",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def accessapproval_projects_approval_requests_get_without_preload_content(
        self,
        name: Annotated[StrictStr, Field(description="The name of the approval request to retrieve. Format: \"{projects|folders|organizations}/{id}/approvalRequests/{approval_request}\"")],
        xgafv: Annotated[Optional[StrictStr], Field(description="V1 error format.")] = None,
        access_token: Annotated[Optional[StrictStr], Field(description="OAuth access token.")] = None,
        alt: Annotated[Optional[StrictStr], Field(description="Data format for response.")] = None,
        param_callback: Annotated[Optional[StrictStr], Field(description="JSONP")] = None,
        fields: Annotated[Optional[StrictStr], Field(description="Selector specifying which fields to include in a partial response.")] = None,
        key: Annotated[Optional[StrictStr], Field(description="API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.")] = None,
        oauth_token: Annotated[Optional[StrictStr], Field(description="OAuth 2.0 token for the current user.")] = None,
        pretty_print: Annotated[Optional[StrictBool], Field(description="Returns response with indentations and line breaks.")] = None,
        quota_user: Annotated[Optional[StrictStr], Field(description="Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.")] = None,
        upload_protocol: Annotated[Optional[StrictStr], Field(description="Upload protocol for media (e.g. \"raw\", \"multipart\").")] = None,
        upload_type: Annotated[Optional[StrictStr], Field(description="Legacy upload protocol for media (e.g. \"media\", \"multipart\").")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """accessapproval_projects_approval_requests_get

        Gets an approval request. Returns NOT_FOUND if the request does not exist.

        :param name: The name of the approval request to retrieve. Format: \"{projects|folders|organizations}/{id}/approvalRequests/{approval_request}\" (required)
        :type name: str
        :param xgafv: V1 error format.
        :type xgafv: str
        :param access_token: OAuth access token.
        :type access_token: str
        :param alt: Data format for response.
        :type alt: str
        :param param_callback: JSONP
        :type param_callback: str
        :param fields: Selector specifying which fields to include in a partial response.
        :type fields: str
        :param key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :type key: str
        :param oauth_token: OAuth 2.0 token for the current user.
        :type oauth_token: str
        :param pretty_print: Returns response with indentations and line breaks.
        :type pretty_print: bool
        :param quota_user: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
        :type quota_user: str
        :param upload_protocol: Upload protocol for media (e.g. \"raw\", \"multipart\").
        :type upload_protocol: str
        :param upload_type: Legacy upload protocol for media (e.g. \"media\", \"multipart\").
        :type upload_type: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._accessapproval_projects_approval_requests_get_serialize(
            name=name,
            xgafv=xgafv,
            access_token=access_token,
            alt=alt,
            param_callback=param_callback,
            fields=fields,
            key=key,
            oauth_token=oauth_token,
            pretty_print=pretty_print,
            quota_user=quota_user,
            upload_protocol=upload_protocol,
            upload_type=upload_type,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ApprovalRequest",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _accessapproval_projects_approval_requests_get_serialize(
        self,
        name,
        xgafv,
        access_token,
        alt,
        param_callback,
        fields,
        key,
        oauth_token,
        pretty_print,
        quota_user,
        upload_protocol,
        upload_type,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if name is not None:
            _path_params['name'] = name
        # process the query parameters
        if xgafv is not None:
            
            _query_params.append(('$.xgafv', xgafv))
            
        if access_token is not None:
            
            _query_params.append(('access_token', access_token))
            
        if alt is not None:
            
            _query_params.append(('alt', alt))
            
        if param_callback is not None:
            
            _query_params.append(('callback', param_callback))
            
        if fields is not None:
            
            _query_params.append(('fields', fields))
            
        if key is not None:
            
            _query_params.append(('key', key))
            
        if oauth_token is not None:
            
            _query_params.append(('oauth_token', oauth_token))
            
        if pretty_print is not None:
            
            _query_params.append(('prettyPrint', pretty_print))
            
        if quota_user is not None:
            
            _query_params.append(('quotaUser', quota_user))
            
        if upload_protocol is not None:
            
            _query_params.append(('upload_protocol', upload_protocol))
            
        if upload_type is not None:
            
            _query_params.append(('uploadType', upload_type))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'Oauth2c', 
            'Oauth2'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/v1/{name}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def accessapproval_projects_approval_requests_invalidate(
        self,
        name: Annotated[StrictStr, Field(description="Name of the ApprovalRequest to invalidate.")],
        xgafv: Annotated[Optional[StrictStr], Field(description="V1 error format.")] = None,
        access_token: Annotated[Optional[StrictStr], Field(description="OAuth access token.")] = None,
        alt: Annotated[Optional[StrictStr], Field(description="Data format for response.")] = None,
        param_callback: Annotated[Optional[StrictStr], Field(description="JSONP")] = None,
        fields: Annotated[Optional[StrictStr], Field(description="Selector specifying which fields to include in a partial response.")] = None,
        key: Annotated[Optional[StrictStr], Field(description="API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.")] = None,
        oauth_token: Annotated[Optional[StrictStr], Field(description="OAuth 2.0 token for the current user.")] = None,
        pretty_print: Annotated[Optional[StrictBool], Field(description="Returns response with indentations and line breaks.")] = None,
        quota_user: Annotated[Optional[StrictStr], Field(description="Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.")] = None,
        upload_protocol: Annotated[Optional[StrictStr], Field(description="Upload protocol for media (e.g. \"raw\", \"multipart\").")] = None,
        upload_type: Annotated[Optional[StrictStr], Field(description="Legacy upload protocol for media (e.g. \"media\", \"multipart\").")] = None,
        body: Optional[Dict[str, Any]] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApprovalRequest:
        """accessapproval_projects_approval_requests_invalidate

        Invalidates an existing ApprovalRequest. Returns the updated ApprovalRequest. NOTE: This does not deny access to the resource if another request has been made and approved. It only invalidates a single approval. Returns FAILED_PRECONDITION if the request exists but is not in an approved state.

        :param name: Name of the ApprovalRequest to invalidate. (required)
        :type name: str
        :param xgafv: V1 error format.
        :type xgafv: str
        :param access_token: OAuth access token.
        :type access_token: str
        :param alt: Data format for response.
        :type alt: str
        :param param_callback: JSONP
        :type param_callback: str
        :param fields: Selector specifying which fields to include in a partial response.
        :type fields: str
        :param key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :type key: str
        :param oauth_token: OAuth 2.0 token for the current user.
        :type oauth_token: str
        :param pretty_print: Returns response with indentations and line breaks.
        :type pretty_print: bool
        :param quota_user: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
        :type quota_user: str
        :param upload_protocol: Upload protocol for media (e.g. \"raw\", \"multipart\").
        :type upload_protocol: str
        :param upload_type: Legacy upload protocol for media (e.g. \"media\", \"multipart\").
        :type upload_type: str
        :param body:
        :type body: object
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._accessapproval_projects_approval_requests_invalidate_serialize(
            name=name,
            xgafv=xgafv,
            access_token=access_token,
            alt=alt,
            param_callback=param_callback,
            fields=fields,
            key=key,
            oauth_token=oauth_token,
            pretty_print=pretty_print,
            quota_user=quota_user,
            upload_protocol=upload_protocol,
            upload_type=upload_type,
            body=body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ApprovalRequest",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def accessapproval_projects_approval_requests_invalidate_with_http_info(
        self,
        name: Annotated[StrictStr, Field(description="Name of the ApprovalRequest to invalidate.")],
        xgafv: Annotated[Optional[StrictStr], Field(description="V1 error format.")] = None,
        access_token: Annotated[Optional[StrictStr], Field(description="OAuth access token.")] = None,
        alt: Annotated[Optional[StrictStr], Field(description="Data format for response.")] = None,
        param_callback: Annotated[Optional[StrictStr], Field(description="JSONP")] = None,
        fields: Annotated[Optional[StrictStr], Field(description="Selector specifying which fields to include in a partial response.")] = None,
        key: Annotated[Optional[StrictStr], Field(description="API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.")] = None,
        oauth_token: Annotated[Optional[StrictStr], Field(description="OAuth 2.0 token for the current user.")] = None,
        pretty_print: Annotated[Optional[StrictBool], Field(description="Returns response with indentations and line breaks.")] = None,
        quota_user: Annotated[Optional[StrictStr], Field(description="Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.")] = None,
        upload_protocol: Annotated[Optional[StrictStr], Field(description="Upload protocol for media (e.g. \"raw\", \"multipart\").")] = None,
        upload_type: Annotated[Optional[StrictStr], Field(description="Legacy upload protocol for media (e.g. \"media\", \"multipart\").")] = None,
        body: Optional[Dict[str, Any]] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[ApprovalRequest]:
        """accessapproval_projects_approval_requests_invalidate

        Invalidates an existing ApprovalRequest. Returns the updated ApprovalRequest. NOTE: This does not deny access to the resource if another request has been made and approved. It only invalidates a single approval. Returns FAILED_PRECONDITION if the request exists but is not in an approved state.

        :param name: Name of the ApprovalRequest to invalidate. (required)
        :type name: str
        :param xgafv: V1 error format.
        :type xgafv: str
        :param access_token: OAuth access token.
        :type access_token: str
        :param alt: Data format for response.
        :type alt: str
        :param param_callback: JSONP
        :type param_callback: str
        :param fields: Selector specifying which fields to include in a partial response.
        :type fields: str
        :param key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :type key: str
        :param oauth_token: OAuth 2.0 token for the current user.
        :type oauth_token: str
        :param pretty_print: Returns response with indentations and line breaks.
        :type pretty_print: bool
        :param quota_user: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
        :type quota_user: str
        :param upload_protocol: Upload protocol for media (e.g. \"raw\", \"multipart\").
        :type upload_protocol: str
        :param upload_type: Legacy upload protocol for media (e.g. \"media\", \"multipart\").
        :type upload_type: str
        :param body:
        :type body: object
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._accessapproval_projects_approval_requests_invalidate_serialize(
            name=name,
            xgafv=xgafv,
            access_token=access_token,
            alt=alt,
            param_callback=param_callback,
            fields=fields,
            key=key,
            oauth_token=oauth_token,
            pretty_print=pretty_print,
            quota_user=quota_user,
            upload_protocol=upload_protocol,
            upload_type=upload_type,
            body=body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ApprovalRequest",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def accessapproval_projects_approval_requests_invalidate_without_preload_content(
        self,
        name: Annotated[StrictStr, Field(description="Name of the ApprovalRequest to invalidate.")],
        xgafv: Annotated[Optional[StrictStr], Field(description="V1 error format.")] = None,
        access_token: Annotated[Optional[StrictStr], Field(description="OAuth access token.")] = None,
        alt: Annotated[Optional[StrictStr], Field(description="Data format for response.")] = None,
        param_callback: Annotated[Optional[StrictStr], Field(description="JSONP")] = None,
        fields: Annotated[Optional[StrictStr], Field(description="Selector specifying which fields to include in a partial response.")] = None,
        key: Annotated[Optional[StrictStr], Field(description="API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.")] = None,
        oauth_token: Annotated[Optional[StrictStr], Field(description="OAuth 2.0 token for the current user.")] = None,
        pretty_print: Annotated[Optional[StrictBool], Field(description="Returns response with indentations and line breaks.")] = None,
        quota_user: Annotated[Optional[StrictStr], Field(description="Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.")] = None,
        upload_protocol: Annotated[Optional[StrictStr], Field(description="Upload protocol for media (e.g. \"raw\", \"multipart\").")] = None,
        upload_type: Annotated[Optional[StrictStr], Field(description="Legacy upload protocol for media (e.g. \"media\", \"multipart\").")] = None,
        body: Optional[Dict[str, Any]] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """accessapproval_projects_approval_requests_invalidate

        Invalidates an existing ApprovalRequest. Returns the updated ApprovalRequest. NOTE: This does not deny access to the resource if another request has been made and approved. It only invalidates a single approval. Returns FAILED_PRECONDITION if the request exists but is not in an approved state.

        :param name: Name of the ApprovalRequest to invalidate. (required)
        :type name: str
        :param xgafv: V1 error format.
        :type xgafv: str
        :param access_token: OAuth access token.
        :type access_token: str
        :param alt: Data format for response.
        :type alt: str
        :param param_callback: JSONP
        :type param_callback: str
        :param fields: Selector specifying which fields to include in a partial response.
        :type fields: str
        :param key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :type key: str
        :param oauth_token: OAuth 2.0 token for the current user.
        :type oauth_token: str
        :param pretty_print: Returns response with indentations and line breaks.
        :type pretty_print: bool
        :param quota_user: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
        :type quota_user: str
        :param upload_protocol: Upload protocol for media (e.g. \"raw\", \"multipart\").
        :type upload_protocol: str
        :param upload_type: Legacy upload protocol for media (e.g. \"media\", \"multipart\").
        :type upload_type: str
        :param body:
        :type body: object
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._accessapproval_projects_approval_requests_invalidate_serialize(
            name=name,
            xgafv=xgafv,
            access_token=access_token,
            alt=alt,
            param_callback=param_callback,
            fields=fields,
            key=key,
            oauth_token=oauth_token,
            pretty_print=pretty_print,
            quota_user=quota_user,
            upload_protocol=upload_protocol,
            upload_type=upload_type,
            body=body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ApprovalRequest",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _accessapproval_projects_approval_requests_invalidate_serialize(
        self,
        name,
        xgafv,
        access_token,
        alt,
        param_callback,
        fields,
        key,
        oauth_token,
        pretty_print,
        quota_user,
        upload_protocol,
        upload_type,
        body,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if name is not None:
            _path_params['name'] = name
        # process the query parameters
        if xgafv is not None:
            
            _query_params.append(('$.xgafv', xgafv))
            
        if access_token is not None:
            
            _query_params.append(('access_token', access_token))
            
        if alt is not None:
            
            _query_params.append(('alt', alt))
            
        if param_callback is not None:
            
            _query_params.append(('callback', param_callback))
            
        if fields is not None:
            
            _query_params.append(('fields', fields))
            
        if key is not None:
            
            _query_params.append(('key', key))
            
        if oauth_token is not None:
            
            _query_params.append(('oauth_token', oauth_token))
            
        if pretty_print is not None:
            
            _query_params.append(('prettyPrint', pretty_print))
            
        if quota_user is not None:
            
            _query_params.append(('quotaUser', quota_user))
            
        if upload_protocol is not None:
            
            _query_params.append(('upload_protocol', upload_protocol))
            
        if upload_type is not None:
            
            _query_params.append(('uploadType', upload_type))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if body is not None:
            _body_params = body


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'Oauth2c', 
            'Oauth2'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/v1/{name}:invalidate',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def accessapproval_projects_approval_requests_list(
        self,
        parent: Annotated[StrictStr, Field(description="The parent resource. This may be \"projects/{project}\", \"folders/{folder}\", or \"organizations/{organization}\".")],
        xgafv: Annotated[Optional[StrictStr], Field(description="V1 error format.")] = None,
        access_token: Annotated[Optional[StrictStr], Field(description="OAuth access token.")] = None,
        alt: Annotated[Optional[StrictStr], Field(description="Data format for response.")] = None,
        param_callback: Annotated[Optional[StrictStr], Field(description="JSONP")] = None,
        fields: Annotated[Optional[StrictStr], Field(description="Selector specifying which fields to include in a partial response.")] = None,
        key: Annotated[Optional[StrictStr], Field(description="API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.")] = None,
        oauth_token: Annotated[Optional[StrictStr], Field(description="OAuth 2.0 token for the current user.")] = None,
        pretty_print: Annotated[Optional[StrictBool], Field(description="Returns response with indentations and line breaks.")] = None,
        quota_user: Annotated[Optional[StrictStr], Field(description="Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.")] = None,
        upload_protocol: Annotated[Optional[StrictStr], Field(description="Upload protocol for media (e.g. \"raw\", \"multipart\").")] = None,
        upload_type: Annotated[Optional[StrictStr], Field(description="Legacy upload protocol for media (e.g. \"media\", \"multipart\").")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="A filter on the type of approval requests to retrieve. Must be one of the following values: * [not set]: Requests that are pending or have active approvals. * ALL: All requests. * PENDING: Only pending requests. * ACTIVE: Only active (i.e. currently approved) requests. * DISMISSED: Only requests that have been dismissed, or requests that are not approved and past expiration. * EXPIRED: Only requests that have been approved, and the approval has expired. * HISTORY: Active, dismissed and expired requests.")] = None,
        page_size: Annotated[Optional[StrictInt], Field(description="Requested page size.")] = None,
        page_token: Annotated[Optional[StrictStr], Field(description="A token identifying the page of results to return.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ListApprovalRequestsResponse:
        """accessapproval_projects_approval_requests_list

        Lists approval requests associated with a project, folder, or organization. Approval requests can be filtered by state (pending, active, dismissed). The order is reverse chronological.

        :param parent: The parent resource. This may be \"projects/{project}\", \"folders/{folder}\", or \"organizations/{organization}\". (required)
        :type parent: str
        :param xgafv: V1 error format.
        :type xgafv: str
        :param access_token: OAuth access token.
        :type access_token: str
        :param alt: Data format for response.
        :type alt: str
        :param param_callback: JSONP
        :type param_callback: str
        :param fields: Selector specifying which fields to include in a partial response.
        :type fields: str
        :param key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :type key: str
        :param oauth_token: OAuth 2.0 token for the current user.
        :type oauth_token: str
        :param pretty_print: Returns response with indentations and line breaks.
        :type pretty_print: bool
        :param quota_user: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
        :type quota_user: str
        :param upload_protocol: Upload protocol for media (e.g. \"raw\", \"multipart\").
        :type upload_protocol: str
        :param upload_type: Legacy upload protocol for media (e.g. \"media\", \"multipart\").
        :type upload_type: str
        :param filter: A filter on the type of approval requests to retrieve. Must be one of the following values: * [not set]: Requests that are pending or have active approvals. * ALL: All requests. * PENDING: Only pending requests. * ACTIVE: Only active (i.e. currently approved) requests. * DISMISSED: Only requests that have been dismissed, or requests that are not approved and past expiration. * EXPIRED: Only requests that have been approved, and the approval has expired. * HISTORY: Active, dismissed and expired requests.
        :type filter: str
        :param page_size: Requested page size.
        :type page_size: int
        :param page_token: A token identifying the page of results to return.
        :type page_token: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._accessapproval_projects_approval_requests_list_serialize(
            parent=parent,
            xgafv=xgafv,
            access_token=access_token,
            alt=alt,
            param_callback=param_callback,
            fields=fields,
            key=key,
            oauth_token=oauth_token,
            pretty_print=pretty_print,
            quota_user=quota_user,
            upload_protocol=upload_protocol,
            upload_type=upload_type,
            filter=filter,
            page_size=page_size,
            page_token=page_token,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ListApprovalRequestsResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def accessapproval_projects_approval_requests_list_with_http_info(
        self,
        parent: Annotated[StrictStr, Field(description="The parent resource. This may be \"projects/{project}\", \"folders/{folder}\", or \"organizations/{organization}\".")],
        xgafv: Annotated[Optional[StrictStr], Field(description="V1 error format.")] = None,
        access_token: Annotated[Optional[StrictStr], Field(description="OAuth access token.")] = None,
        alt: Annotated[Optional[StrictStr], Field(description="Data format for response.")] = None,
        param_callback: Annotated[Optional[StrictStr], Field(description="JSONP")] = None,
        fields: Annotated[Optional[StrictStr], Field(description="Selector specifying which fields to include in a partial response.")] = None,
        key: Annotated[Optional[StrictStr], Field(description="API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.")] = None,
        oauth_token: Annotated[Optional[StrictStr], Field(description="OAuth 2.0 token for the current user.")] = None,
        pretty_print: Annotated[Optional[StrictBool], Field(description="Returns response with indentations and line breaks.")] = None,
        quota_user: Annotated[Optional[StrictStr], Field(description="Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.")] = None,
        upload_protocol: Annotated[Optional[StrictStr], Field(description="Upload protocol for media (e.g. \"raw\", \"multipart\").")] = None,
        upload_type: Annotated[Optional[StrictStr], Field(description="Legacy upload protocol for media (e.g. \"media\", \"multipart\").")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="A filter on the type of approval requests to retrieve. Must be one of the following values: * [not set]: Requests that are pending or have active approvals. * ALL: All requests. * PENDING: Only pending requests. * ACTIVE: Only active (i.e. currently approved) requests. * DISMISSED: Only requests that have been dismissed, or requests that are not approved and past expiration. * EXPIRED: Only requests that have been approved, and the approval has expired. * HISTORY: Active, dismissed and expired requests.")] = None,
        page_size: Annotated[Optional[StrictInt], Field(description="Requested page size.")] = None,
        page_token: Annotated[Optional[StrictStr], Field(description="A token identifying the page of results to return.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[ListApprovalRequestsResponse]:
        """accessapproval_projects_approval_requests_list

        Lists approval requests associated with a project, folder, or organization. Approval requests can be filtered by state (pending, active, dismissed). The order is reverse chronological.

        :param parent: The parent resource. This may be \"projects/{project}\", \"folders/{folder}\", or \"organizations/{organization}\". (required)
        :type parent: str
        :param xgafv: V1 error format.
        :type xgafv: str
        :param access_token: OAuth access token.
        :type access_token: str
        :param alt: Data format for response.
        :type alt: str
        :param param_callback: JSONP
        :type param_callback: str
        :param fields: Selector specifying which fields to include in a partial response.
        :type fields: str
        :param key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :type key: str
        :param oauth_token: OAuth 2.0 token for the current user.
        :type oauth_token: str
        :param pretty_print: Returns response with indentations and line breaks.
        :type pretty_print: bool
        :param quota_user: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
        :type quota_user: str
        :param upload_protocol: Upload protocol for media (e.g. \"raw\", \"multipart\").
        :type upload_protocol: str
        :param upload_type: Legacy upload protocol for media (e.g. \"media\", \"multipart\").
        :type upload_type: str
        :param filter: A filter on the type of approval requests to retrieve. Must be one of the following values: * [not set]: Requests that are pending or have active approvals. * ALL: All requests. * PENDING: Only pending requests. * ACTIVE: Only active (i.e. currently approved) requests. * DISMISSED: Only requests that have been dismissed, or requests that are not approved and past expiration. * EXPIRED: Only requests that have been approved, and the approval has expired. * HISTORY: Active, dismissed and expired requests.
        :type filter: str
        :param page_size: Requested page size.
        :type page_size: int
        :param page_token: A token identifying the page of results to return.
        :type page_token: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._accessapproval_projects_approval_requests_list_serialize(
            parent=parent,
            xgafv=xgafv,
            access_token=access_token,
            alt=alt,
            param_callback=param_callback,
            fields=fields,
            key=key,
            oauth_token=oauth_token,
            pretty_print=pretty_print,
            quota_user=quota_user,
            upload_protocol=upload_protocol,
            upload_type=upload_type,
            filter=filter,
            page_size=page_size,
            page_token=page_token,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ListApprovalRequestsResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def accessapproval_projects_approval_requests_list_without_preload_content(
        self,
        parent: Annotated[StrictStr, Field(description="The parent resource. This may be \"projects/{project}\", \"folders/{folder}\", or \"organizations/{organization}\".")],
        xgafv: Annotated[Optional[StrictStr], Field(description="V1 error format.")] = None,
        access_token: Annotated[Optional[StrictStr], Field(description="OAuth access token.")] = None,
        alt: Annotated[Optional[StrictStr], Field(description="Data format for response.")] = None,
        param_callback: Annotated[Optional[StrictStr], Field(description="JSONP")] = None,
        fields: Annotated[Optional[StrictStr], Field(description="Selector specifying which fields to include in a partial response.")] = None,
        key: Annotated[Optional[StrictStr], Field(description="API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.")] = None,
        oauth_token: Annotated[Optional[StrictStr], Field(description="OAuth 2.0 token for the current user.")] = None,
        pretty_print: Annotated[Optional[StrictBool], Field(description="Returns response with indentations and line breaks.")] = None,
        quota_user: Annotated[Optional[StrictStr], Field(description="Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.")] = None,
        upload_protocol: Annotated[Optional[StrictStr], Field(description="Upload protocol for media (e.g. \"raw\", \"multipart\").")] = None,
        upload_type: Annotated[Optional[StrictStr], Field(description="Legacy upload protocol for media (e.g. \"media\", \"multipart\").")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="A filter on the type of approval requests to retrieve. Must be one of the following values: * [not set]: Requests that are pending or have active approvals. * ALL: All requests. * PENDING: Only pending requests. * ACTIVE: Only active (i.e. currently approved) requests. * DISMISSED: Only requests that have been dismissed, or requests that are not approved and past expiration. * EXPIRED: Only requests that have been approved, and the approval has expired. * HISTORY: Active, dismissed and expired requests.")] = None,
        page_size: Annotated[Optional[StrictInt], Field(description="Requested page size.")] = None,
        page_token: Annotated[Optional[StrictStr], Field(description="A token identifying the page of results to return.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """accessapproval_projects_approval_requests_list

        Lists approval requests associated with a project, folder, or organization. Approval requests can be filtered by state (pending, active, dismissed). The order is reverse chronological.

        :param parent: The parent resource. This may be \"projects/{project}\", \"folders/{folder}\", or \"organizations/{organization}\". (required)
        :type parent: str
        :param xgafv: V1 error format.
        :type xgafv: str
        :param access_token: OAuth access token.
        :type access_token: str
        :param alt: Data format for response.
        :type alt: str
        :param param_callback: JSONP
        :type param_callback: str
        :param fields: Selector specifying which fields to include in a partial response.
        :type fields: str
        :param key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :type key: str
        :param oauth_token: OAuth 2.0 token for the current user.
        :type oauth_token: str
        :param pretty_print: Returns response with indentations and line breaks.
        :type pretty_print: bool
        :param quota_user: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
        :type quota_user: str
        :param upload_protocol: Upload protocol for media (e.g. \"raw\", \"multipart\").
        :type upload_protocol: str
        :param upload_type: Legacy upload protocol for media (e.g. \"media\", \"multipart\").
        :type upload_type: str
        :param filter: A filter on the type of approval requests to retrieve. Must be one of the following values: * [not set]: Requests that are pending or have active approvals. * ALL: All requests. * PENDING: Only pending requests. * ACTIVE: Only active (i.e. currently approved) requests. * DISMISSED: Only requests that have been dismissed, or requests that are not approved and past expiration. * EXPIRED: Only requests that have been approved, and the approval has expired. * HISTORY: Active, dismissed and expired requests.
        :type filter: str
        :param page_size: Requested page size.
        :type page_size: int
        :param page_token: A token identifying the page of results to return.
        :type page_token: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._accessapproval_projects_approval_requests_list_serialize(
            parent=parent,
            xgafv=xgafv,
            access_token=access_token,
            alt=alt,
            param_callback=param_callback,
            fields=fields,
            key=key,
            oauth_token=oauth_token,
            pretty_print=pretty_print,
            quota_user=quota_user,
            upload_protocol=upload_protocol,
            upload_type=upload_type,
            filter=filter,
            page_size=page_size,
            page_token=page_token,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ListApprovalRequestsResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _accessapproval_projects_approval_requests_list_serialize(
        self,
        parent,
        xgafv,
        access_token,
        alt,
        param_callback,
        fields,
        key,
        oauth_token,
        pretty_print,
        quota_user,
        upload_protocol,
        upload_type,
        filter,
        page_size,
        page_token,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if parent is not None:
            _path_params['parent'] = parent
        # process the query parameters
        if xgafv is not None:
            
            _query_params.append(('$.xgafv', xgafv))
            
        if access_token is not None:
            
            _query_params.append(('access_token', access_token))
            
        if alt is not None:
            
            _query_params.append(('alt', alt))
            
        if param_callback is not None:
            
            _query_params.append(('callback', param_callback))
            
        if fields is not None:
            
            _query_params.append(('fields', fields))
            
        if key is not None:
            
            _query_params.append(('key', key))
            
        if oauth_token is not None:
            
            _query_params.append(('oauth_token', oauth_token))
            
        if pretty_print is not None:
            
            _query_params.append(('prettyPrint', pretty_print))
            
        if quota_user is not None:
            
            _query_params.append(('quotaUser', quota_user))
            
        if upload_protocol is not None:
            
            _query_params.append(('upload_protocol', upload_protocol))
            
        if upload_type is not None:
            
            _query_params.append(('uploadType', upload_type))
            
        if filter is not None:
            
            _query_params.append(('filter', filter))
            
        if page_size is not None:
            
            _query_params.append(('pageSize', page_size))
            
        if page_token is not None:
            
            _query_params.append(('pageToken', page_token))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'Oauth2c', 
            'Oauth2'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/v1/{parent}/approvalRequests',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def accessapproval_projects_delete_access_approval_settings(
        self,
        name: Annotated[StrictStr, Field(description="Name of the AccessApprovalSettings to delete.")],
        xgafv: Annotated[Optional[StrictStr], Field(description="V1 error format.")] = None,
        access_token: Annotated[Optional[StrictStr], Field(description="OAuth access token.")] = None,
        alt: Annotated[Optional[StrictStr], Field(description="Data format for response.")] = None,
        param_callback: Annotated[Optional[StrictStr], Field(description="JSONP")] = None,
        fields: Annotated[Optional[StrictStr], Field(description="Selector specifying which fields to include in a partial response.")] = None,
        key: Annotated[Optional[StrictStr], Field(description="API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.")] = None,
        oauth_token: Annotated[Optional[StrictStr], Field(description="OAuth 2.0 token for the current user.")] = None,
        pretty_print: Annotated[Optional[StrictBool], Field(description="Returns response with indentations and line breaks.")] = None,
        quota_user: Annotated[Optional[StrictStr], Field(description="Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.")] = None,
        upload_protocol: Annotated[Optional[StrictStr], Field(description="Upload protocol for media (e.g. \"raw\", \"multipart\").")] = None,
        upload_type: Annotated[Optional[StrictStr], Field(description="Legacy upload protocol for media (e.g. \"media\", \"multipart\").")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> object:
        """accessapproval_projects_delete_access_approval_settings

        Deletes the settings associated with a project, folder, or organization. This will have the effect of disabling Access Approval for the project, folder, or organization, but only if all ancestors also have Access Approval disabled. If Access Approval is enabled at a higher level of the hierarchy, then Access Approval will still be enabled at this level as the settings are inherited.

        :param name: Name of the AccessApprovalSettings to delete. (required)
        :type name: str
        :param xgafv: V1 error format.
        :type xgafv: str
        :param access_token: OAuth access token.
        :type access_token: str
        :param alt: Data format for response.
        :type alt: str
        :param param_callback: JSONP
        :type param_callback: str
        :param fields: Selector specifying which fields to include in a partial response.
        :type fields: str
        :param key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :type key: str
        :param oauth_token: OAuth 2.0 token for the current user.
        :type oauth_token: str
        :param pretty_print: Returns response with indentations and line breaks.
        :type pretty_print: bool
        :param quota_user: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
        :type quota_user: str
        :param upload_protocol: Upload protocol for media (e.g. \"raw\", \"multipart\").
        :type upload_protocol: str
        :param upload_type: Legacy upload protocol for media (e.g. \"media\", \"multipart\").
        :type upload_type: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._accessapproval_projects_delete_access_approval_settings_serialize(
            name=name,
            xgafv=xgafv,
            access_token=access_token,
            alt=alt,
            param_callback=param_callback,
            fields=fields,
            key=key,
            oauth_token=oauth_token,
            pretty_print=pretty_print,
            quota_user=quota_user,
            upload_protocol=upload_protocol,
            upload_type=upload_type,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def accessapproval_projects_delete_access_approval_settings_with_http_info(
        self,
        name: Annotated[StrictStr, Field(description="Name of the AccessApprovalSettings to delete.")],
        xgafv: Annotated[Optional[StrictStr], Field(description="V1 error format.")] = None,
        access_token: Annotated[Optional[StrictStr], Field(description="OAuth access token.")] = None,
        alt: Annotated[Optional[StrictStr], Field(description="Data format for response.")] = None,
        param_callback: Annotated[Optional[StrictStr], Field(description="JSONP")] = None,
        fields: Annotated[Optional[StrictStr], Field(description="Selector specifying which fields to include in a partial response.")] = None,
        key: Annotated[Optional[StrictStr], Field(description="API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.")] = None,
        oauth_token: Annotated[Optional[StrictStr], Field(description="OAuth 2.0 token for the current user.")] = None,
        pretty_print: Annotated[Optional[StrictBool], Field(description="Returns response with indentations and line breaks.")] = None,
        quota_user: Annotated[Optional[StrictStr], Field(description="Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.")] = None,
        upload_protocol: Annotated[Optional[StrictStr], Field(description="Upload protocol for media (e.g. \"raw\", \"multipart\").")] = None,
        upload_type: Annotated[Optional[StrictStr], Field(description="Legacy upload protocol for media (e.g. \"media\", \"multipart\").")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[object]:
        """accessapproval_projects_delete_access_approval_settings

        Deletes the settings associated with a project, folder, or organization. This will have the effect of disabling Access Approval for the project, folder, or organization, but only if all ancestors also have Access Approval disabled. If Access Approval is enabled at a higher level of the hierarchy, then Access Approval will still be enabled at this level as the settings are inherited.

        :param name: Name of the AccessApprovalSettings to delete. (required)
        :type name: str
        :param xgafv: V1 error format.
        :type xgafv: str
        :param access_token: OAuth access token.
        :type access_token: str
        :param alt: Data format for response.
        :type alt: str
        :param param_callback: JSONP
        :type param_callback: str
        :param fields: Selector specifying which fields to include in a partial response.
        :type fields: str
        :param key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :type key: str
        :param oauth_token: OAuth 2.0 token for the current user.
        :type oauth_token: str
        :param pretty_print: Returns response with indentations and line breaks.
        :type pretty_print: bool
        :param quota_user: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
        :type quota_user: str
        :param upload_protocol: Upload protocol for media (e.g. \"raw\", \"multipart\").
        :type upload_protocol: str
        :param upload_type: Legacy upload protocol for media (e.g. \"media\", \"multipart\").
        :type upload_type: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._accessapproval_projects_delete_access_approval_settings_serialize(
            name=name,
            xgafv=xgafv,
            access_token=access_token,
            alt=alt,
            param_callback=param_callback,
            fields=fields,
            key=key,
            oauth_token=oauth_token,
            pretty_print=pretty_print,
            quota_user=quota_user,
            upload_protocol=upload_protocol,
            upload_type=upload_type,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def accessapproval_projects_delete_access_approval_settings_without_preload_content(
        self,
        name: Annotated[StrictStr, Field(description="Name of the AccessApprovalSettings to delete.")],
        xgafv: Annotated[Optional[StrictStr], Field(description="V1 error format.")] = None,
        access_token: Annotated[Optional[StrictStr], Field(description="OAuth access token.")] = None,
        alt: Annotated[Optional[StrictStr], Field(description="Data format for response.")] = None,
        param_callback: Annotated[Optional[StrictStr], Field(description="JSONP")] = None,
        fields: Annotated[Optional[StrictStr], Field(description="Selector specifying which fields to include in a partial response.")] = None,
        key: Annotated[Optional[StrictStr], Field(description="API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.")] = None,
        oauth_token: Annotated[Optional[StrictStr], Field(description="OAuth 2.0 token for the current user.")] = None,
        pretty_print: Annotated[Optional[StrictBool], Field(description="Returns response with indentations and line breaks.")] = None,
        quota_user: Annotated[Optional[StrictStr], Field(description="Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.")] = None,
        upload_protocol: Annotated[Optional[StrictStr], Field(description="Upload protocol for media (e.g. \"raw\", \"multipart\").")] = None,
        upload_type: Annotated[Optional[StrictStr], Field(description="Legacy upload protocol for media (e.g. \"media\", \"multipart\").")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """accessapproval_projects_delete_access_approval_settings

        Deletes the settings associated with a project, folder, or organization. This will have the effect of disabling Access Approval for the project, folder, or organization, but only if all ancestors also have Access Approval disabled. If Access Approval is enabled at a higher level of the hierarchy, then Access Approval will still be enabled at this level as the settings are inherited.

        :param name: Name of the AccessApprovalSettings to delete. (required)
        :type name: str
        :param xgafv: V1 error format.
        :type xgafv: str
        :param access_token: OAuth access token.
        :type access_token: str
        :param alt: Data format for response.
        :type alt: str
        :param param_callback: JSONP
        :type param_callback: str
        :param fields: Selector specifying which fields to include in a partial response.
        :type fields: str
        :param key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :type key: str
        :param oauth_token: OAuth 2.0 token for the current user.
        :type oauth_token: str
        :param pretty_print: Returns response with indentations and line breaks.
        :type pretty_print: bool
        :param quota_user: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
        :type quota_user: str
        :param upload_protocol: Upload protocol for media (e.g. \"raw\", \"multipart\").
        :type upload_protocol: str
        :param upload_type: Legacy upload protocol for media (e.g. \"media\", \"multipart\").
        :type upload_type: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._accessapproval_projects_delete_access_approval_settings_serialize(
            name=name,
            xgafv=xgafv,
            access_token=access_token,
            alt=alt,
            param_callback=param_callback,
            fields=fields,
            key=key,
            oauth_token=oauth_token,
            pretty_print=pretty_print,
            quota_user=quota_user,
            upload_protocol=upload_protocol,
            upload_type=upload_type,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _accessapproval_projects_delete_access_approval_settings_serialize(
        self,
        name,
        xgafv,
        access_token,
        alt,
        param_callback,
        fields,
        key,
        oauth_token,
        pretty_print,
        quota_user,
        upload_protocol,
        upload_type,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if name is not None:
            _path_params['name'] = name
        # process the query parameters
        if xgafv is not None:
            
            _query_params.append(('$.xgafv', xgafv))
            
        if access_token is not None:
            
            _query_params.append(('access_token', access_token))
            
        if alt is not None:
            
            _query_params.append(('alt', alt))
            
        if param_callback is not None:
            
            _query_params.append(('callback', param_callback))
            
        if fields is not None:
            
            _query_params.append(('fields', fields))
            
        if key is not None:
            
            _query_params.append(('key', key))
            
        if oauth_token is not None:
            
            _query_params.append(('oauth_token', oauth_token))
            
        if pretty_print is not None:
            
            _query_params.append(('prettyPrint', pretty_print))
            
        if quota_user is not None:
            
            _query_params.append(('quotaUser', quota_user))
            
        if upload_protocol is not None:
            
            _query_params.append(('upload_protocol', upload_protocol))
            
        if upload_type is not None:
            
            _query_params.append(('uploadType', upload_type))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'Oauth2c', 
            'Oauth2'
        ]

        return self.api_client.param_serialize(
            method='DELETE',
            resource_path='/v1/{name}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def accessapproval_projects_update_access_approval_settings(
        self,
        name: Annotated[StrictStr, Field(description="The resource name of the settings. Format is one of: * \"projects/{project}/accessApprovalSettings\" * \"folders/{folder}/accessApprovalSettings\" * \"organizations/{organization}/accessApprovalSettings\"")],
        xgafv: Annotated[Optional[StrictStr], Field(description="V1 error format.")] = None,
        access_token: Annotated[Optional[StrictStr], Field(description="OAuth access token.")] = None,
        alt: Annotated[Optional[StrictStr], Field(description="Data format for response.")] = None,
        param_callback: Annotated[Optional[StrictStr], Field(description="JSONP")] = None,
        fields: Annotated[Optional[StrictStr], Field(description="Selector specifying which fields to include in a partial response.")] = None,
        key: Annotated[Optional[StrictStr], Field(description="API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.")] = None,
        oauth_token: Annotated[Optional[StrictStr], Field(description="OAuth 2.0 token for the current user.")] = None,
        pretty_print: Annotated[Optional[StrictBool], Field(description="Returns response with indentations and line breaks.")] = None,
        quota_user: Annotated[Optional[StrictStr], Field(description="Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.")] = None,
        upload_protocol: Annotated[Optional[StrictStr], Field(description="Upload protocol for media (e.g. \"raw\", \"multipart\").")] = None,
        upload_type: Annotated[Optional[StrictStr], Field(description="Legacy upload protocol for media (e.g. \"media\", \"multipart\").")] = None,
        update_mask: Annotated[Optional[StrictStr], Field(description="The update mask applies to the settings. Only the top level fields of AccessApprovalSettings (notification_emails & enrolled_services) are supported. For each field, if it is included, the currently stored value will be entirely overwritten with the value of the field passed in this request. For the `FieldMask` definition, see https://developers.google.com/protocol-buffers/docs/reference/google.protobuf#fieldmask If this field is left unset, only the notification_emails field will be updated.")] = None,
        access_approval_settings: Optional[AccessApprovalSettings] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> AccessApprovalSettings:
        """accessapproval_projects_update_access_approval_settings

        Updates the settings associated with a project, folder, or organization. Settings to update are determined by the value of field_mask.

        :param name: The resource name of the settings. Format is one of: * \"projects/{project}/accessApprovalSettings\" * \"folders/{folder}/accessApprovalSettings\" * \"organizations/{organization}/accessApprovalSettings\" (required)
        :type name: str
        :param xgafv: V1 error format.
        :type xgafv: str
        :param access_token: OAuth access token.
        :type access_token: str
        :param alt: Data format for response.
        :type alt: str
        :param param_callback: JSONP
        :type param_callback: str
        :param fields: Selector specifying which fields to include in a partial response.
        :type fields: str
        :param key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :type key: str
        :param oauth_token: OAuth 2.0 token for the current user.
        :type oauth_token: str
        :param pretty_print: Returns response with indentations and line breaks.
        :type pretty_print: bool
        :param quota_user: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
        :type quota_user: str
        :param upload_protocol: Upload protocol for media (e.g. \"raw\", \"multipart\").
        :type upload_protocol: str
        :param upload_type: Legacy upload protocol for media (e.g. \"media\", \"multipart\").
        :type upload_type: str
        :param update_mask: The update mask applies to the settings. Only the top level fields of AccessApprovalSettings (notification_emails & enrolled_services) are supported. For each field, if it is included, the currently stored value will be entirely overwritten with the value of the field passed in this request. For the `FieldMask` definition, see https://developers.google.com/protocol-buffers/docs/reference/google.protobuf#fieldmask If this field is left unset, only the notification_emails field will be updated.
        :type update_mask: str
        :param access_approval_settings:
        :type access_approval_settings: AccessApprovalSettings
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._accessapproval_projects_update_access_approval_settings_serialize(
            name=name,
            xgafv=xgafv,
            access_token=access_token,
            alt=alt,
            param_callback=param_callback,
            fields=fields,
            key=key,
            oauth_token=oauth_token,
            pretty_print=pretty_print,
            quota_user=quota_user,
            upload_protocol=upload_protocol,
            upload_type=upload_type,
            update_mask=update_mask,
            access_approval_settings=access_approval_settings,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AccessApprovalSettings",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def accessapproval_projects_update_access_approval_settings_with_http_info(
        self,
        name: Annotated[StrictStr, Field(description="The resource name of the settings. Format is one of: * \"projects/{project}/accessApprovalSettings\" * \"folders/{folder}/accessApprovalSettings\" * \"organizations/{organization}/accessApprovalSettings\"")],
        xgafv: Annotated[Optional[StrictStr], Field(description="V1 error format.")] = None,
        access_token: Annotated[Optional[StrictStr], Field(description="OAuth access token.")] = None,
        alt: Annotated[Optional[StrictStr], Field(description="Data format for response.")] = None,
        param_callback: Annotated[Optional[StrictStr], Field(description="JSONP")] = None,
        fields: Annotated[Optional[StrictStr], Field(description="Selector specifying which fields to include in a partial response.")] = None,
        key: Annotated[Optional[StrictStr], Field(description="API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.")] = None,
        oauth_token: Annotated[Optional[StrictStr], Field(description="OAuth 2.0 token for the current user.")] = None,
        pretty_print: Annotated[Optional[StrictBool], Field(description="Returns response with indentations and line breaks.")] = None,
        quota_user: Annotated[Optional[StrictStr], Field(description="Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.")] = None,
        upload_protocol: Annotated[Optional[StrictStr], Field(description="Upload protocol for media (e.g. \"raw\", \"multipart\").")] = None,
        upload_type: Annotated[Optional[StrictStr], Field(description="Legacy upload protocol for media (e.g. \"media\", \"multipart\").")] = None,
        update_mask: Annotated[Optional[StrictStr], Field(description="The update mask applies to the settings. Only the top level fields of AccessApprovalSettings (notification_emails & enrolled_services) are supported. For each field, if it is included, the currently stored value will be entirely overwritten with the value of the field passed in this request. For the `FieldMask` definition, see https://developers.google.com/protocol-buffers/docs/reference/google.protobuf#fieldmask If this field is left unset, only the notification_emails field will be updated.")] = None,
        access_approval_settings: Optional[AccessApprovalSettings] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[AccessApprovalSettings]:
        """accessapproval_projects_update_access_approval_settings

        Updates the settings associated with a project, folder, or organization. Settings to update are determined by the value of field_mask.

        :param name: The resource name of the settings. Format is one of: * \"projects/{project}/accessApprovalSettings\" * \"folders/{folder}/accessApprovalSettings\" * \"organizations/{organization}/accessApprovalSettings\" (required)
        :type name: str
        :param xgafv: V1 error format.
        :type xgafv: str
        :param access_token: OAuth access token.
        :type access_token: str
        :param alt: Data format for response.
        :type alt: str
        :param param_callback: JSONP
        :type param_callback: str
        :param fields: Selector specifying which fields to include in a partial response.
        :type fields: str
        :param key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :type key: str
        :param oauth_token: OAuth 2.0 token for the current user.
        :type oauth_token: str
        :param pretty_print: Returns response with indentations and line breaks.
        :type pretty_print: bool
        :param quota_user: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
        :type quota_user: str
        :param upload_protocol: Upload protocol for media (e.g. \"raw\", \"multipart\").
        :type upload_protocol: str
        :param upload_type: Legacy upload protocol for media (e.g. \"media\", \"multipart\").
        :type upload_type: str
        :param update_mask: The update mask applies to the settings. Only the top level fields of AccessApprovalSettings (notification_emails & enrolled_services) are supported. For each field, if it is included, the currently stored value will be entirely overwritten with the value of the field passed in this request. For the `FieldMask` definition, see https://developers.google.com/protocol-buffers/docs/reference/google.protobuf#fieldmask If this field is left unset, only the notification_emails field will be updated.
        :type update_mask: str
        :param access_approval_settings:
        :type access_approval_settings: AccessApprovalSettings
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._accessapproval_projects_update_access_approval_settings_serialize(
            name=name,
            xgafv=xgafv,
            access_token=access_token,
            alt=alt,
            param_callback=param_callback,
            fields=fields,
            key=key,
            oauth_token=oauth_token,
            pretty_print=pretty_print,
            quota_user=quota_user,
            upload_protocol=upload_protocol,
            upload_type=upload_type,
            update_mask=update_mask,
            access_approval_settings=access_approval_settings,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AccessApprovalSettings",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def accessapproval_projects_update_access_approval_settings_without_preload_content(
        self,
        name: Annotated[StrictStr, Field(description="The resource name of the settings. Format is one of: * \"projects/{project}/accessApprovalSettings\" * \"folders/{folder}/accessApprovalSettings\" * \"organizations/{organization}/accessApprovalSettings\"")],
        xgafv: Annotated[Optional[StrictStr], Field(description="V1 error format.")] = None,
        access_token: Annotated[Optional[StrictStr], Field(description="OAuth access token.")] = None,
        alt: Annotated[Optional[StrictStr], Field(description="Data format for response.")] = None,
        param_callback: Annotated[Optional[StrictStr], Field(description="JSONP")] = None,
        fields: Annotated[Optional[StrictStr], Field(description="Selector specifying which fields to include in a partial response.")] = None,
        key: Annotated[Optional[StrictStr], Field(description="API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.")] = None,
        oauth_token: Annotated[Optional[StrictStr], Field(description="OAuth 2.0 token for the current user.")] = None,
        pretty_print: Annotated[Optional[StrictBool], Field(description="Returns response with indentations and line breaks.")] = None,
        quota_user: Annotated[Optional[StrictStr], Field(description="Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.")] = None,
        upload_protocol: Annotated[Optional[StrictStr], Field(description="Upload protocol for media (e.g. \"raw\", \"multipart\").")] = None,
        upload_type: Annotated[Optional[StrictStr], Field(description="Legacy upload protocol for media (e.g. \"media\", \"multipart\").")] = None,
        update_mask: Annotated[Optional[StrictStr], Field(description="The update mask applies to the settings. Only the top level fields of AccessApprovalSettings (notification_emails & enrolled_services) are supported. For each field, if it is included, the currently stored value will be entirely overwritten with the value of the field passed in this request. For the `FieldMask` definition, see https://developers.google.com/protocol-buffers/docs/reference/google.protobuf#fieldmask If this field is left unset, only the notification_emails field will be updated.")] = None,
        access_approval_settings: Optional[AccessApprovalSettings] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """accessapproval_projects_update_access_approval_settings

        Updates the settings associated with a project, folder, or organization. Settings to update are determined by the value of field_mask.

        :param name: The resource name of the settings. Format is one of: * \"projects/{project}/accessApprovalSettings\" * \"folders/{folder}/accessApprovalSettings\" * \"organizations/{organization}/accessApprovalSettings\" (required)
        :type name: str
        :param xgafv: V1 error format.
        :type xgafv: str
        :param access_token: OAuth access token.
        :type access_token: str
        :param alt: Data format for response.
        :type alt: str
        :param param_callback: JSONP
        :type param_callback: str
        :param fields: Selector specifying which fields to include in a partial response.
        :type fields: str
        :param key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :type key: str
        :param oauth_token: OAuth 2.0 token for the current user.
        :type oauth_token: str
        :param pretty_print: Returns response with indentations and line breaks.
        :type pretty_print: bool
        :param quota_user: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
        :type quota_user: str
        :param upload_protocol: Upload protocol for media (e.g. \"raw\", \"multipart\").
        :type upload_protocol: str
        :param upload_type: Legacy upload protocol for media (e.g. \"media\", \"multipart\").
        :type upload_type: str
        :param update_mask: The update mask applies to the settings. Only the top level fields of AccessApprovalSettings (notification_emails & enrolled_services) are supported. For each field, if it is included, the currently stored value will be entirely overwritten with the value of the field passed in this request. For the `FieldMask` definition, see https://developers.google.com/protocol-buffers/docs/reference/google.protobuf#fieldmask If this field is left unset, only the notification_emails field will be updated.
        :type update_mask: str
        :param access_approval_settings:
        :type access_approval_settings: AccessApprovalSettings
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._accessapproval_projects_update_access_approval_settings_serialize(
            name=name,
            xgafv=xgafv,
            access_token=access_token,
            alt=alt,
            param_callback=param_callback,
            fields=fields,
            key=key,
            oauth_token=oauth_token,
            pretty_print=pretty_print,
            quota_user=quota_user,
            upload_protocol=upload_protocol,
            upload_type=upload_type,
            update_mask=update_mask,
            access_approval_settings=access_approval_settings,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AccessApprovalSettings",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _accessapproval_projects_update_access_approval_settings_serialize(
        self,
        name,
        xgafv,
        access_token,
        alt,
        param_callback,
        fields,
        key,
        oauth_token,
        pretty_print,
        quota_user,
        upload_protocol,
        upload_type,
        update_mask,
        access_approval_settings,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if name is not None:
            _path_params['name'] = name
        # process the query parameters
        if xgafv is not None:
            
            _query_params.append(('$.xgafv', xgafv))
            
        if access_token is not None:
            
            _query_params.append(('access_token', access_token))
            
        if alt is not None:
            
            _query_params.append(('alt', alt))
            
        if param_callback is not None:
            
            _query_params.append(('callback', param_callback))
            
        if fields is not None:
            
            _query_params.append(('fields', fields))
            
        if key is not None:
            
            _query_params.append(('key', key))
            
        if oauth_token is not None:
            
            _query_params.append(('oauth_token', oauth_token))
            
        if pretty_print is not None:
            
            _query_params.append(('prettyPrint', pretty_print))
            
        if quota_user is not None:
            
            _query_params.append(('quotaUser', quota_user))
            
        if upload_protocol is not None:
            
            _query_params.append(('upload_protocol', upload_protocol))
            
        if upload_type is not None:
            
            _query_params.append(('uploadType', upload_type))
            
        if update_mask is not None:
            
            _query_params.append(('updateMask', update_mask))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if access_approval_settings is not None:
            _body_params = access_approval_settings


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'Oauth2c', 
            'Oauth2'
        ]

        return self.api_client.param_serialize(
            method='PATCH',
            resource_path='/v1/{name}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )


