# coding: utf-8

"""
    Network Management API

    The Network Management API provides a collection of network performance monitoring and diagnostic capabilities.

    The version of the OpenAPI document: v1
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictStr, field_validator
from typing import Any, ClassVar, Dict, List, Optional
from openapi_client.models.abort_info import AbortInfo
from openapi_client.models.app_engine_version_info import AppEngineVersionInfo
from openapi_client.models.cloud_function_info import CloudFunctionInfo
from openapi_client.models.cloud_run_revision_info import CloudRunRevisionInfo
from openapi_client.models.cloud_sql_instance_info import CloudSQLInstanceInfo
from openapi_client.models.deliver_info import DeliverInfo
from openapi_client.models.drop_info import DropInfo
from openapi_client.models.endpoint_info import EndpointInfo
from openapi_client.models.firewall_info import FirewallInfo
from openapi_client.models.forward_info import ForwardInfo
from openapi_client.models.forwarding_rule_info import ForwardingRuleInfo
from openapi_client.models.gke_master_info import GKEMasterInfo
from openapi_client.models.google_service_info import GoogleServiceInfo
from openapi_client.models.instance_info import InstanceInfo
from openapi_client.models.load_balancer_backend_info import LoadBalancerBackendInfo
from openapi_client.models.load_balancer_info import LoadBalancerInfo
from openapi_client.models.nat_info import NatInfo
from openapi_client.models.network_info import NetworkInfo
from openapi_client.models.proxy_connection_info import ProxyConnectionInfo
from openapi_client.models.route_info import RouteInfo
from openapi_client.models.storage_bucket_info import StorageBucketInfo
from openapi_client.models.vpc_connector_info import VpcConnectorInfo
from openapi_client.models.vpn_gateway_info import VpnGatewayInfo
from openapi_client.models.vpn_tunnel_info import VpnTunnelInfo
from typing import Optional, Set
from typing_extensions import Self

class Step(BaseModel):
    """
    A simulated forwarding path is composed of multiple steps. Each step has a well-defined state and an associated configuration.
    """ # noqa: E501
    abort: Optional[AbortInfo] = None
    app_engine_version: Optional[AppEngineVersionInfo] = Field(default=None, alias="appEngineVersion")
    causes_drop: Optional[StrictBool] = Field(default=None, description="This is a step that leads to the final state Drop.", alias="causesDrop")
    cloud_function: Optional[CloudFunctionInfo] = Field(default=None, alias="cloudFunction")
    cloud_run_revision: Optional[CloudRunRevisionInfo] = Field(default=None, alias="cloudRunRevision")
    cloud_sql_instance: Optional[CloudSQLInstanceInfo] = Field(default=None, alias="cloudSqlInstance")
    deliver: Optional[DeliverInfo] = None
    description: Optional[StrictStr] = Field(default=None, description="A description of the step. Usually this is a summary of the state.")
    drop: Optional[DropInfo] = None
    endpoint: Optional[EndpointInfo] = None
    firewall: Optional[FirewallInfo] = None
    forward: Optional[ForwardInfo] = None
    forwarding_rule: Optional[ForwardingRuleInfo] = Field(default=None, alias="forwardingRule")
    gke_master: Optional[GKEMasterInfo] = Field(default=None, alias="gkeMaster")
    google_service: Optional[GoogleServiceInfo] = Field(default=None, alias="googleService")
    instance: Optional[InstanceInfo] = None
    load_balancer: Optional[LoadBalancerInfo] = Field(default=None, alias="loadBalancer")
    load_balancer_backend_info: Optional[LoadBalancerBackendInfo] = Field(default=None, alias="loadBalancerBackendInfo")
    nat: Optional[NatInfo] = None
    network: Optional[NetworkInfo] = None
    project_id: Optional[StrictStr] = Field(default=None, description="Project ID that contains the configuration this step is validating.", alias="projectId")
    proxy_connection: Optional[ProxyConnectionInfo] = Field(default=None, alias="proxyConnection")
    route: Optional[RouteInfo] = None
    state: Optional[StrictStr] = Field(default=None, description="Each step is in one of the pre-defined states.")
    storage_bucket: Optional[StorageBucketInfo] = Field(default=None, alias="storageBucket")
    vpc_connector: Optional[VpcConnectorInfo] = Field(default=None, alias="vpcConnector")
    vpn_gateway: Optional[VpnGatewayInfo] = Field(default=None, alias="vpnGateway")
    vpn_tunnel: Optional[VpnTunnelInfo] = Field(default=None, alias="vpnTunnel")
    __properties: ClassVar[List[str]] = ["abort", "appEngineVersion", "causesDrop", "cloudFunction", "cloudRunRevision", "cloudSqlInstance", "deliver", "description", "drop", "endpoint", "firewall", "forward", "forwardingRule", "gkeMaster", "googleService", "instance", "loadBalancer", "loadBalancerBackendInfo", "nat", "network", "projectId", "proxyConnection", "route", "state", "storageBucket", "vpcConnector", "vpnGateway", "vpnTunnel"]

    @field_validator('state')
    def state_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['STATE_UNSPECIFIED', 'START_FROM_INSTANCE', 'START_FROM_INTERNET', 'START_FROM_GOOGLE_SERVICE', 'START_FROM_PRIVATE_NETWORK', 'START_FROM_GKE_MASTER', 'START_FROM_CLOUD_SQL_INSTANCE', 'START_FROM_CLOUD_FUNCTION', 'START_FROM_APP_ENGINE_VERSION', 'START_FROM_CLOUD_RUN_REVISION', 'START_FROM_STORAGE_BUCKET', 'START_FROM_PSC_PUBLISHED_SERVICE', 'APPLY_INGRESS_FIREWALL_RULE', 'APPLY_EGRESS_FIREWALL_RULE', 'APPLY_ROUTE', 'APPLY_FORWARDING_RULE', 'ANALYZE_LOAD_BALANCER_BACKEND', 'SPOOFING_APPROVED', 'ARRIVE_AT_INSTANCE', 'ARRIVE_AT_INTERNAL_LOAD_BALANCER', 'ARRIVE_AT_EXTERNAL_LOAD_BALANCER', 'ARRIVE_AT_VPN_GATEWAY', 'ARRIVE_AT_VPN_TUNNEL', 'ARRIVE_AT_VPC_CONNECTOR', 'NAT', 'PROXY_CONNECTION', 'DELIVER', 'DROP', 'FORWARD', 'ABORT', 'VIEWER_PERMISSION_MISSING']):
            raise ValueError("must be one of enum values ('STATE_UNSPECIFIED', 'START_FROM_INSTANCE', 'START_FROM_INTERNET', 'START_FROM_GOOGLE_SERVICE', 'START_FROM_PRIVATE_NETWORK', 'START_FROM_GKE_MASTER', 'START_FROM_CLOUD_SQL_INSTANCE', 'START_FROM_CLOUD_FUNCTION', 'START_FROM_APP_ENGINE_VERSION', 'START_FROM_CLOUD_RUN_REVISION', 'START_FROM_STORAGE_BUCKET', 'START_FROM_PSC_PUBLISHED_SERVICE', 'APPLY_INGRESS_FIREWALL_RULE', 'APPLY_EGRESS_FIREWALL_RULE', 'APPLY_ROUTE', 'APPLY_FORWARDING_RULE', 'ANALYZE_LOAD_BALANCER_BACKEND', 'SPOOFING_APPROVED', 'ARRIVE_AT_INSTANCE', 'ARRIVE_AT_INTERNAL_LOAD_BALANCER', 'ARRIVE_AT_EXTERNAL_LOAD_BALANCER', 'ARRIVE_AT_VPN_GATEWAY', 'ARRIVE_AT_VPN_TUNNEL', 'ARRIVE_AT_VPC_CONNECTOR', 'NAT', 'PROXY_CONNECTION', 'DELIVER', 'DROP', 'FORWARD', 'ABORT', 'VIEWER_PERMISSION_MISSING')")
        return value

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of Step from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of abort
        if self.abort:
            _dict['abort'] = self.abort.to_dict()
        # override the default output from pydantic by calling `to_dict()` of app_engine_version
        if self.app_engine_version:
            _dict['appEngineVersion'] = self.app_engine_version.to_dict()
        # override the default output from pydantic by calling `to_dict()` of cloud_function
        if self.cloud_function:
            _dict['cloudFunction'] = self.cloud_function.to_dict()
        # override the default output from pydantic by calling `to_dict()` of cloud_run_revision
        if self.cloud_run_revision:
            _dict['cloudRunRevision'] = self.cloud_run_revision.to_dict()
        # override the default output from pydantic by calling `to_dict()` of cloud_sql_instance
        if self.cloud_sql_instance:
            _dict['cloudSqlInstance'] = self.cloud_sql_instance.to_dict()
        # override the default output from pydantic by calling `to_dict()` of deliver
        if self.deliver:
            _dict['deliver'] = self.deliver.to_dict()
        # override the default output from pydantic by calling `to_dict()` of drop
        if self.drop:
            _dict['drop'] = self.drop.to_dict()
        # override the default output from pydantic by calling `to_dict()` of endpoint
        if self.endpoint:
            _dict['endpoint'] = self.endpoint.to_dict()
        # override the default output from pydantic by calling `to_dict()` of firewall
        if self.firewall:
            _dict['firewall'] = self.firewall.to_dict()
        # override the default output from pydantic by calling `to_dict()` of forward
        if self.forward:
            _dict['forward'] = self.forward.to_dict()
        # override the default output from pydantic by calling `to_dict()` of forwarding_rule
        if self.forwarding_rule:
            _dict['forwardingRule'] = self.forwarding_rule.to_dict()
        # override the default output from pydantic by calling `to_dict()` of gke_master
        if self.gke_master:
            _dict['gkeMaster'] = self.gke_master.to_dict()
        # override the default output from pydantic by calling `to_dict()` of google_service
        if self.google_service:
            _dict['googleService'] = self.google_service.to_dict()
        # override the default output from pydantic by calling `to_dict()` of instance
        if self.instance:
            _dict['instance'] = self.instance.to_dict()
        # override the default output from pydantic by calling `to_dict()` of load_balancer
        if self.load_balancer:
            _dict['loadBalancer'] = self.load_balancer.to_dict()
        # override the default output from pydantic by calling `to_dict()` of load_balancer_backend_info
        if self.load_balancer_backend_info:
            _dict['loadBalancerBackendInfo'] = self.load_balancer_backend_info.to_dict()
        # override the default output from pydantic by calling `to_dict()` of nat
        if self.nat:
            _dict['nat'] = self.nat.to_dict()
        # override the default output from pydantic by calling `to_dict()` of network
        if self.network:
            _dict['network'] = self.network.to_dict()
        # override the default output from pydantic by calling `to_dict()` of proxy_connection
        if self.proxy_connection:
            _dict['proxyConnection'] = self.proxy_connection.to_dict()
        # override the default output from pydantic by calling `to_dict()` of route
        if self.route:
            _dict['route'] = self.route.to_dict()
        # override the default output from pydantic by calling `to_dict()` of storage_bucket
        if self.storage_bucket:
            _dict['storageBucket'] = self.storage_bucket.to_dict()
        # override the default output from pydantic by calling `to_dict()` of vpc_connector
        if self.vpc_connector:
            _dict['vpcConnector'] = self.vpc_connector.to_dict()
        # override the default output from pydantic by calling `to_dict()` of vpn_gateway
        if self.vpn_gateway:
            _dict['vpnGateway'] = self.vpn_gateway.to_dict()
        # override the default output from pydantic by calling `to_dict()` of vpn_tunnel
        if self.vpn_tunnel:
            _dict['vpnTunnel'] = self.vpn_tunnel.to_dict()
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of Step from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "abort": AbortInfo.from_dict(obj["abort"]) if obj.get("abort") is not None else None,
            "appEngineVersion": AppEngineVersionInfo.from_dict(obj["appEngineVersion"]) if obj.get("appEngineVersion") is not None else None,
            "causesDrop": obj.get("causesDrop"),
            "cloudFunction": CloudFunctionInfo.from_dict(obj["cloudFunction"]) if obj.get("cloudFunction") is not None else None,
            "cloudRunRevision": CloudRunRevisionInfo.from_dict(obj["cloudRunRevision"]) if obj.get("cloudRunRevision") is not None else None,
            "cloudSqlInstance": CloudSQLInstanceInfo.from_dict(obj["cloudSqlInstance"]) if obj.get("cloudSqlInstance") is not None else None,
            "deliver": DeliverInfo.from_dict(obj["deliver"]) if obj.get("deliver") is not None else None,
            "description": obj.get("description"),
            "drop": DropInfo.from_dict(obj["drop"]) if obj.get("drop") is not None else None,
            "endpoint": EndpointInfo.from_dict(obj["endpoint"]) if obj.get("endpoint") is not None else None,
            "firewall": FirewallInfo.from_dict(obj["firewall"]) if obj.get("firewall") is not None else None,
            "forward": ForwardInfo.from_dict(obj["forward"]) if obj.get("forward") is not None else None,
            "forwardingRule": ForwardingRuleInfo.from_dict(obj["forwardingRule"]) if obj.get("forwardingRule") is not None else None,
            "gkeMaster": GKEMasterInfo.from_dict(obj["gkeMaster"]) if obj.get("gkeMaster") is not None else None,
            "googleService": GoogleServiceInfo.from_dict(obj["googleService"]) if obj.get("googleService") is not None else None,
            "instance": InstanceInfo.from_dict(obj["instance"]) if obj.get("instance") is not None else None,
            "loadBalancer": LoadBalancerInfo.from_dict(obj["loadBalancer"]) if obj.get("loadBalancer") is not None else None,
            "loadBalancerBackendInfo": LoadBalancerBackendInfo.from_dict(obj["loadBalancerBackendInfo"]) if obj.get("loadBalancerBackendInfo") is not None else None,
            "nat": NatInfo.from_dict(obj["nat"]) if obj.get("nat") is not None else None,
            "network": NetworkInfo.from_dict(obj["network"]) if obj.get("network") is not None else None,
            "projectId": obj.get("projectId"),
            "proxyConnection": ProxyConnectionInfo.from_dict(obj["proxyConnection"]) if obj.get("proxyConnection") is not None else None,
            "route": RouteInfo.from_dict(obj["route"]) if obj.get("route") is not None else None,
            "state": obj.get("state"),
            "storageBucket": StorageBucketInfo.from_dict(obj["storageBucket"]) if obj.get("storageBucket") is not None else None,
            "vpcConnector": VpcConnectorInfo.from_dict(obj["vpcConnector"]) if obj.get("vpcConnector") is not None else None,
            "vpnGateway": VpnGatewayInfo.from_dict(obj["vpnGateway"]) if obj.get("vpnGateway") is not None else None,
            "vpnTunnel": VpnTunnelInfo.from_dict(obj["vpnTunnel"]) if obj.get("vpnTunnel") is not None else None
        })
        return _obj


