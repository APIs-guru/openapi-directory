# coding: utf-8

"""
    Network Management API

    The Network Management API provides a collection of network performance monitoring and diagnostic capabilities.

    The version of the OpenAPI document: v1beta1
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictInt, StrictStr, field_validator
from typing import Any, ClassVar, Dict, List, Optional
from openapi_client.models.app_engine_version_endpoint import AppEngineVersionEndpoint
from openapi_client.models.cloud_function_endpoint import CloudFunctionEndpoint
from openapi_client.models.cloud_run_revision_endpoint import CloudRunRevisionEndpoint
from typing import Optional, Set
from typing_extensions import Self

class Endpoint(BaseModel):
    """
    Source or destination of the Connectivity Test.
    """ # noqa: E501
    app_engine_version: Optional[AppEngineVersionEndpoint] = Field(default=None, alias="appEngineVersion")
    cloud_function: Optional[CloudFunctionEndpoint] = Field(default=None, alias="cloudFunction")
    cloud_run_revision: Optional[CloudRunRevisionEndpoint] = Field(default=None, alias="cloudRunRevision")
    cloud_sql_instance: Optional[StrictStr] = Field(default=None, description="A [Cloud SQL](https://cloud.google.com/sql) instance URI.", alias="cloudSqlInstance")
    forwarding_rule: Optional[StrictStr] = Field(default=None, description="A forwarding rule and its corresponding IP address represent the frontend configuration of a Google Cloud load balancer. Forwarding rules are also used for protocol forwarding, Private Service Connect and other network services to provide forwarding information in the control plane. Format: projects/{project}/global/forwardingRules/{id} or projects/{project}/regions/{region}/forwardingRules/{id}", alias="forwardingRule")
    forwarding_rule_target: Optional[StrictStr] = Field(default=None, description="Output only. Specifies the type of the target of the forwarding rule.", alias="forwardingRuleTarget")
    gke_master_cluster: Optional[StrictStr] = Field(default=None, description="A cluster URI for [Google Kubernetes Engine master](https://cloud.google.com/kubernetes-engine/docs/concepts/cluster-architecture).", alias="gkeMasterCluster")
    instance: Optional[StrictStr] = Field(default=None, description="A Compute Engine instance URI.")
    ip_address: Optional[StrictStr] = Field(default=None, description="The IP address of the endpoint, which can be an external or internal IP.", alias="ipAddress")
    load_balancer_id: Optional[StrictStr] = Field(default=None, description="Output only. ID of the load balancer the forwarding rule points to. Empty for forwarding rules not related to load balancers.", alias="loadBalancerId")
    load_balancer_type: Optional[StrictStr] = Field(default=None, description="Output only. Type of the load balancer the forwarding rule points to.", alias="loadBalancerType")
    network: Optional[StrictStr] = Field(default=None, description="A Compute Engine network URI.")
    network_type: Optional[StrictStr] = Field(default=None, description="Type of the network where the endpoint is located. Applicable only to source endpoint, as destination network type can be inferred from the source.", alias="networkType")
    port: Optional[StrictInt] = Field(default=None, description="The IP protocol port of the endpoint. Only applicable when protocol is TCP or UDP.")
    project_id: Optional[StrictStr] = Field(default=None, description="Project ID where the endpoint is located. The Project ID can be derived from the URI if you provide a VM instance or network URI. The following are two cases where you must provide the project ID: 1. Only the IP address is specified, and the IP address is within a Google Cloud project. 2. When you are using Shared VPC and the IP address that you provide is from the service project. In this case, the network that the IP address resides in is defined in the host project.", alias="projectId")
    __properties: ClassVar[List[str]] = ["appEngineVersion", "cloudFunction", "cloudRunRevision", "cloudSqlInstance", "forwardingRule", "forwardingRuleTarget", "gkeMasterCluster", "instance", "ipAddress", "loadBalancerId", "loadBalancerType", "network", "networkType", "port", "projectId"]

    @field_validator('forwarding_rule_target')
    def forwarding_rule_target_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['FORWARDING_RULE_TARGET_UNSPECIFIED', 'INSTANCE', 'LOAD_BALANCER', 'VPN_GATEWAY', 'PSC']):
            raise ValueError("must be one of enum values ('FORWARDING_RULE_TARGET_UNSPECIFIED', 'INSTANCE', 'LOAD_BALANCER', 'VPN_GATEWAY', 'PSC')")
        return value

    @field_validator('load_balancer_type')
    def load_balancer_type_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['LOAD_BALANCER_TYPE_UNSPECIFIED', 'HTTPS_ADVANCED_LOAD_BALANCER', 'HTTPS_LOAD_BALANCER', 'REGIONAL_HTTPS_LOAD_BALANCER', 'INTERNAL_HTTPS_LOAD_BALANCER', 'SSL_PROXY_LOAD_BALANCER', 'TCP_PROXY_LOAD_BALANCER', 'INTERNAL_TCP_PROXY_LOAD_BALANCER', 'NETWORK_LOAD_BALANCER', 'LEGACY_NETWORK_LOAD_BALANCER', 'TCP_UDP_INTERNAL_LOAD_BALANCER']):
            raise ValueError("must be one of enum values ('LOAD_BALANCER_TYPE_UNSPECIFIED', 'HTTPS_ADVANCED_LOAD_BALANCER', 'HTTPS_LOAD_BALANCER', 'REGIONAL_HTTPS_LOAD_BALANCER', 'INTERNAL_HTTPS_LOAD_BALANCER', 'SSL_PROXY_LOAD_BALANCER', 'TCP_PROXY_LOAD_BALANCER', 'INTERNAL_TCP_PROXY_LOAD_BALANCER', 'NETWORK_LOAD_BALANCER', 'LEGACY_NETWORK_LOAD_BALANCER', 'TCP_UDP_INTERNAL_LOAD_BALANCER')")
        return value

    @field_validator('network_type')
    def network_type_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['NETWORK_TYPE_UNSPECIFIED', 'GCP_NETWORK', 'NON_GCP_NETWORK']):
            raise ValueError("must be one of enum values ('NETWORK_TYPE_UNSPECIFIED', 'GCP_NETWORK', 'NON_GCP_NETWORK')")
        return value

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of Endpoint from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        """
        excluded_fields: Set[str] = set([
            "forwarding_rule_target",
            "load_balancer_id",
            "load_balancer_type",
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of app_engine_version
        if self.app_engine_version:
            _dict['appEngineVersion'] = self.app_engine_version.to_dict()
        # override the default output from pydantic by calling `to_dict()` of cloud_function
        if self.cloud_function:
            _dict['cloudFunction'] = self.cloud_function.to_dict()
        # override the default output from pydantic by calling `to_dict()` of cloud_run_revision
        if self.cloud_run_revision:
            _dict['cloudRunRevision'] = self.cloud_run_revision.to_dict()
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of Endpoint from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "appEngineVersion": AppEngineVersionEndpoint.from_dict(obj["appEngineVersion"]) if obj.get("appEngineVersion") is not None else None,
            "cloudFunction": CloudFunctionEndpoint.from_dict(obj["cloudFunction"]) if obj.get("cloudFunction") is not None else None,
            "cloudRunRevision": CloudRunRevisionEndpoint.from_dict(obj["cloudRunRevision"]) if obj.get("cloudRunRevision") is not None else None,
            "cloudSqlInstance": obj.get("cloudSqlInstance"),
            "forwardingRule": obj.get("forwardingRule"),
            "forwardingRuleTarget": obj.get("forwardingRuleTarget"),
            "gkeMasterCluster": obj.get("gkeMasterCluster"),
            "instance": obj.get("instance"),
            "ipAddress": obj.get("ipAddress"),
            "loadBalancerId": obj.get("loadBalancerId"),
            "loadBalancerType": obj.get("loadBalancerType"),
            "network": obj.get("network"),
            "networkType": obj.get("networkType"),
            "port": obj.get("port"),
            "projectId": obj.get("projectId")
        })
        return _obj


