# coding: utf-8

"""
    Cloud Key Management Service (KMS) API

    Manages keys and performs cryptographic operations in a central cloud service, for direct use by other cloud resources and applications. 

    The version of the OpenAPI document: v1
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictStr, field_validator
from typing import Any, ClassVar, Dict, List, Optional
from openapi_client.models.key_operation_attestation import KeyOperationAttestation
from openapi_client.models.wrapping_public_key import WrappingPublicKey
from typing import Optional, Set
from typing_extensions import Self

class ImportJob(BaseModel):
    """
    An ImportJob can be used to create CryptoKeys and CryptoKeyVersions using pre-existing key material, generated outside of Cloud KMS. When an ImportJob is created, Cloud KMS will generate a \"wrapping key\", which is a public/private key pair. You use the wrapping key to encrypt (also known as wrap) the pre-existing key material to protect it during the import process. The nature of the wrapping key depends on the choice of import_method. When the wrapping key generation is complete, the state will be set to ACTIVE and the public_key can be fetched. The fetched public key can then be used to wrap your pre-existing key material. Once the key material is wrapped, it can be imported into a new CryptoKeyVersion in an existing CryptoKey by calling ImportCryptoKeyVersion. Multiple CryptoKeyVersions can be imported with a single ImportJob. Cloud KMS uses the private key portion of the wrapping key to unwrap the key material. Only Cloud KMS has access to the private key. An ImportJob expires 3 days after it is created. Once expired, Cloud KMS will no longer be able to import or unwrap any key material that was wrapped with the ImportJob's public key. For more information, see [Importing a key](https://cloud.google.com/kms/docs/importing-a-key).
    """ # noqa: E501
    attestation: Optional[KeyOperationAttestation] = None
    create_time: Optional[StrictStr] = Field(default=None, description="Output only. The time at which this ImportJob was created.", alias="createTime")
    expire_event_time: Optional[StrictStr] = Field(default=None, description="Output only. The time this ImportJob expired. Only present if state is EXPIRED.", alias="expireEventTime")
    expire_time: Optional[StrictStr] = Field(default=None, description="Output only. The time at which this ImportJob is scheduled for expiration and can no longer be used to import key material.", alias="expireTime")
    generate_time: Optional[StrictStr] = Field(default=None, description="Output only. The time this ImportJob's key material was generated.", alias="generateTime")
    import_method: Optional[StrictStr] = Field(default=None, description="Required. Immutable. The wrapping method to be used for incoming key material.", alias="importMethod")
    name: Optional[StrictStr] = Field(default=None, description="Output only. The resource name for this ImportJob in the format `projects/*/locations/*/keyRings/*/importJobs/*`.")
    protection_level: Optional[StrictStr] = Field(default=None, description="Required. Immutable. The protection level of the ImportJob. This must match the protection_level of the version_template on the CryptoKey you attempt to import into.", alias="protectionLevel")
    public_key: Optional[WrappingPublicKey] = Field(default=None, alias="publicKey")
    state: Optional[StrictStr] = Field(default=None, description="Output only. The current state of the ImportJob, indicating if it can be used.")
    __properties: ClassVar[List[str]] = ["attestation", "createTime", "expireEventTime", "expireTime", "generateTime", "importMethod", "name", "protectionLevel", "publicKey", "state"]

    @field_validator('import_method')
    def import_method_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['IMPORT_METHOD_UNSPECIFIED', 'RSA_OAEP_3072_SHA1_AES_256', 'RSA_OAEP_4096_SHA1_AES_256', 'RSA_OAEP_3072_SHA256_AES_256', 'RSA_OAEP_4096_SHA256_AES_256', 'RSA_OAEP_3072_SHA256', 'RSA_OAEP_4096_SHA256']):
            raise ValueError("must be one of enum values ('IMPORT_METHOD_UNSPECIFIED', 'RSA_OAEP_3072_SHA1_AES_256', 'RSA_OAEP_4096_SHA1_AES_256', 'RSA_OAEP_3072_SHA256_AES_256', 'RSA_OAEP_4096_SHA256_AES_256', 'RSA_OAEP_3072_SHA256', 'RSA_OAEP_4096_SHA256')")
        return value

    @field_validator('protection_level')
    def protection_level_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['PROTECTION_LEVEL_UNSPECIFIED', 'SOFTWARE', 'HSM', 'EXTERNAL', 'EXTERNAL_VPC']):
            raise ValueError("must be one of enum values ('PROTECTION_LEVEL_UNSPECIFIED', 'SOFTWARE', 'HSM', 'EXTERNAL', 'EXTERNAL_VPC')")
        return value

    @field_validator('state')
    def state_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['IMPORT_JOB_STATE_UNSPECIFIED', 'PENDING_GENERATION', 'ACTIVE', 'EXPIRED']):
            raise ValueError("must be one of enum values ('IMPORT_JOB_STATE_UNSPECIFIED', 'PENDING_GENERATION', 'ACTIVE', 'EXPIRED')")
        return value

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of ImportJob from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        """
        excluded_fields: Set[str] = set([
            "create_time",
            "expire_event_time",
            "expire_time",
            "generate_time",
            "name",
            "state",
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of attestation
        if self.attestation:
            _dict['attestation'] = self.attestation.to_dict()
        # override the default output from pydantic by calling `to_dict()` of public_key
        if self.public_key:
            _dict['publicKey'] = self.public_key.to_dict()
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of ImportJob from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "attestation": KeyOperationAttestation.from_dict(obj["attestation"]) if obj.get("attestation") is not None else None,
            "createTime": obj.get("createTime"),
            "expireEventTime": obj.get("expireEventTime"),
            "expireTime": obj.get("expireTime"),
            "generateTime": obj.get("generateTime"),
            "importMethod": obj.get("importMethod"),
            "name": obj.get("name"),
            "protectionLevel": obj.get("protectionLevel"),
            "publicKey": WrappingPublicKey.from_dict(obj["publicKey"]) if obj.get("publicKey") is not None else None,
            "state": obj.get("state")
        })
        return _obj


