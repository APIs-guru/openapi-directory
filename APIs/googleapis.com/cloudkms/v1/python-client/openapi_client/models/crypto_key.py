# coding: utf-8

"""
    Cloud Key Management Service (KMS) API

    Manages keys and performs cryptographic operations in a central cloud service, for direct use by other cloud resources and applications. 

    The version of the OpenAPI document: v1
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictStr, field_validator
from typing import Any, ClassVar, Dict, List, Optional
from openapi_client.models.crypto_key_version import CryptoKeyVersion
from openapi_client.models.crypto_key_version_template import CryptoKeyVersionTemplate
from typing import Optional, Set
from typing_extensions import Self

class CryptoKey(BaseModel):
    """
    A CryptoKey represents a logical key that can be used for cryptographic operations. A CryptoKey is made up of zero or more versions, which represent the actual key material used in cryptographic operations.
    """ # noqa: E501
    create_time: Optional[StrictStr] = Field(default=None, description="Output only. The time at which this CryptoKey was created.", alias="createTime")
    crypto_key_backend: Optional[StrictStr] = Field(default=None, description="Immutable. The resource name of the backend environment where the key material for all CryptoKeyVersions associated with this CryptoKey reside and where all related cryptographic operations are performed. Only applicable if CryptoKeyVersions have a ProtectionLevel of EXTERNAL_VPC, with the resource name in the format `projects/*/locations/*/ekmConnections/*`. Note, this list is non-exhaustive and may apply to additional ProtectionLevels in the future.", alias="cryptoKeyBackend")
    destroy_scheduled_duration: Optional[StrictStr] = Field(default=None, description="Immutable. The period of time that versions of this key spend in the DESTROY_SCHEDULED state before transitioning to DESTROYED. If not specified at creation time, the default duration is 24 hours.", alias="destroyScheduledDuration")
    import_only: Optional[StrictBool] = Field(default=None, description="Immutable. Whether this key may contain imported versions only.", alias="importOnly")
    labels: Optional[Dict[str, StrictStr]] = Field(default=None, description="Labels with user-defined metadata. For more information, see [Labeling Keys](https://cloud.google.com/kms/docs/labeling-keys).")
    name: Optional[StrictStr] = Field(default=None, description="Output only. The resource name for this CryptoKey in the format `projects/*/locations/*/keyRings/*/cryptoKeys/*`.")
    next_rotation_time: Optional[StrictStr] = Field(default=None, description="At next_rotation_time, the Key Management Service will automatically: 1. Create a new version of this CryptoKey. 2. Mark the new version as primary. Key rotations performed manually via CreateCryptoKeyVersion and UpdateCryptoKeyPrimaryVersion do not affect next_rotation_time. Keys with purpose ENCRYPT_DECRYPT support automatic rotation. For other keys, this field must be omitted.", alias="nextRotationTime")
    primary: Optional[CryptoKeyVersion] = None
    purpose: Optional[StrictStr] = Field(default=None, description="Immutable. The immutable purpose of this CryptoKey.")
    rotation_period: Optional[StrictStr] = Field(default=None, description="next_rotation_time will be advanced by this period when the service automatically rotates a key. Must be at least 24 hours and at most 876,000 hours. If rotation_period is set, next_rotation_time must also be set. Keys with purpose ENCRYPT_DECRYPT support automatic rotation. For other keys, this field must be omitted.", alias="rotationPeriod")
    version_template: Optional[CryptoKeyVersionTemplate] = Field(default=None, alias="versionTemplate")
    __properties: ClassVar[List[str]] = ["createTime", "cryptoKeyBackend", "destroyScheduledDuration", "importOnly", "labels", "name", "nextRotationTime", "primary", "purpose", "rotationPeriod", "versionTemplate"]

    @field_validator('purpose')
    def purpose_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['CRYPTO_KEY_PURPOSE_UNSPECIFIED', 'ENCRYPT_DECRYPT', 'ASYMMETRIC_SIGN', 'ASYMMETRIC_DECRYPT', 'RAW_ENCRYPT_DECRYPT', 'MAC']):
            raise ValueError("must be one of enum values ('CRYPTO_KEY_PURPOSE_UNSPECIFIED', 'ENCRYPT_DECRYPT', 'ASYMMETRIC_SIGN', 'ASYMMETRIC_DECRYPT', 'RAW_ENCRYPT_DECRYPT', 'MAC')")
        return value

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of CryptoKey from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        """
        excluded_fields: Set[str] = set([
            "create_time",
            "name",
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of primary
        if self.primary:
            _dict['primary'] = self.primary.to_dict()
        # override the default output from pydantic by calling `to_dict()` of version_template
        if self.version_template:
            _dict['versionTemplate'] = self.version_template.to_dict()
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of CryptoKey from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "createTime": obj.get("createTime"),
            "cryptoKeyBackend": obj.get("cryptoKeyBackend"),
            "destroyScheduledDuration": obj.get("destroyScheduledDuration"),
            "importOnly": obj.get("importOnly"),
            "labels": obj.get("labels"),
            "name": obj.get("name"),
            "nextRotationTime": obj.get("nextRotationTime"),
            "primary": CryptoKeyVersion.from_dict(obj["primary"]) if obj.get("primary") is not None else None,
            "purpose": obj.get("purpose"),
            "rotationPeriod": obj.get("rotationPeriod"),
            "versionTemplate": CryptoKeyVersionTemplate.from_dict(obj["versionTemplate"]) if obj.get("versionTemplate") is not None else None
        })
        return _obj


