# coding: utf-8

"""
    Cloud Healthcare API

    Manage, store, and access healthcare data in Google Cloud Platform.

    The version of the OpenAPI document: v1beta1
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictStr, field_validator
from typing import Any, ClassVar, Dict, List, Optional
from openapi_client.models.consent_config import ConsentConfig
from openapi_client.models.fhir_notification_config import FhirNotificationConfig
from openapi_client.models.notification_config import NotificationConfig
from openapi_client.models.search_config import SearchConfig
from openapi_client.models.stream_config import StreamConfig
from openapi_client.models.validation_config import ValidationConfig
from typing import Optional, Set
from typing_extensions import Self

class FhirStore(BaseModel):
    """
    Represents a FHIR store.
    """ # noqa: E501
    complex_data_type_reference_parsing: Optional[StrictStr] = Field(default=None, description="Enable parsing of references within complex FHIR data types such as Extensions. If this value is set to ENABLED, then features like referential integrity and Bundle reference rewriting apply to all references. If this flag has not been specified the behavior of the FHIR store will not change, references in complex data types will not be parsed. New stores will have this value set to ENABLED after a notification period. Warning: turning on this flag causes processing existing resources to fail if they contain references to non-existent resources.", alias="complexDataTypeReferenceParsing")
    consent_config: Optional[ConsentConfig] = Field(default=None, alias="consentConfig")
    default_search_handling_strict: Optional[StrictBool] = Field(default=None, description="If true, overrides the default search behavior for this FHIR store to `handling=strict` which returns an error for unrecognized search parameters. If false, uses the FHIR specification default `handling=lenient` which ignores unrecognized search parameters. The handling can always be changed from the default on an individual API call by setting the HTTP header `Prefer: handling=strict` or `Prefer: handling=lenient`.", alias="defaultSearchHandlingStrict")
    disable_referential_integrity: Optional[StrictBool] = Field(default=None, description="Immutable. Whether to disable referential integrity in this FHIR store. This field is immutable after FHIR store creation. The default value is false, meaning that the API enforces referential integrity and fails the requests that result in inconsistent state in the FHIR store. When this field is set to true, the API skips referential integrity checks. Consequently, operations that rely on references, such as GetPatientEverything, do not return all the results if broken references exist.", alias="disableReferentialIntegrity")
    disable_resource_versioning: Optional[StrictBool] = Field(default=None, description="Immutable. Whether to disable resource versioning for this FHIR store. This field can not be changed after the creation of FHIR store. If set to false, which is the default behavior, all write operations cause historical versions to be recorded automatically. The historical versions can be fetched through the history APIs, but cannot be updated. If set to true, no historical versions are kept. The server sends errors for attempts to read the historical versions.", alias="disableResourceVersioning")
    enable_history_modifications: Optional[StrictBool] = Field(default=None, description="Optional. Whether to allow ExecuteBundle to accept history bundles, and directly insert and overwrite historical resource versions into the FHIR store. If set to false, using history bundles fails with an error.", alias="enableHistoryModifications")
    enable_update_create: Optional[StrictBool] = Field(default=None, description="Whether this FHIR store has the [updateCreate capability](https://www.hl7.org/fhir/capabilitystatement-definitions.html#CapabilityStatement.rest.resource.updateCreate). This determines if the client can use an Update operation to create a new resource with a client-specified ID. If false, all IDs are server-assigned through the Create operation and attempts to update a non-existent resource return errors. It is strongly advised not to include or encode any sensitive data such as patient identifiers in client-specified resource IDs. Those IDs are part of the FHIR resource path recorded in Cloud audit logs and Pub/Sub notifications. Those IDs can also be contained in reference fields within other resources.", alias="enableUpdateCreate")
    labels: Optional[Dict[str, StrictStr]] = Field(default=None, description="User-supplied key-value pairs used to organize FHIR stores. Label keys must be between 1 and 63 characters long, have a UTF-8 encoding of maximum 128 bytes, and must conform to the following PCRE regular expression: \\p{Ll}\\p{Lo}{0,62} Label values are optional, must be between 1 and 63 characters long, have a UTF-8 encoding of maximum 128 bytes, and must conform to the following PCRE regular expression: [\\p{Ll}\\p{Lo}\\p{N}_-]{0,63} No more than 64 labels can be associated with a given store.")
    name: Optional[StrictStr] = Field(default=None, description="Output only. Identifier. Resource name of the FHIR store, of the form `projects/{project_id}/datasets/{dataset_id}/fhirStores/{fhir_store_id}`.")
    notification_config: Optional[NotificationConfig] = Field(default=None, alias="notificationConfig")
    notification_configs: Optional[List[FhirNotificationConfig]] = Field(default=None, description="Specifies where and whether to send notifications upon changes to a Fhir store.", alias="notificationConfigs")
    search_config: Optional[SearchConfig] = Field(default=None, alias="searchConfig")
    stream_configs: Optional[List[StreamConfig]] = Field(default=None, description="A list of streaming configs that configure the destinations of streaming export for every resource mutation in this FHIR store. Each store is allowed to have up to 10 streaming configs. After a new config is added, the next resource mutation is streamed to the new location in addition to the existing ones. When a location is removed from the list, the server stops streaming to that location. Before adding a new config, you must add the required [`bigquery.dataEditor`](https://cloud.google.com/bigquery/docs/access-control#bigquery.dataEditor) role to your project's **Cloud Healthcare Service Agent** [service account](https://cloud.google.com/iam/docs/service-accounts). Some lag (typically on the order of dozens of seconds) is expected before the results show up in the streaming destination.", alias="streamConfigs")
    validation_config: Optional[ValidationConfig] = Field(default=None, alias="validationConfig")
    version: Optional[StrictStr] = Field(default=None, description="Required. Immutable. The FHIR specification version that this FHIR store supports natively. This field is immutable after store creation. Requests are rejected if they contain FHIR resources of a different version. Version is required for every FHIR store.")
    __properties: ClassVar[List[str]] = ["complexDataTypeReferenceParsing", "consentConfig", "defaultSearchHandlingStrict", "disableReferentialIntegrity", "disableResourceVersioning", "enableHistoryModifications", "enableUpdateCreate", "labels", "name", "notificationConfig", "notificationConfigs", "searchConfig", "streamConfigs", "validationConfig", "version"]

    @field_validator('complex_data_type_reference_parsing')
    def complex_data_type_reference_parsing_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['COMPLEX_DATA_TYPE_REFERENCE_PARSING_UNSPECIFIED', 'DISABLED', 'ENABLED']):
            raise ValueError("must be one of enum values ('COMPLEX_DATA_TYPE_REFERENCE_PARSING_UNSPECIFIED', 'DISABLED', 'ENABLED')")
        return value

    @field_validator('version')
    def version_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['VERSION_UNSPECIFIED', 'DSTU2', 'STU3', 'R4']):
            raise ValueError("must be one of enum values ('VERSION_UNSPECIFIED', 'DSTU2', 'STU3', 'R4')")
        return value

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of FhirStore from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of consent_config
        if self.consent_config:
            _dict['consentConfig'] = self.consent_config.to_dict()
        # override the default output from pydantic by calling `to_dict()` of notification_config
        if self.notification_config:
            _dict['notificationConfig'] = self.notification_config.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in notification_configs (list)
        _items = []
        if self.notification_configs:
            for _item_notification_configs in self.notification_configs:
                if _item_notification_configs:
                    _items.append(_item_notification_configs.to_dict())
            _dict['notificationConfigs'] = _items
        # override the default output from pydantic by calling `to_dict()` of search_config
        if self.search_config:
            _dict['searchConfig'] = self.search_config.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in stream_configs (list)
        _items = []
        if self.stream_configs:
            for _item_stream_configs in self.stream_configs:
                if _item_stream_configs:
                    _items.append(_item_stream_configs.to_dict())
            _dict['streamConfigs'] = _items
        # override the default output from pydantic by calling `to_dict()` of validation_config
        if self.validation_config:
            _dict['validationConfig'] = self.validation_config.to_dict()
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of FhirStore from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "complexDataTypeReferenceParsing": obj.get("complexDataTypeReferenceParsing"),
            "consentConfig": ConsentConfig.from_dict(obj["consentConfig"]) if obj.get("consentConfig") is not None else None,
            "defaultSearchHandlingStrict": obj.get("defaultSearchHandlingStrict"),
            "disableReferentialIntegrity": obj.get("disableReferentialIntegrity"),
            "disableResourceVersioning": obj.get("disableResourceVersioning"),
            "enableHistoryModifications": obj.get("enableHistoryModifications"),
            "enableUpdateCreate": obj.get("enableUpdateCreate"),
            "labels": obj.get("labels"),
            "name": obj.get("name"),
            "notificationConfig": NotificationConfig.from_dict(obj["notificationConfig"]) if obj.get("notificationConfig") is not None else None,
            "notificationConfigs": [FhirNotificationConfig.from_dict(_item) for _item in obj["notificationConfigs"]] if obj.get("notificationConfigs") is not None else None,
            "searchConfig": SearchConfig.from_dict(obj["searchConfig"]) if obj.get("searchConfig") is not None else None,
            "streamConfigs": [StreamConfig.from_dict(_item) for _item in obj["streamConfigs"]] if obj.get("streamConfigs") is not None else None,
            "validationConfig": ValidationConfig.from_dict(obj["validationConfig"]) if obj.get("validationConfig") is not None else None,
            "version": obj.get("version")
        })
        return _obj


