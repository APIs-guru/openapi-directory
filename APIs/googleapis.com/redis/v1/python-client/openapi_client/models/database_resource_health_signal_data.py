# coding: utf-8

"""
    Google Cloud Memorystore for Redis API

    Creates and manages Redis instances on the Google Cloud Platform.

    The version of the OpenAPI document: v1
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictStr, field_validator
from typing import Any, ClassVar, Dict, List, Optional
from openapi_client.models.compliance import Compliance
from typing import Optional, Set
from typing_extensions import Self

class DatabaseResourceHealthSignalData(BaseModel):
    """
    Common model for database resource health signal data.
    """ # noqa: E501
    additional_metadata: Optional[Dict[str, Any]] = Field(default=None, description="Any other additional metadata", alias="additionalMetadata")
    compliance: Optional[List[Compliance]] = Field(default=None, description="Industry standards associated with this signal; if this signal is an issue, that could be a violation of the associated industry standard(s). For example, AUTO_BACKUP_DISABLED signal is associated with CIS GCP 1.1, CIS GCP 1.2, CIS GCP 1.3, NIST 800-53 and ISO-27001 compliance standards. If a database resource does not have automated backup enable, it will violate these following industry standards.")
    description: Optional[StrictStr] = Field(default=None, description="Description associated with signal")
    event_time: Optional[StrictStr] = Field(default=None, description="Required. The last time at which the event described by this signal took place", alias="eventTime")
    external_uri: Optional[StrictStr] = Field(default=None, description="The external-uri of the signal, using which more information about this signal can be obtained. In GCP, this will take user to SCC page to get more details about signals.", alias="externalUri")
    name: Optional[StrictStr] = Field(default=None, description="Required. The name of the signal, ex: PUBLIC_SQL_INSTANCE, SQL_LOG_ERROR_VERBOSITY etc.")
    provider: Optional[StrictStr] = Field(default=None, description="Cloud provider name. Ex: GCP/AWS/Azure/OnPrem/SelfManaged")
    resource_container: Optional[StrictStr] = Field(default=None, description="Closest parent container of this resource. In GCP, 'container' refers to a Cloud Resource Manager project. It must be resource name of a Cloud Resource Manager project with the format of \"provider//\", such as \"projects/123\". For GCP provided resources, number should be project number.", alias="resourceContainer")
    resource_name: Optional[StrictStr] = Field(default=None, description="Required. Database resource name associated with the signal. Resource name to follow CAIS resource_name format as noted here go/condor-common-datamodel", alias="resourceName")
    signal_class: Optional[StrictStr] = Field(default=None, description="Required. The class of the signal, such as if it's a THREAT or VULNERABILITY.", alias="signalClass")
    signal_id: Optional[StrictStr] = Field(default=None, description="Required. Unique identifier for the signal. This is an unique id which would be mainatined by partner to identify a signal.", alias="signalId")
    signal_type: Optional[StrictStr] = Field(default=None, description="Required. Type of signal, for example, `AVAILABLE_IN_MULTIPLE_ZONES`, `LOGGING_MOST_ERRORS`, etc.", alias="signalType")
    state: Optional[StrictStr] = None
    __properties: ClassVar[List[str]] = ["additionalMetadata", "compliance", "description", "eventTime", "externalUri", "name", "provider", "resourceContainer", "resourceName", "signalClass", "signalId", "signalType", "state"]

    @field_validator('provider')
    def provider_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['PROVIDER_UNSPECIFIED', 'GCP', 'AWS', 'AZURE', 'ONPREM', 'SELFMANAGED', 'PROVIDER_OTHER']):
            raise ValueError("must be one of enum values ('PROVIDER_UNSPECIFIED', 'GCP', 'AWS', 'AZURE', 'ONPREM', 'SELFMANAGED', 'PROVIDER_OTHER')")
        return value

    @field_validator('signal_class')
    def signal_class_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['CLASS_UNSPECIFIED', 'THREAT', 'VULNERABILITY', 'MISCONFIGURATION', 'OBSERVATION', 'ERROR']):
            raise ValueError("must be one of enum values ('CLASS_UNSPECIFIED', 'THREAT', 'VULNERABILITY', 'MISCONFIGURATION', 'OBSERVATION', 'ERROR')")
        return value

    @field_validator('signal_type')
    def signal_type_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['SIGNAL_TYPE_UNSPECIFIED', 'SIGNAL_TYPE_NOT_PROTECTED_BY_AUTOMATIC_FAILOVER', 'SIGNAL_TYPE_GROUP_NOT_REPLICATING_ACROSS_REGIONS', 'SIGNAL_TYPE_NOT_AVAILABLE_IN_MULTIPLE_ZONES', 'SIGNAL_TYPE_NOT_AVAILABLE_IN_MULTIPLE_REGIONS', 'SIGNAL_TYPE_NO_PROMOTABLE_REPLICA', 'SIGNAL_TYPE_NO_AUTOMATED_BACKUP_POLICY', 'SIGNAL_TYPE_SHORT_BACKUP_RETENTION', 'SIGNAL_TYPE_LAST_BACKUP_FAILED', 'SIGNAL_TYPE_LAST_BACKUP_OLD', 'SIGNAL_TYPE_VIOLATES_CIS_GCP_FOUNDATION_2_0', 'SIGNAL_TYPE_VIOLATES_CIS_GCP_FOUNDATION_1_3', 'SIGNAL_TYPE_VIOLATES_CIS_GCP_FOUNDATION_1_2', 'SIGNAL_TYPE_VIOLATES_CIS_GCP_FOUNDATION_1_1', 'SIGNAL_TYPE_VIOLATES_CIS_GCP_FOUNDATION_1_0', 'SIGNAL_TYPE_VIOLATES_NIST_800_53', 'SIGNAL_TYPE_VIOLATES_ISO_27001', 'SIGNAL_TYPE_VIOLATES_PCI_DSS_V3_2_1', 'SIGNAL_TYPE_LOGS_NOT_OPTIMIZED_FOR_TROUBLESHOOTING', 'SIGNAL_TYPE_QUERY_DURATIONS_NOT_LOGGED', 'SIGNAL_TYPE_VERBOSE_ERROR_LOGGING', 'SIGNAL_TYPE_QUERY_LOCK_WAITS_NOT_LOGGED', 'SIGNAL_TYPE_LOGGING_MOST_ERRORS', 'SIGNAL_TYPE_LOGGING_ONLY_CRITICAL_ERRORS', 'SIGNAL_TYPE_MINIMAL_ERROR_LOGGING', 'SIGNAL_TYPE_QUERY_STATISTICS_LOGGED', 'SIGNAL_TYPE_EXCESSIVE_LOGGING_OF_CLIENT_HOSTNAME', 'SIGNAL_TYPE_EXCESSIVE_LOGGING_OF_PARSER_STATISTICS', 'SIGNAL_TYPE_EXCESSIVE_LOGGING_OF_PLANNER_STATISTICS', 'SIGNAL_TYPE_NOT_LOGGING_ONLY_DDL_STATEMENTS', 'SIGNAL_TYPE_LOGGING_QUERY_STATISTICS', 'SIGNAL_TYPE_NOT_LOGGING_TEMPORARY_FILES', 'SIGNAL_TYPE_CONNECTION_MAX_NOT_CONFIGURED', 'SIGNAL_TYPE_USER_OPTIONS_CONFIGURED', 'SIGNAL_TYPE_EXPOSED_TO_PUBLIC_ACCESS', 'SIGNAL_TYPE_UNENCRYPTED_CONNECTIONS', 'SIGNAL_TYPE_NO_ROOT_PASSWORD', 'SIGNAL_TYPE_WEAK_ROOT_PASSWORD', 'SIGNAL_TYPE_ENCRYPTION_KEY_NOT_CUSTOMER_MANAGED', 'SIGNAL_TYPE_SERVER_AUTHENTICATION_NOT_REQUIRED', 'SIGNAL_TYPE_EXPOSED_BY_OWNERSHIP_CHAINING', 'SIGNAL_TYPE_EXPOSED_TO_EXTERNAL_SCRIPTS', 'SIGNAL_TYPE_EXPOSED_TO_LOCAL_DATA_LOADS', 'SIGNAL_TYPE_CONNECTION_ATTEMPTS_NOT_LOGGED', 'SIGNAL_TYPE_DISCONNECTIONS_NOT_LOGGED', 'SIGNAL_TYPE_LOGGING_EXCESSIVE_STATEMENT_INFO', 'SIGNAL_TYPE_EXPOSED_TO_REMOTE_ACCESS', 'SIGNAL_TYPE_DATABASE_NAMES_EXPOSED', 'SIGNAL_TYPE_SENSITIVE_TRACE_INFO_NOT_MASKED', 'SIGNAL_TYPE_PUBLIC_IP_ENABLED', 'SIGNAL_TYPE_IDLE', 'SIGNAL_TYPE_OVERPROVISIONED', 'SIGNAL_TYPE_HIGH_NUMBER_OF_OPEN_TABLES', 'SIGNAL_TYPE_HIGH_NUMBER_OF_TABLES', 'SIGNAL_TYPE_HIGH_TRANSACTION_ID_UTILIZATION', 'SIGNAL_TYPE_UNDERPROVISIONED', 'SIGNAL_TYPE_OUT_OF_DISK', 'SIGNAL_TYPE_SERVER_CERTIFICATE_NEAR_EXPIRY', 'SIGNAL_TYPE_DATABASE_AUDITING_DISABLED', 'SIGNAL_TYPE_RESTRICT_AUTHORIZED_NETWORKS', 'SIGNAL_TYPE_VIOLATE_POLICY_RESTRICT_PUBLIC_IP']):
            raise ValueError("must be one of enum values ('SIGNAL_TYPE_UNSPECIFIED', 'SIGNAL_TYPE_NOT_PROTECTED_BY_AUTOMATIC_FAILOVER', 'SIGNAL_TYPE_GROUP_NOT_REPLICATING_ACROSS_REGIONS', 'SIGNAL_TYPE_NOT_AVAILABLE_IN_MULTIPLE_ZONES', 'SIGNAL_TYPE_NOT_AVAILABLE_IN_MULTIPLE_REGIONS', 'SIGNAL_TYPE_NO_PROMOTABLE_REPLICA', 'SIGNAL_TYPE_NO_AUTOMATED_BACKUP_POLICY', 'SIGNAL_TYPE_SHORT_BACKUP_RETENTION', 'SIGNAL_TYPE_LAST_BACKUP_FAILED', 'SIGNAL_TYPE_LAST_BACKUP_OLD', 'SIGNAL_TYPE_VIOLATES_CIS_GCP_FOUNDATION_2_0', 'SIGNAL_TYPE_VIOLATES_CIS_GCP_FOUNDATION_1_3', 'SIGNAL_TYPE_VIOLATES_CIS_GCP_FOUNDATION_1_2', 'SIGNAL_TYPE_VIOLATES_CIS_GCP_FOUNDATION_1_1', 'SIGNAL_TYPE_VIOLATES_CIS_GCP_FOUNDATION_1_0', 'SIGNAL_TYPE_VIOLATES_NIST_800_53', 'SIGNAL_TYPE_VIOLATES_ISO_27001', 'SIGNAL_TYPE_VIOLATES_PCI_DSS_V3_2_1', 'SIGNAL_TYPE_LOGS_NOT_OPTIMIZED_FOR_TROUBLESHOOTING', 'SIGNAL_TYPE_QUERY_DURATIONS_NOT_LOGGED', 'SIGNAL_TYPE_VERBOSE_ERROR_LOGGING', 'SIGNAL_TYPE_QUERY_LOCK_WAITS_NOT_LOGGED', 'SIGNAL_TYPE_LOGGING_MOST_ERRORS', 'SIGNAL_TYPE_LOGGING_ONLY_CRITICAL_ERRORS', 'SIGNAL_TYPE_MINIMAL_ERROR_LOGGING', 'SIGNAL_TYPE_QUERY_STATISTICS_LOGGED', 'SIGNAL_TYPE_EXCESSIVE_LOGGING_OF_CLIENT_HOSTNAME', 'SIGNAL_TYPE_EXCESSIVE_LOGGING_OF_PARSER_STATISTICS', 'SIGNAL_TYPE_EXCESSIVE_LOGGING_OF_PLANNER_STATISTICS', 'SIGNAL_TYPE_NOT_LOGGING_ONLY_DDL_STATEMENTS', 'SIGNAL_TYPE_LOGGING_QUERY_STATISTICS', 'SIGNAL_TYPE_NOT_LOGGING_TEMPORARY_FILES', 'SIGNAL_TYPE_CONNECTION_MAX_NOT_CONFIGURED', 'SIGNAL_TYPE_USER_OPTIONS_CONFIGURED', 'SIGNAL_TYPE_EXPOSED_TO_PUBLIC_ACCESS', 'SIGNAL_TYPE_UNENCRYPTED_CONNECTIONS', 'SIGNAL_TYPE_NO_ROOT_PASSWORD', 'SIGNAL_TYPE_WEAK_ROOT_PASSWORD', 'SIGNAL_TYPE_ENCRYPTION_KEY_NOT_CUSTOMER_MANAGED', 'SIGNAL_TYPE_SERVER_AUTHENTICATION_NOT_REQUIRED', 'SIGNAL_TYPE_EXPOSED_BY_OWNERSHIP_CHAINING', 'SIGNAL_TYPE_EXPOSED_TO_EXTERNAL_SCRIPTS', 'SIGNAL_TYPE_EXPOSED_TO_LOCAL_DATA_LOADS', 'SIGNAL_TYPE_CONNECTION_ATTEMPTS_NOT_LOGGED', 'SIGNAL_TYPE_DISCONNECTIONS_NOT_LOGGED', 'SIGNAL_TYPE_LOGGING_EXCESSIVE_STATEMENT_INFO', 'SIGNAL_TYPE_EXPOSED_TO_REMOTE_ACCESS', 'SIGNAL_TYPE_DATABASE_NAMES_EXPOSED', 'SIGNAL_TYPE_SENSITIVE_TRACE_INFO_NOT_MASKED', 'SIGNAL_TYPE_PUBLIC_IP_ENABLED', 'SIGNAL_TYPE_IDLE', 'SIGNAL_TYPE_OVERPROVISIONED', 'SIGNAL_TYPE_HIGH_NUMBER_OF_OPEN_TABLES', 'SIGNAL_TYPE_HIGH_NUMBER_OF_TABLES', 'SIGNAL_TYPE_HIGH_TRANSACTION_ID_UTILIZATION', 'SIGNAL_TYPE_UNDERPROVISIONED', 'SIGNAL_TYPE_OUT_OF_DISK', 'SIGNAL_TYPE_SERVER_CERTIFICATE_NEAR_EXPIRY', 'SIGNAL_TYPE_DATABASE_AUDITING_DISABLED', 'SIGNAL_TYPE_RESTRICT_AUTHORIZED_NETWORKS', 'SIGNAL_TYPE_VIOLATE_POLICY_RESTRICT_PUBLIC_IP')")
        return value

    @field_validator('state')
    def state_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['STATE_UNSPECIFIED', 'ACTIVE', 'RESOLVED', 'MUTED']):
            raise ValueError("must be one of enum values ('STATE_UNSPECIFIED', 'ACTIVE', 'RESOLVED', 'MUTED')")
        return value

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of DatabaseResourceHealthSignalData from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of each item in compliance (list)
        _items = []
        if self.compliance:
            for _item_compliance in self.compliance:
                if _item_compliance:
                    _items.append(_item_compliance.to_dict())
            _dict['compliance'] = _items
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of DatabaseResourceHealthSignalData from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "additionalMetadata": obj.get("additionalMetadata"),
            "compliance": [Compliance.from_dict(_item) for _item in obj["compliance"]] if obj.get("compliance") is not None else None,
            "description": obj.get("description"),
            "eventTime": obj.get("eventTime"),
            "externalUri": obj.get("externalUri"),
            "name": obj.get("name"),
            "provider": obj.get("provider"),
            "resourceContainer": obj.get("resourceContainer"),
            "resourceName": obj.get("resourceName"),
            "signalClass": obj.get("signalClass"),
            "signalId": obj.get("signalId"),
            "signalType": obj.get("signalType"),
            "state": obj.get("state")
        })
        return _obj


