# coding: utf-8

"""
    Cloud Document AI API

    Service to parse structured information from unstructured or semi-structured documents using state-of-the-art Google AI such as natural language, computer vision, translation, and AutoML.

    The version of the OpenAPI document: v1
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictBytes, StrictStr
from typing import Any, ClassVar, Dict, List, Optional, Union
from openapi_client.models.google_cloud_documentai_v1_document_entity import GoogleCloudDocumentaiV1DocumentEntity
from openapi_client.models.google_cloud_documentai_v1_document_entity_relation import GoogleCloudDocumentaiV1DocumentEntityRelation
from openapi_client.models.google_cloud_documentai_v1_document_page import GoogleCloudDocumentaiV1DocumentPage
from openapi_client.models.google_cloud_documentai_v1_document_revision import GoogleCloudDocumentaiV1DocumentRevision
from openapi_client.models.google_cloud_documentai_v1_document_shard_info import GoogleCloudDocumentaiV1DocumentShardInfo
from openapi_client.models.google_cloud_documentai_v1_document_style import GoogleCloudDocumentaiV1DocumentStyle
from openapi_client.models.google_cloud_documentai_v1_document_text_change import GoogleCloudDocumentaiV1DocumentTextChange
from openapi_client.models.google_rpc_status import GoogleRpcStatus
from typing import Optional, Set
from typing_extensions import Self

class GoogleCloudDocumentaiV1Document(BaseModel):
    """
    Document represents the canonical document resource in Document AI. It is an interchange format that provides insights into documents and allows for collaboration between users and Document AI to iterate and optimize for quality.
    """ # noqa: E501
    content: Optional[Union[StrictBytes, StrictStr]] = Field(default=None, description="Optional. Inline document content, represented as a stream of bytes. Note: As with all `bytes` fields, protobuffers use a pure binary representation, whereas JSON representations use base64.")
    entities: Optional[List[GoogleCloudDocumentaiV1DocumentEntity]] = Field(default=None, description="A list of entities detected on Document.text. For document shards, entities in this list may cross shard boundaries.")
    entity_relations: Optional[List[GoogleCloudDocumentaiV1DocumentEntityRelation]] = Field(default=None, description="Placeholder. Relationship among Document.entities.", alias="entityRelations")
    error: Optional[GoogleRpcStatus] = None
    mime_type: Optional[StrictStr] = Field(default=None, description="An IANA published [media type (MIME type)](https://www.iana.org/assignments/media-types/media-types.xhtml).", alias="mimeType")
    pages: Optional[List[GoogleCloudDocumentaiV1DocumentPage]] = Field(default=None, description="Visual page layout for the Document.")
    revisions: Optional[List[GoogleCloudDocumentaiV1DocumentRevision]] = Field(default=None, description="Placeholder. Revision history of this document.")
    shard_info: Optional[GoogleCloudDocumentaiV1DocumentShardInfo] = Field(default=None, alias="shardInfo")
    text: Optional[StrictStr] = Field(default=None, description="Optional. UTF-8 encoded text in reading order from the document.")
    text_changes: Optional[List[GoogleCloudDocumentaiV1DocumentTextChange]] = Field(default=None, description="Placeholder. A list of text corrections made to Document.text. This is usually used for annotating corrections to OCR mistakes. Text changes for a given revision may not overlap with each other.", alias="textChanges")
    text_styles: Optional[List[GoogleCloudDocumentaiV1DocumentStyle]] = Field(default=None, description="Styles for the Document.text.", alias="textStyles")
    uri: Optional[StrictStr] = Field(default=None, description="Optional. Currently supports Google Cloud Storage URI of the form `gs://bucket_name/object_name`. Object versioning is not supported. For more information, refer to [Google Cloud Storage Request URIs](https://cloud.google.com/storage/docs/reference-uris).")
    __properties: ClassVar[List[str]] = ["content", "entities", "entityRelations", "error", "mimeType", "pages", "revisions", "shardInfo", "text", "textChanges", "textStyles", "uri"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of GoogleCloudDocumentaiV1Document from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of each item in entities (list)
        _items = []
        if self.entities:
            for _item_entities in self.entities:
                if _item_entities:
                    _items.append(_item_entities.to_dict())
            _dict['entities'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in entity_relations (list)
        _items = []
        if self.entity_relations:
            for _item_entity_relations in self.entity_relations:
                if _item_entity_relations:
                    _items.append(_item_entity_relations.to_dict())
            _dict['entityRelations'] = _items
        # override the default output from pydantic by calling `to_dict()` of error
        if self.error:
            _dict['error'] = self.error.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in pages (list)
        _items = []
        if self.pages:
            for _item_pages in self.pages:
                if _item_pages:
                    _items.append(_item_pages.to_dict())
            _dict['pages'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in revisions (list)
        _items = []
        if self.revisions:
            for _item_revisions in self.revisions:
                if _item_revisions:
                    _items.append(_item_revisions.to_dict())
            _dict['revisions'] = _items
        # override the default output from pydantic by calling `to_dict()` of shard_info
        if self.shard_info:
            _dict['shardInfo'] = self.shard_info.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in text_changes (list)
        _items = []
        if self.text_changes:
            for _item_text_changes in self.text_changes:
                if _item_text_changes:
                    _items.append(_item_text_changes.to_dict())
            _dict['textChanges'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in text_styles (list)
        _items = []
        if self.text_styles:
            for _item_text_styles in self.text_styles:
                if _item_text_styles:
                    _items.append(_item_text_styles.to_dict())
            _dict['textStyles'] = _items
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of GoogleCloudDocumentaiV1Document from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "content": obj.get("content"),
            "entities": [GoogleCloudDocumentaiV1DocumentEntity.from_dict(_item) for _item in obj["entities"]] if obj.get("entities") is not None else None,
            "entityRelations": [GoogleCloudDocumentaiV1DocumentEntityRelation.from_dict(_item) for _item in obj["entityRelations"]] if obj.get("entityRelations") is not None else None,
            "error": GoogleRpcStatus.from_dict(obj["error"]) if obj.get("error") is not None else None,
            "mimeType": obj.get("mimeType"),
            "pages": [GoogleCloudDocumentaiV1DocumentPage.from_dict(_item) for _item in obj["pages"]] if obj.get("pages") is not None else None,
            "revisions": [GoogleCloudDocumentaiV1DocumentRevision.from_dict(_item) for _item in obj["revisions"]] if obj.get("revisions") is not None else None,
            "shardInfo": GoogleCloudDocumentaiV1DocumentShardInfo.from_dict(obj["shardInfo"]) if obj.get("shardInfo") is not None else None,
            "text": obj.get("text"),
            "textChanges": [GoogleCloudDocumentaiV1DocumentTextChange.from_dict(_item) for _item in obj["textChanges"]] if obj.get("textChanges") is not None else None,
            "textStyles": [GoogleCloudDocumentaiV1DocumentStyle.from_dict(_item) for _item in obj["textStyles"]] if obj.get("textStyles") is not None else None,
            "uri": obj.get("uri")
        })
        return _obj


