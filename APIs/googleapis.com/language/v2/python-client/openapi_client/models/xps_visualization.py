# coding: utf-8

"""
    Cloud Natural Language API

    Provides natural language understanding technologies, such as sentiment analysis, entity recognition, entity sentiment analysis, and other text annotations, to developers.

    The version of the OpenAPI document: v2
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictFloat, StrictInt, StrictStr, field_validator
from typing import Any, ClassVar, Dict, List, Optional, Union
from typing import Optional, Set
from typing_extensions import Self

class XPSVisualization(BaseModel):
    """
    Visualization configurations for image explanation.
    """ # noqa: E501
    clip_percent_lowerbound: Optional[Union[StrictFloat, StrictInt]] = Field(default=None, description="Excludes attributions below the specified percentile, from the highlighted areas. Defaults to 62.", alias="clipPercentLowerbound")
    clip_percent_upperbound: Optional[Union[StrictFloat, StrictInt]] = Field(default=None, description="Excludes attributions above the specified percentile from the highlighted areas. Using the clip_percent_upperbound and clip_percent_lowerbound together can be useful for filtering out noise and making it easier to see areas of strong attribution. Defaults to 99.9.", alias="clipPercentUpperbound")
    color_map: Optional[StrictStr] = Field(default=None, description="The color scheme used for the highlighted areas. Defaults to PINK_GREEN for Integrated Gradients attribution, which shows positive attributions in green and negative in pink. Defaults to VIRIDIS for XRAI attribution, which highlights the most influential regions in yellow and the least influential in blue.", alias="colorMap")
    overlay_type: Optional[StrictStr] = Field(default=None, description="How the original image is displayed in the visualization. Adjusting the overlay can help increase visual clarity if the original image makes it difficult to view the visualization. Defaults to NONE.", alias="overlayType")
    polarity: Optional[StrictStr] = Field(default=None, description="Whether to only highlight pixels with positive contributions, negative or both. Defaults to POSITIVE.")
    type: Optional[StrictStr] = Field(default=None, description="Type of the image visualization. Only applicable to Integrated Gradients attribution. OUTLINES shows regions of attribution, while PIXELS shows per-pixel attribution. Defaults to OUTLINES.")
    __properties: ClassVar[List[str]] = ["clipPercentLowerbound", "clipPercentUpperbound", "colorMap", "overlayType", "polarity", "type"]

    @field_validator('color_map')
    def color_map_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['COLOR_MAP_UNSPECIFIED', 'PINK_GREEN', 'VIRIDIS', 'RED', 'GREEN', 'RED_GREEN', 'PINK_WHITE_GREEN']):
            raise ValueError("must be one of enum values ('COLOR_MAP_UNSPECIFIED', 'PINK_GREEN', 'VIRIDIS', 'RED', 'GREEN', 'RED_GREEN', 'PINK_WHITE_GREEN')")
        return value

    @field_validator('overlay_type')
    def overlay_type_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['OVERLAY_TYPE_UNSPECIFIED', 'NONE', 'ORIGINAL', 'GRAYSCALE', 'MASK_BLACK']):
            raise ValueError("must be one of enum values ('OVERLAY_TYPE_UNSPECIFIED', 'NONE', 'ORIGINAL', 'GRAYSCALE', 'MASK_BLACK')")
        return value

    @field_validator('polarity')
    def polarity_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['POLARITY_UNSPECIFIED', 'POSITIVE', 'NEGATIVE', 'BOTH']):
            raise ValueError("must be one of enum values ('POLARITY_UNSPECIFIED', 'POSITIVE', 'NEGATIVE', 'BOTH')")
        return value

    @field_validator('type')
    def type_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['TYPE_UNSPECIFIED', 'PIXELS', 'OUTLINES']):
            raise ValueError("must be one of enum values ('TYPE_UNSPECIFIED', 'PIXELS', 'OUTLINES')")
        return value

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of XPSVisualization from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of XPSVisualization from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "clipPercentLowerbound": obj.get("clipPercentLowerbound"),
            "clipPercentUpperbound": obj.get("clipPercentUpperbound"),
            "colorMap": obj.get("colorMap"),
            "overlayType": obj.get("overlayType"),
            "polarity": obj.get("polarity"),
            "type": obj.get("type")
        })
        return _obj


