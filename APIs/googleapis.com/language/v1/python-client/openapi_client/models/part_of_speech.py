# coding: utf-8

"""
    Cloud Natural Language API

    Provides natural language understanding technologies, such as sentiment analysis, entity recognition, entity sentiment analysis, and other text annotations, to developers.

    The version of the OpenAPI document: v1
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictStr, field_validator
from typing import Any, ClassVar, Dict, List, Optional
from typing import Optional, Set
from typing_extensions import Self

class PartOfSpeech(BaseModel):
    """
    Represents part of speech information for a token. Parts of speech are as defined in http://www.lrec-conf.org/proceedings/lrec2012/pdf/274_Paper.pdf
    """ # noqa: E501
    aspect: Optional[StrictStr] = Field(default=None, description="The grammatical aspect.")
    case: Optional[StrictStr] = Field(default=None, description="The grammatical case.")
    form: Optional[StrictStr] = Field(default=None, description="The grammatical form.")
    gender: Optional[StrictStr] = Field(default=None, description="The grammatical gender.")
    mood: Optional[StrictStr] = Field(default=None, description="The grammatical mood.")
    number: Optional[StrictStr] = Field(default=None, description="The grammatical number.")
    person: Optional[StrictStr] = Field(default=None, description="The grammatical person.")
    proper: Optional[StrictStr] = Field(default=None, description="The grammatical properness.")
    reciprocity: Optional[StrictStr] = Field(default=None, description="The grammatical reciprocity.")
    tag: Optional[StrictStr] = Field(default=None, description="The part of speech tag.")
    tense: Optional[StrictStr] = Field(default=None, description="The grammatical tense.")
    voice: Optional[StrictStr] = Field(default=None, description="The grammatical voice.")
    __properties: ClassVar[List[str]] = ["aspect", "case", "form", "gender", "mood", "number", "person", "proper", "reciprocity", "tag", "tense", "voice"]

    @field_validator('aspect')
    def aspect_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['ASPECT_UNKNOWN', 'PERFECTIVE', 'IMPERFECTIVE', 'PROGRESSIVE']):
            raise ValueError("must be one of enum values ('ASPECT_UNKNOWN', 'PERFECTIVE', 'IMPERFECTIVE', 'PROGRESSIVE')")
        return value

    @field_validator('case')
    def case_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['CASE_UNKNOWN', 'ACCUSATIVE', 'ADVERBIAL', 'COMPLEMENTIVE', 'DATIVE', 'GENITIVE', 'INSTRUMENTAL', 'LOCATIVE', 'NOMINATIVE', 'OBLIQUE', 'PARTITIVE', 'PREPOSITIONAL', 'REFLEXIVE_CASE', 'RELATIVE_CASE', 'VOCATIVE']):
            raise ValueError("must be one of enum values ('CASE_UNKNOWN', 'ACCUSATIVE', 'ADVERBIAL', 'COMPLEMENTIVE', 'DATIVE', 'GENITIVE', 'INSTRUMENTAL', 'LOCATIVE', 'NOMINATIVE', 'OBLIQUE', 'PARTITIVE', 'PREPOSITIONAL', 'REFLEXIVE_CASE', 'RELATIVE_CASE', 'VOCATIVE')")
        return value

    @field_validator('form')
    def form_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['FORM_UNKNOWN', 'ADNOMIAL', 'AUXILIARY', 'COMPLEMENTIZER', 'FINAL_ENDING', 'GERUND', 'REALIS', 'IRREALIS', 'SHORT', 'LONG', 'ORDER', 'SPECIFIC']):
            raise ValueError("must be one of enum values ('FORM_UNKNOWN', 'ADNOMIAL', 'AUXILIARY', 'COMPLEMENTIZER', 'FINAL_ENDING', 'GERUND', 'REALIS', 'IRREALIS', 'SHORT', 'LONG', 'ORDER', 'SPECIFIC')")
        return value

    @field_validator('gender')
    def gender_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['GENDER_UNKNOWN', 'FEMININE', 'MASCULINE', 'NEUTER']):
            raise ValueError("must be one of enum values ('GENDER_UNKNOWN', 'FEMININE', 'MASCULINE', 'NEUTER')")
        return value

    @field_validator('mood')
    def mood_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['MOOD_UNKNOWN', 'CONDITIONAL_MOOD', 'IMPERATIVE', 'INDICATIVE', 'INTERROGATIVE', 'JUSSIVE', 'SUBJUNCTIVE']):
            raise ValueError("must be one of enum values ('MOOD_UNKNOWN', 'CONDITIONAL_MOOD', 'IMPERATIVE', 'INDICATIVE', 'INTERROGATIVE', 'JUSSIVE', 'SUBJUNCTIVE')")
        return value

    @field_validator('number')
    def number_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['NUMBER_UNKNOWN', 'SINGULAR', 'PLURAL', 'DUAL']):
            raise ValueError("must be one of enum values ('NUMBER_UNKNOWN', 'SINGULAR', 'PLURAL', 'DUAL')")
        return value

    @field_validator('person')
    def person_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['PERSON_UNKNOWN', 'FIRST', 'SECOND', 'THIRD', 'REFLEXIVE_PERSON']):
            raise ValueError("must be one of enum values ('PERSON_UNKNOWN', 'FIRST', 'SECOND', 'THIRD', 'REFLEXIVE_PERSON')")
        return value

    @field_validator('proper')
    def proper_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['PROPER_UNKNOWN', 'PROPER', 'NOT_PROPER']):
            raise ValueError("must be one of enum values ('PROPER_UNKNOWN', 'PROPER', 'NOT_PROPER')")
        return value

    @field_validator('reciprocity')
    def reciprocity_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['RECIPROCITY_UNKNOWN', 'RECIPROCAL', 'NON_RECIPROCAL']):
            raise ValueError("must be one of enum values ('RECIPROCITY_UNKNOWN', 'RECIPROCAL', 'NON_RECIPROCAL')")
        return value

    @field_validator('tag')
    def tag_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['UNKNOWN', 'ADJ', 'ADP', 'ADV', 'CONJ', 'DET', 'NOUN', 'NUM', 'PRON', 'PRT', 'PUNCT', 'VERB', 'X', 'AFFIX']):
            raise ValueError("must be one of enum values ('UNKNOWN', 'ADJ', 'ADP', 'ADV', 'CONJ', 'DET', 'NOUN', 'NUM', 'PRON', 'PRT', 'PUNCT', 'VERB', 'X', 'AFFIX')")
        return value

    @field_validator('tense')
    def tense_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['TENSE_UNKNOWN', 'CONDITIONAL_TENSE', 'FUTURE', 'PAST', 'PRESENT', 'IMPERFECT', 'PLUPERFECT']):
            raise ValueError("must be one of enum values ('TENSE_UNKNOWN', 'CONDITIONAL_TENSE', 'FUTURE', 'PAST', 'PRESENT', 'IMPERFECT', 'PLUPERFECT')")
        return value

    @field_validator('voice')
    def voice_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['VOICE_UNKNOWN', 'ACTIVE', 'CAUSATIVE', 'PASSIVE']):
            raise ValueError("must be one of enum values ('VOICE_UNKNOWN', 'ACTIVE', 'CAUSATIVE', 'PASSIVE')")
        return value

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of PartOfSpeech from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of PartOfSpeech from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "aspect": obj.get("aspect"),
            "case": obj.get("case"),
            "form": obj.get("form"),
            "gender": obj.get("gender"),
            "mood": obj.get("mood"),
            "number": obj.get("number"),
            "person": obj.get("person"),
            "proper": obj.get("proper"),
            "reciprocity": obj.get("reciprocity"),
            "tag": obj.get("tag"),
            "tense": obj.get("tense"),
            "voice": obj.get("voice")
        })
        return _obj


