# coding: utf-8

"""
    Google Play Android Developer API

    Lets Android application developers access their Google Play accounts. At a high level, the expected workflow is to \"insert\" an Edit, make changes as necessary, and then \"commit\" it. 

    The version of the OpenAPI document: v3
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictStr, field_validator
from typing import Any, ClassVar, Dict, List, Optional
from openapi_client.models.in_app_product_listing import InAppProductListing
from openapi_client.models.managed_product_tax_and_compliance_settings import ManagedProductTaxAndComplianceSettings
from openapi_client.models.price import Price
from openapi_client.models.subscription_tax_and_compliance_settings import SubscriptionTaxAndComplianceSettings
from typing import Optional, Set
from typing_extensions import Self

class InAppProduct(BaseModel):
    """
    An in-app product. The resource for InappproductsService.
    """ # noqa: E501
    default_language: Optional[StrictStr] = Field(default=None, description="Default language of the localized data, as defined by BCP-47. e.g. \"en-US\".", alias="defaultLanguage")
    default_price: Optional[Price] = Field(default=None, alias="defaultPrice")
    grace_period: Optional[StrictStr] = Field(default=None, description="Grace period of the subscription, specified in ISO 8601 format. Allows developers to give their subscribers a grace period when the payment for the new recurrence period is declined. Acceptable values are P0D (zero days), P3D (three days), P7D (seven days), P14D (14 days), and P30D (30 days).", alias="gracePeriod")
    listings: Optional[Dict[str, InAppProductListing]] = Field(default=None, description="List of localized title and description data. Map key is the language of the localized data, as defined by BCP-47, e.g. \"en-US\".")
    managed_product_taxes_and_compliance_settings: Optional[ManagedProductTaxAndComplianceSettings] = Field(default=None, alias="managedProductTaxesAndComplianceSettings")
    package_name: Optional[StrictStr] = Field(default=None, description="Package name of the parent app.", alias="packageName")
    prices: Optional[Dict[str, Price]] = Field(default=None, description="Prices per buyer region. None of these can be zero, as in-app products are never free. Map key is region code, as defined by ISO 3166-2.")
    purchase_type: Optional[StrictStr] = Field(default=None, description="The type of the product, e.g. a recurring subscription.", alias="purchaseType")
    sku: Optional[StrictStr] = Field(default=None, description="Stock-keeping-unit (SKU) of the product, unique within an app.")
    status: Optional[StrictStr] = Field(default=None, description="The status of the product, e.g. whether it's active.")
    subscription_period: Optional[StrictStr] = Field(default=None, description="Subscription period, specified in ISO 8601 format. Acceptable values are P1W (one week), P1M (one month), P3M (three months), P6M (six months), and P1Y (one year).", alias="subscriptionPeriod")
    subscription_taxes_and_compliance_settings: Optional[SubscriptionTaxAndComplianceSettings] = Field(default=None, alias="subscriptionTaxesAndComplianceSettings")
    trial_period: Optional[StrictStr] = Field(default=None, description="Trial period, specified in ISO 8601 format. Acceptable values are anything between P7D (seven days) and P999D (999 days).", alias="trialPeriod")
    __properties: ClassVar[List[str]] = ["defaultLanguage", "defaultPrice", "gracePeriod", "listings", "managedProductTaxesAndComplianceSettings", "packageName", "prices", "purchaseType", "sku", "status", "subscriptionPeriod", "subscriptionTaxesAndComplianceSettings", "trialPeriod"]

    @field_validator('purchase_type')
    def purchase_type_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['purchaseTypeUnspecified', 'managedUser', 'subscription']):
            raise ValueError("must be one of enum values ('purchaseTypeUnspecified', 'managedUser', 'subscription')")
        return value

    @field_validator('status')
    def status_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['statusUnspecified', 'active', 'inactive']):
            raise ValueError("must be one of enum values ('statusUnspecified', 'active', 'inactive')")
        return value

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of InAppProduct from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of default_price
        if self.default_price:
            _dict['defaultPrice'] = self.default_price.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each value in listings (dict)
        _field_dict = {}
        if self.listings:
            for _key_listings in self.listings:
                if self.listings[_key_listings]:
                    _field_dict[_key_listings] = self.listings[_key_listings].to_dict()
            _dict['listings'] = _field_dict
        # override the default output from pydantic by calling `to_dict()` of managed_product_taxes_and_compliance_settings
        if self.managed_product_taxes_and_compliance_settings:
            _dict['managedProductTaxesAndComplianceSettings'] = self.managed_product_taxes_and_compliance_settings.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each value in prices (dict)
        _field_dict = {}
        if self.prices:
            for _key_prices in self.prices:
                if self.prices[_key_prices]:
                    _field_dict[_key_prices] = self.prices[_key_prices].to_dict()
            _dict['prices'] = _field_dict
        # override the default output from pydantic by calling `to_dict()` of subscription_taxes_and_compliance_settings
        if self.subscription_taxes_and_compliance_settings:
            _dict['subscriptionTaxesAndComplianceSettings'] = self.subscription_taxes_and_compliance_settings.to_dict()
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of InAppProduct from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "defaultLanguage": obj.get("defaultLanguage"),
            "defaultPrice": Price.from_dict(obj["defaultPrice"]) if obj.get("defaultPrice") is not None else None,
            "gracePeriod": obj.get("gracePeriod"),
            "listings": dict(
                (_k, InAppProductListing.from_dict(_v))
                for _k, _v in obj["listings"].items()
            )
            if obj.get("listings") is not None
            else None,
            "managedProductTaxesAndComplianceSettings": ManagedProductTaxAndComplianceSettings.from_dict(obj["managedProductTaxesAndComplianceSettings"]) if obj.get("managedProductTaxesAndComplianceSettings") is not None else None,
            "packageName": obj.get("packageName"),
            "prices": dict(
                (_k, Price.from_dict(_v))
                for _k, _v in obj["prices"].items()
            )
            if obj.get("prices") is not None
            else None,
            "purchaseType": obj.get("purchaseType"),
            "sku": obj.get("sku"),
            "status": obj.get("status"),
            "subscriptionPeriod": obj.get("subscriptionPeriod"),
            "subscriptionTaxesAndComplianceSettings": SubscriptionTaxAndComplianceSettings.from_dict(obj["subscriptionTaxesAndComplianceSettings"]) if obj.get("subscriptionTaxesAndComplianceSettings") is not None else None,
            "trialPeriod": obj.get("trialPeriod")
        })
        return _obj


