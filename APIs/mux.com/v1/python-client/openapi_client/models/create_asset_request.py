# coding: utf-8

"""
    Mux API

    Mux is how developers build online video. This API encompasses both Mux Video and Mux Data functionality to help you build your video-related projects better and faster than ever before.

    The version of the OpenAPI document: v1
    Contact: devex@mux.com
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictStr, field_validator
from typing import Any, ClassVar, Dict, List, Optional
from openapi_client.models.input_settings import InputSettings
from openapi_client.models.playback_policy import PlaybackPolicy
from typing import Optional, Set
from typing_extensions import Self

class CreateAssetRequest(BaseModel):
    """
    CreateAssetRequest
    """ # noqa: E501
    encoding_tier: Optional[StrictStr] = Field(default=None, description="The encoding tier informs the cost, quality, and available platform features for the asset. By default the `smart` encoding tier is used.")
    input: Optional[List[InputSettings]] = Field(default=None, description="An array of objects that each describe an input file to be used to create the asset. As a shortcut, input can also be a string URL for a file when only one input file is used. See `input[].url` for requirements.")
    master_access: Optional[StrictStr] = Field(default=None, description="Specify what level (if any) of support for master access. Master access can be enabled temporarily for your asset to be downloaded. See the [Download your videos guide](/guides/video/download-your-videos) for more information.")
    max_resolution_tier: Optional[StrictStr] = Field(default=None, description="Max resolution tier can be used to control the maximum `resolution_tier` your asset is encoded, stored, and streamed at. If not set, this defaults to `1080p`.")
    mp4_support: Optional[StrictStr] = Field(default=None, description="Specify what level (if any) of support for mp4 playback. In most cases you should use our default HLS-based streaming playback ({playback_id}.m3u8) which can automatically adjust to viewers' connection speeds, but an mp4 can be useful for some legacy devices or downloading for offline playback. See the [Download your videos guide](/guides/video/download-your-videos) for more information.")
    normalize_audio: Optional[StrictBool] = Field(default=False, description="Normalize the audio track loudness level. This parameter is only applicable to on-demand (not live) assets.")
    passthrough: Optional[StrictStr] = Field(default=None, description="Arbitrary user-supplied metadata that will be included in the asset details and related webhooks. Can be used to store your own ID for a video along with the asset. **Max: 255 characters**.")
    per_title_encode: Optional[StrictBool] = None
    playback_policy: Optional[List[PlaybackPolicy]] = Field(default=None, description="An array of playback policy names that you want applied to this asset and available through `playback_ids`. Options include: `\"public\"` (anyone with the playback URL can stream the asset). And `\"signed\"` (an additional access token is required to play the asset). If no playback_policy is set, the asset will have no playback IDs and will therefore not be playable. For simplicity, a single string name can be used in place of the array in the case of only one playback policy.")
    test: Optional[StrictBool] = Field(default=None, description="Marks the asset as a test asset when the value is set to true. A Test asset can help evaluate the Mux Video APIs without incurring any cost. There is no limit on number of test assets created. Test asset are watermarked with the Mux logo, limited to 10 seconds, deleted after 24 hrs.")
    __properties: ClassVar[List[str]] = ["encoding_tier", "input", "master_access", "max_resolution_tier", "mp4_support", "normalize_audio", "passthrough", "per_title_encode", "playback_policy", "test"]

    @field_validator('encoding_tier')
    def encoding_tier_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['smart', 'baseline']):
            raise ValueError("must be one of enum values ('smart', 'baseline')")
        return value

    @field_validator('master_access')
    def master_access_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['none', 'temporary']):
            raise ValueError("must be one of enum values ('none', 'temporary')")
        return value

    @field_validator('max_resolution_tier')
    def max_resolution_tier_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['1080p', '1440p', '2160p']):
            raise ValueError("must be one of enum values ('1080p', '1440p', '2160p')")
        return value

    @field_validator('mp4_support')
    def mp4_support_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['none', 'standard']):
            raise ValueError("must be one of enum values ('none', 'standard')")
        return value

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of CreateAssetRequest from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of each item in input (list)
        _items = []
        if self.input:
            for _item_input in self.input:
                if _item_input:
                    _items.append(_item_input.to_dict())
            _dict['input'] = _items
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of CreateAssetRequest from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "encoding_tier": obj.get("encoding_tier"),
            "input": [InputSettings.from_dict(_item) for _item in obj["input"]] if obj.get("input") is not None else None,
            "master_access": obj.get("master_access"),
            "max_resolution_tier": obj.get("max_resolution_tier"),
            "mp4_support": obj.get("mp4_support"),
            "normalize_audio": obj.get("normalize_audio") if obj.get("normalize_audio") is not None else False,
            "passthrough": obj.get("passthrough"),
            "per_title_encode": obj.get("per_title_encode"),
            "playback_policy": obj.get("playback_policy"),
            "test": obj.get("test")
        })
        return _obj


