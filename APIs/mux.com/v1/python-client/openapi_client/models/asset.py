# coding: utf-8

"""
    Mux API

    Mux is how developers build online video. This API encompasses both Mux Video and Mux Data functionality to help you build your video-related projects better and faster than ever before.

    The version of the OpenAPI document: v1
    Contact: devex@mux.com
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictFloat, StrictInt, StrictStr, field_validator
from typing import Any, ClassVar, Dict, List, Optional, Union
from openapi_client.models.asset_errors import AssetErrors
from openapi_client.models.asset_master import AssetMaster
from openapi_client.models.asset_non_standard_input_reasons import AssetNonStandardInputReasons
from openapi_client.models.asset_recording_times_inner import AssetRecordingTimesInner
from openapi_client.models.asset_static_renditions import AssetStaticRenditions
from openapi_client.models.playback_id import PlaybackID
from openapi_client.models.track import Track
from typing import Optional, Set
from typing_extensions import Self

class Asset(BaseModel):
    """
    Asset
    """ # noqa: E501
    aspect_ratio: Optional[StrictStr] = Field(default=None, description="The aspect ratio of the asset in the form of `width:height`, for example `16:9`.")
    created_at: Optional[StrictStr] = Field(default=None, description="Time the Asset was created, defined as a Unix timestamp (seconds since epoch).")
    duration: Optional[Union[StrictFloat, StrictInt]] = Field(default=None, description="The duration of the asset in seconds (max duration for a single asset is 12 hours).")
    encoding_tier: Optional[StrictStr] = Field(default=None, description="The encoding tier informs the cost, quality, and available platform features for the asset. By default the `smart` encoding tier is used.")
    errors: Optional[AssetErrors] = None
    id: Optional[StrictStr] = Field(default=None, description="Unique identifier for the Asset. Max 255 characters.")
    is_live: Optional[StrictBool] = Field(default=None, description="Indicates whether the live stream that created this asset is currently `active` and not in `idle` state. This is an optional parameter added when the asset is created from a live stream.")
    live_stream_id: Optional[StrictStr] = Field(default=None, description="Unique identifier for the live stream. This is an optional parameter added when the asset is created from a live stream.")
    master: Optional[AssetMaster] = None
    master_access: Optional[StrictStr] = 'none'
    max_resolution_tier: Optional[StrictStr] = Field(default=None, description="Max resolution tier can be used to control the maximum `resolution_tier` your asset is encoded, stored, and streamed at. If not set, this defaults to `1080p`.")
    max_stored_frame_rate: Optional[Union[StrictFloat, StrictInt]] = Field(default=None, description="The maximum frame rate that has been stored for the asset. The asset may be delivered at lower frame rates depending on the device and bandwidth, however it cannot be delivered at a higher value than is stored. This field may return -1 if the frame rate of the input cannot be reliably determined.")
    max_stored_resolution: Optional[StrictStr] = Field(default=None, description="This field is deprecated. Please use `resolution_tier` instead. The maximum resolution that has been stored for the asset. The asset may be delivered at lower resolutions depending on the device and bandwidth, however it cannot be delivered at a higher value than is stored.")
    mp4_support: Optional[StrictStr] = 'none'
    non_standard_input_reasons: Optional[AssetNonStandardInputReasons] = None
    normalize_audio: Optional[StrictBool] = Field(default=False, description="Normalize the audio track loudness level. This parameter is only applicable to on-demand (not live) assets.")
    passthrough: Optional[StrictStr] = Field(default=None, description="Arbitrary user-supplied metadata set for the asset. Max 255 characters.")
    per_title_encode: Optional[StrictBool] = None
    playback_ids: Optional[List[PlaybackID]] = Field(default=None, description="An array of Playback ID objects. Use these to create HLS playback URLs. See [Play your videos](https://docs.mux.com/guides/video/play-your-videos) for more details.")
    recording_times: Optional[List[AssetRecordingTimesInner]] = Field(default=None, description="An array of individual live stream recording sessions. A recording session is created on each encoder connection during the live stream. Additionally any time slate media is inserted during brief interruptions in the live stream media or times when the live streaming software disconnects, a recording session representing the slate media will be added with a \"slate\" type.")
    resolution_tier: Optional[StrictStr] = Field(default=None, description="The resolution tier that the asset was ingested at, affecting billing for ingest & storage. This field also represents the highest resolution tier that the content can be delivered at, however the actual resolution may be lower depending on the device, bandwidth, and exact resolution of the uploaded asset.")
    source_asset_id: Optional[StrictStr] = Field(default=None, description="Asset Identifier of the video used as the source for creating the clip.")
    static_renditions: Optional[AssetStaticRenditions] = None
    status: Optional[StrictStr] = Field(default=None, description="The status of the asset.")
    test: Optional[StrictBool] = Field(default=None, description="True means this live stream is a test asset. A test asset can help evaluate the Mux Video APIs without incurring any cost. There is no limit on number of test assets created. Test assets are watermarked with the Mux logo, limited to 10 seconds, and deleted after 24 hrs.")
    tracks: Optional[List[Track]] = Field(default=None, description="The individual media tracks that make up an asset.")
    upload_id: Optional[StrictStr] = Field(default=None, description="Unique identifier for the Direct Upload. This is an optional parameter added when the asset is created from a direct upload.")
    __properties: ClassVar[List[str]] = ["aspect_ratio", "created_at", "duration", "encoding_tier", "errors", "id", "is_live", "live_stream_id", "master", "master_access", "max_resolution_tier", "max_stored_frame_rate", "max_stored_resolution", "mp4_support", "non_standard_input_reasons", "normalize_audio", "passthrough", "per_title_encode", "playback_ids", "recording_times", "resolution_tier", "source_asset_id", "static_renditions", "status", "test", "tracks", "upload_id"]

    @field_validator('encoding_tier')
    def encoding_tier_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['smart', 'baseline']):
            raise ValueError("must be one of enum values ('smart', 'baseline')")
        return value

    @field_validator('master_access')
    def master_access_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['temporary', 'none']):
            raise ValueError("must be one of enum values ('temporary', 'none')")
        return value

    @field_validator('max_resolution_tier')
    def max_resolution_tier_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['1080p', '1440p', '2160p']):
            raise ValueError("must be one of enum values ('1080p', '1440p', '2160p')")
        return value

    @field_validator('max_stored_resolution')
    def max_stored_resolution_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['Audio only', 'SD', 'HD', 'FHD', 'UHD']):
            raise ValueError("must be one of enum values ('Audio only', 'SD', 'HD', 'FHD', 'UHD')")
        return value

    @field_validator('mp4_support')
    def mp4_support_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['standard', 'none']):
            raise ValueError("must be one of enum values ('standard', 'none')")
        return value

    @field_validator('resolution_tier')
    def resolution_tier_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['audio-only', '720p', '1080p', '1440p', '2160p']):
            raise ValueError("must be one of enum values ('audio-only', '720p', '1080p', '1440p', '2160p')")
        return value

    @field_validator('status')
    def status_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['preparing', 'ready', 'errored']):
            raise ValueError("must be one of enum values ('preparing', 'ready', 'errored')")
        return value

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of Asset from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of errors
        if self.errors:
            _dict['errors'] = self.errors.to_dict()
        # override the default output from pydantic by calling `to_dict()` of master
        if self.master:
            _dict['master'] = self.master.to_dict()
        # override the default output from pydantic by calling `to_dict()` of non_standard_input_reasons
        if self.non_standard_input_reasons:
            _dict['non_standard_input_reasons'] = self.non_standard_input_reasons.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in playback_ids (list)
        _items = []
        if self.playback_ids:
            for _item_playback_ids in self.playback_ids:
                if _item_playback_ids:
                    _items.append(_item_playback_ids.to_dict())
            _dict['playback_ids'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in recording_times (list)
        _items = []
        if self.recording_times:
            for _item_recording_times in self.recording_times:
                if _item_recording_times:
                    _items.append(_item_recording_times.to_dict())
            _dict['recording_times'] = _items
        # override the default output from pydantic by calling `to_dict()` of static_renditions
        if self.static_renditions:
            _dict['static_renditions'] = self.static_renditions.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in tracks (list)
        _items = []
        if self.tracks:
            for _item_tracks in self.tracks:
                if _item_tracks:
                    _items.append(_item_tracks.to_dict())
            _dict['tracks'] = _items
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of Asset from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "aspect_ratio": obj.get("aspect_ratio"),
            "created_at": obj.get("created_at"),
            "duration": obj.get("duration"),
            "encoding_tier": obj.get("encoding_tier"),
            "errors": AssetErrors.from_dict(obj["errors"]) if obj.get("errors") is not None else None,
            "id": obj.get("id"),
            "is_live": obj.get("is_live"),
            "live_stream_id": obj.get("live_stream_id"),
            "master": AssetMaster.from_dict(obj["master"]) if obj.get("master") is not None else None,
            "master_access": obj.get("master_access") if obj.get("master_access") is not None else 'none',
            "max_resolution_tier": obj.get("max_resolution_tier"),
            "max_stored_frame_rate": obj.get("max_stored_frame_rate"),
            "max_stored_resolution": obj.get("max_stored_resolution"),
            "mp4_support": obj.get("mp4_support") if obj.get("mp4_support") is not None else 'none',
            "non_standard_input_reasons": AssetNonStandardInputReasons.from_dict(obj["non_standard_input_reasons"]) if obj.get("non_standard_input_reasons") is not None else None,
            "normalize_audio": obj.get("normalize_audio") if obj.get("normalize_audio") is not None else False,
            "passthrough": obj.get("passthrough"),
            "per_title_encode": obj.get("per_title_encode"),
            "playback_ids": [PlaybackID.from_dict(_item) for _item in obj["playback_ids"]] if obj.get("playback_ids") is not None else None,
            "recording_times": [AssetRecordingTimesInner.from_dict(_item) for _item in obj["recording_times"]] if obj.get("recording_times") is not None else None,
            "resolution_tier": obj.get("resolution_tier"),
            "source_asset_id": obj.get("source_asset_id"),
            "static_renditions": AssetStaticRenditions.from_dict(obj["static_renditions"]) if obj.get("static_renditions") is not None else None,
            "status": obj.get("status"),
            "test": obj.get("test"),
            "tracks": [Track.from_dict(_item) for _item in obj["tracks"]] if obj.get("tracks") is not None else None,
            "upload_id": obj.get("upload_id")
        })
        return _obj


