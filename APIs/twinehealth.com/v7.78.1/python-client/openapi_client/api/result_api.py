# coding: utf-8

"""
    Fitbit Plus API

    # Overview The Fitbit Plus API is a RESTful API. The requests and responses are formated according to the [JSON API](http://jsonapi.org/format/1.0/) specification.  In addition to this documentation, we also provide an [OpenAPI](https://github.com/OAI/OpenAPI-Specification/blob/master/versions/2.0.md) \"yaml\" file describing the API: [Fitbit Plus API Specification](swagger.yaml).  # Authentication Authentication for the Fitbit Plus API is based on the [OAuth 2.0 Authorization Framework](https://tools.ietf.org/html/rfc6749). Fitbit Plus currently supports grant types of **client_credentials** and **refresh_token**.  See [POST /oauth/token](#operation/createToken) for details on the request and response formats. <!-- ReDoc-Inject: <security-definitions> -->  ## Building Integrations We will provide customers with unique client credentials for each application/integration they build, allowing us to enforce appropriate access controls and monitor API usage. The client credentials will be scoped to the organization, and allow full access to all patients and related data within that organization.  These credentials are appropriate for creating an integration that does one of the following:  - background reporting/analysis  - synchronizing data with another system (such as an EMR)  The API credentials and oauth flows we currently support are **not** well suited for creating a user-facing application that allows a user (patient, coach, or admin) to login and have access to data which is appropriate to that specific user. It is possible to build such an application, but it is not possible to use Fitbit Plus as a federated identity provider. You would need to have a separate means of verifying a user's identity. We do not currently support the required password-based oauth flow to make this possible.  # Paging The Fitbit Plus API supports two different pagination strategies for GET collection endpoints.  #### Skip-based paging  Skip-based paging uses the query parameters `page[size]` and `page[number]` to specify the max number of resources returned and the page number. We default to skip-based paging if there are no page parameters. The response will include a `links` object containing links to the first, last, prev, and next pages of data.  If the contents of the collection change while you are iterating through the collection, you will see duplicate or missing documents. For example, if you are iterating through the `calender_event` resource via `GET /pub/calendar_event?sort=start_at&page[size]=50&page[number]=1`, and a new `calendar_event` is created that has a `start_at` value before the first `calendar_event`, when you fetch the next page at `GET /pub/calendar_event?sort=start_at&page[size]=50&page[number]=2`, the first entry in the second response will be a duplicate of the last entry in the first response.  #### Cursor-based paging Cursor-based paging uses the query parameters `page[limit]` and `page[after]` to specify the max number of entries returned and identify where to begin the next page. Add `page[limit]` to the parameters to use cursor-based paging. The response will include a `links` object containing a link to the next page of data, if the next page exists.  Cursor-based paging is not subject to duplication if new resources are added to the collection. For example, if you are iterating through the `calender_event` resource via `GET /pub/calendar_event?sort=start_at&page[limit]=50`, and a new `calendar_event` is created that has a `start_at` value before the first `calendar_event`, you will not see a duplicate entry when you fetch the next page at `GET /pub/calendar_event?sort=start_at&page[limit]=50&page[after]=<cursor>`.  We encourage the use of cursor-based paging for performance reasons.  In either form of paging, you can determine whether any resources were missed by comparing the number of fetched resources against `meta.count`. Set `page[size]` or `page[limit]` to 0 to get only the count.  It is not valid to mix the two strategies. 

    The version of the OpenAPI document: v7.78.1
    Contact: apiteam@twinehealth.com
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501

import warnings
from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
from typing import Any, Dict, List, Optional, Tuple, Union
from typing_extensions import Annotated

from pydantic import Field, StrictInt, StrictStr
from typing import Optional
from typing_extensions import Annotated
from openapi_client.models.fetch_patient_health_result_response import FetchPatientHealthResultResponse

from openapi_client.api_client import ApiClient, RequestSerialized
from openapi_client.api_response import ApiResponse
from openapi_client.rest import RESTResponseType


class ResultApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client


    @validate_call
    def fetch_patient_health_result(
        self,
        id: Annotated[StrictStr, Field(description="Patient health result identifier")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> FetchPatientHealthResultResponse:
        """Get a patient health result

        Get patient health result by id.

        :param id: Patient health result identifier (required)
        :type id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._fetch_patient_health_result_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FetchPatientHealthResultResponse",
            '401': "FetchErrorResponse",
            '403': "FetchErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def fetch_patient_health_result_with_http_info(
        self,
        id: Annotated[StrictStr, Field(description="Patient health result identifier")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[FetchPatientHealthResultResponse]:
        """Get a patient health result

        Get patient health result by id.

        :param id: Patient health result identifier (required)
        :type id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._fetch_patient_health_result_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FetchPatientHealthResultResponse",
            '401': "FetchErrorResponse",
            '403': "FetchErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def fetch_patient_health_result_without_preload_content(
        self,
        id: Annotated[StrictStr, Field(description="Patient health result identifier")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get a patient health result

        Get patient health result by id.

        :param id: Patient health result identifier (required)
        :type id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._fetch_patient_health_result_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FetchPatientHealthResultResponse",
            '401': "FetchErrorResponse",
            '403': "FetchErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _fetch_patient_health_result_serialize(
        self,
        id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/vnd.api+json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/result/{id}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def fetch_patient_health_results(
        self,
        filter_patient: Annotated[StrictStr, Field(description="Filter the patient health results for a specified patient")],
        filter_actions: Annotated[Optional[StrictStr], Field(description="A comma-separated list of action identifiers")] = None,
        filter_start_at: Annotated[Optional[StrictStr], Field(description="Filter results that occurred after the passed ISO date and time string")] = None,
        filter_end_at: Annotated[Optional[StrictStr], Field(description="Filter results that occurred before the passed ISO date and time string")] = None,
        filter_threads: Annotated[Optional[StrictStr], Field(description="A comma-separated list of thread identifiers")] = None,
        filter_created_at: Annotated[Optional[StrictStr], Field(description="The start (inclusive) and end (exclusive) dates are ISO date and time strings separated by `..`. Example for results created in November 2017 (America/New_York): `filter[created_at]=2017-11-01T00:00:00-04:00..2017-12-01T00:00:00-05:00` ")] = None,
        filter_updated_at: Annotated[Optional[StrictStr], Field(description="The start (inclusive) and end (exclusive) dates are ISO date and time strings separated by `..`. Example for results updated in November 2017 (America/New_York): `filter[updated_at]=2017-11-01T00:00:00-04:00..2017-12-01T00:00:00-05:00` ")] = None,
        page_number: Annotated[Optional[StrictInt], Field(description="Page number")] = None,
        page_size: Annotated[Optional[Annotated[int, Field(le=50, strict=True, ge=0)]], Field(description="Page size")] = None,
        page_limit: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Page limit")] = None,
        page_after: Annotated[Optional[StrictStr], Field(description="Page cursor")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> FetchPatientHealthResultResponse:
        """List patient health results

        Get a list of patient health results.

        :param filter_patient: Filter the patient health results for a specified patient (required)
        :type filter_patient: str
        :param filter_actions: A comma-separated list of action identifiers
        :type filter_actions: str
        :param filter_start_at: Filter results that occurred after the passed ISO date and time string
        :type filter_start_at: str
        :param filter_end_at: Filter results that occurred before the passed ISO date and time string
        :type filter_end_at: str
        :param filter_threads: A comma-separated list of thread identifiers
        :type filter_threads: str
        :param filter_created_at: The start (inclusive) and end (exclusive) dates are ISO date and time strings separated by `..`. Example for results created in November 2017 (America/New_York): `filter[created_at]=2017-11-01T00:00:00-04:00..2017-12-01T00:00:00-05:00` 
        :type filter_created_at: str
        :param filter_updated_at: The start (inclusive) and end (exclusive) dates are ISO date and time strings separated by `..`. Example for results updated in November 2017 (America/New_York): `filter[updated_at]=2017-11-01T00:00:00-04:00..2017-12-01T00:00:00-05:00` 
        :type filter_updated_at: str
        :param page_number: Page number
        :type page_number: int
        :param page_size: Page size
        :type page_size: int
        :param page_limit: Page limit
        :type page_limit: int
        :param page_after: Page cursor
        :type page_after: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._fetch_patient_health_results_serialize(
            filter_patient=filter_patient,
            filter_actions=filter_actions,
            filter_start_at=filter_start_at,
            filter_end_at=filter_end_at,
            filter_threads=filter_threads,
            filter_created_at=filter_created_at,
            filter_updated_at=filter_updated_at,
            page_number=page_number,
            page_size=page_size,
            page_limit=page_limit,
            page_after=page_after,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FetchPatientHealthResultResponse",
            '401': "FetchErrorResponse",
            '403': "FetchErrorResponse",
            '409': "FetchErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def fetch_patient_health_results_with_http_info(
        self,
        filter_patient: Annotated[StrictStr, Field(description="Filter the patient health results for a specified patient")],
        filter_actions: Annotated[Optional[StrictStr], Field(description="A comma-separated list of action identifiers")] = None,
        filter_start_at: Annotated[Optional[StrictStr], Field(description="Filter results that occurred after the passed ISO date and time string")] = None,
        filter_end_at: Annotated[Optional[StrictStr], Field(description="Filter results that occurred before the passed ISO date and time string")] = None,
        filter_threads: Annotated[Optional[StrictStr], Field(description="A comma-separated list of thread identifiers")] = None,
        filter_created_at: Annotated[Optional[StrictStr], Field(description="The start (inclusive) and end (exclusive) dates are ISO date and time strings separated by `..`. Example for results created in November 2017 (America/New_York): `filter[created_at]=2017-11-01T00:00:00-04:00..2017-12-01T00:00:00-05:00` ")] = None,
        filter_updated_at: Annotated[Optional[StrictStr], Field(description="The start (inclusive) and end (exclusive) dates are ISO date and time strings separated by `..`. Example for results updated in November 2017 (America/New_York): `filter[updated_at]=2017-11-01T00:00:00-04:00..2017-12-01T00:00:00-05:00` ")] = None,
        page_number: Annotated[Optional[StrictInt], Field(description="Page number")] = None,
        page_size: Annotated[Optional[Annotated[int, Field(le=50, strict=True, ge=0)]], Field(description="Page size")] = None,
        page_limit: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Page limit")] = None,
        page_after: Annotated[Optional[StrictStr], Field(description="Page cursor")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[FetchPatientHealthResultResponse]:
        """List patient health results

        Get a list of patient health results.

        :param filter_patient: Filter the patient health results for a specified patient (required)
        :type filter_patient: str
        :param filter_actions: A comma-separated list of action identifiers
        :type filter_actions: str
        :param filter_start_at: Filter results that occurred after the passed ISO date and time string
        :type filter_start_at: str
        :param filter_end_at: Filter results that occurred before the passed ISO date and time string
        :type filter_end_at: str
        :param filter_threads: A comma-separated list of thread identifiers
        :type filter_threads: str
        :param filter_created_at: The start (inclusive) and end (exclusive) dates are ISO date and time strings separated by `..`. Example for results created in November 2017 (America/New_York): `filter[created_at]=2017-11-01T00:00:00-04:00..2017-12-01T00:00:00-05:00` 
        :type filter_created_at: str
        :param filter_updated_at: The start (inclusive) and end (exclusive) dates are ISO date and time strings separated by `..`. Example for results updated in November 2017 (America/New_York): `filter[updated_at]=2017-11-01T00:00:00-04:00..2017-12-01T00:00:00-05:00` 
        :type filter_updated_at: str
        :param page_number: Page number
        :type page_number: int
        :param page_size: Page size
        :type page_size: int
        :param page_limit: Page limit
        :type page_limit: int
        :param page_after: Page cursor
        :type page_after: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._fetch_patient_health_results_serialize(
            filter_patient=filter_patient,
            filter_actions=filter_actions,
            filter_start_at=filter_start_at,
            filter_end_at=filter_end_at,
            filter_threads=filter_threads,
            filter_created_at=filter_created_at,
            filter_updated_at=filter_updated_at,
            page_number=page_number,
            page_size=page_size,
            page_limit=page_limit,
            page_after=page_after,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FetchPatientHealthResultResponse",
            '401': "FetchErrorResponse",
            '403': "FetchErrorResponse",
            '409': "FetchErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def fetch_patient_health_results_without_preload_content(
        self,
        filter_patient: Annotated[StrictStr, Field(description="Filter the patient health results for a specified patient")],
        filter_actions: Annotated[Optional[StrictStr], Field(description="A comma-separated list of action identifiers")] = None,
        filter_start_at: Annotated[Optional[StrictStr], Field(description="Filter results that occurred after the passed ISO date and time string")] = None,
        filter_end_at: Annotated[Optional[StrictStr], Field(description="Filter results that occurred before the passed ISO date and time string")] = None,
        filter_threads: Annotated[Optional[StrictStr], Field(description="A comma-separated list of thread identifiers")] = None,
        filter_created_at: Annotated[Optional[StrictStr], Field(description="The start (inclusive) and end (exclusive) dates are ISO date and time strings separated by `..`. Example for results created in November 2017 (America/New_York): `filter[created_at]=2017-11-01T00:00:00-04:00..2017-12-01T00:00:00-05:00` ")] = None,
        filter_updated_at: Annotated[Optional[StrictStr], Field(description="The start (inclusive) and end (exclusive) dates are ISO date and time strings separated by `..`. Example for results updated in November 2017 (America/New_York): `filter[updated_at]=2017-11-01T00:00:00-04:00..2017-12-01T00:00:00-05:00` ")] = None,
        page_number: Annotated[Optional[StrictInt], Field(description="Page number")] = None,
        page_size: Annotated[Optional[Annotated[int, Field(le=50, strict=True, ge=0)]], Field(description="Page size")] = None,
        page_limit: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Page limit")] = None,
        page_after: Annotated[Optional[StrictStr], Field(description="Page cursor")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """List patient health results

        Get a list of patient health results.

        :param filter_patient: Filter the patient health results for a specified patient (required)
        :type filter_patient: str
        :param filter_actions: A comma-separated list of action identifiers
        :type filter_actions: str
        :param filter_start_at: Filter results that occurred after the passed ISO date and time string
        :type filter_start_at: str
        :param filter_end_at: Filter results that occurred before the passed ISO date and time string
        :type filter_end_at: str
        :param filter_threads: A comma-separated list of thread identifiers
        :type filter_threads: str
        :param filter_created_at: The start (inclusive) and end (exclusive) dates are ISO date and time strings separated by `..`. Example for results created in November 2017 (America/New_York): `filter[created_at]=2017-11-01T00:00:00-04:00..2017-12-01T00:00:00-05:00` 
        :type filter_created_at: str
        :param filter_updated_at: The start (inclusive) and end (exclusive) dates are ISO date and time strings separated by `..`. Example for results updated in November 2017 (America/New_York): `filter[updated_at]=2017-11-01T00:00:00-04:00..2017-12-01T00:00:00-05:00` 
        :type filter_updated_at: str
        :param page_number: Page number
        :type page_number: int
        :param page_size: Page size
        :type page_size: int
        :param page_limit: Page limit
        :type page_limit: int
        :param page_after: Page cursor
        :type page_after: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._fetch_patient_health_results_serialize(
            filter_patient=filter_patient,
            filter_actions=filter_actions,
            filter_start_at=filter_start_at,
            filter_end_at=filter_end_at,
            filter_threads=filter_threads,
            filter_created_at=filter_created_at,
            filter_updated_at=filter_updated_at,
            page_number=page_number,
            page_size=page_size,
            page_limit=page_limit,
            page_after=page_after,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FetchPatientHealthResultResponse",
            '401': "FetchErrorResponse",
            '403': "FetchErrorResponse",
            '409': "FetchErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _fetch_patient_health_results_serialize(
        self,
        filter_patient,
        filter_actions,
        filter_start_at,
        filter_end_at,
        filter_threads,
        filter_created_at,
        filter_updated_at,
        page_number,
        page_size,
        page_limit,
        page_after,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if filter_patient is not None:
            
            _query_params.append(('filter[patient]', filter_patient))
            
        if filter_actions is not None:
            
            _query_params.append(('filter[actions]', filter_actions))
            
        if filter_start_at is not None:
            
            _query_params.append(('filter[start_at]', filter_start_at))
            
        if filter_end_at is not None:
            
            _query_params.append(('filter[end_at]', filter_end_at))
            
        if filter_threads is not None:
            
            _query_params.append(('filter[threads]', filter_threads))
            
        if filter_created_at is not None:
            
            _query_params.append(('filter[created_at]', filter_created_at))
            
        if filter_updated_at is not None:
            
            _query_params.append(('filter[updated_at]', filter_updated_at))
            
        if page_number is not None:
            
            _query_params.append(('page[number]', page_number))
            
        if page_size is not None:
            
            _query_params.append(('page[size]', page_size))
            
        if page_limit is not None:
            
            _query_params.append(('page[limit]', page_limit))
            
        if page_after is not None:
            
            _query_params.append(('page[after]', page_after))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/vnd.api+json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/result',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )


