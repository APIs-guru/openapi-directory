# coding: utf-8

"""
    Negotiation API

    The <b>Negotiations API</b> gives sellers the ability to proactively send discount offers to buyers who have shown an \"interest\" in their listings.  <br><br>By sending buyers discount offers on listings where they have shown an interest, sellers can increase the velocity of their sales.  <br><br>There are various ways for a buyer to show <i>interest </i> in a listing. For example, if a buyer adds the listing to their <b>Watch</b> list, or if they add the listing to their shopping cart and later abandon the cart, they are deemed to have shown an interest in the listing.  <br><br>In the offers that sellers send, they can discount their listings by either a percentage off the listing price, or they can set a new discounted price that is lower than the original listing price.  <br><br>For details about how seller offers work, see <a href=\"/api-docs/sell/static/marketing/offers-to-buyers.html\" title=\"Selling Integration Guide\">Sending offers to buyers</a>.

    The version of the OpenAPI document: v1.1.0
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictStr
from typing import Any, ClassVar, Dict, List, Optional
from openapi_client.models.offered_item import OfferedItem
from openapi_client.models.time_duration import TimeDuration
from typing import Optional, Set
from typing_extensions import Self

class CreateOffersRequest(BaseModel):
    """
    This complex type contains the fields needed to create an offer to a buyer that is initiated by the seller.
    """ # noqa: E501
    allow_counter_offer: Optional[StrictBool] = Field(default=None, description="If set to true, the buyer is allowed to make a counter-offer to the seller's offer. Note: Currently, you must set this field to false; counter-offers are not supported in this release. Default: false", alias="allowCounterOffer")
    message: Optional[StrictStr] = Field(default=None, description="A seller-defined message related to the offer being made. This message is sent to the list of &quot;interested&quot; buyers. To increase the conversion rate of the offers a seller makes to buyers, eBay recommends you always add a customized message to your offers. Maximum length: 2,000 characters")
    offer_duration: Optional[TimeDuration] = Field(default=None, alias="offerDuration")
    offered_items: Optional[List[OfferedItem]] = Field(default=None, description="An array of objects where each object contains the details of an offer and the ID of the listing on which the offer is being made. Note that the service does not currently support the creation of multiple offers with a single call to sendOfferToInterestedBuyer. With this, each request can target only one listing at a time and you must populate this array with a single element that contains the details of one offer.", alias="offeredItems")
    __properties: ClassVar[List[str]] = ["allowCounterOffer", "message", "offerDuration", "offeredItems"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of CreateOffersRequest from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of offer_duration
        if self.offer_duration:
            _dict['offerDuration'] = self.offer_duration.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in offered_items (list)
        _items = []
        if self.offered_items:
            for _item_offered_items in self.offered_items:
                if _item_offered_items:
                    _items.append(_item_offered_items.to_dict())
            _dict['offeredItems'] = _items
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of CreateOffersRequest from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "allowCounterOffer": obj.get("allowCounterOffer"),
            "message": obj.get("message"),
            "offerDuration": TimeDuration.from_dict(obj["offerDuration"]) if obj.get("offerDuration") is not None else None,
            "offeredItems": [OfferedItem.from_dict(_item) for _item in obj["offeredItems"]] if obj.get("offeredItems") is not None else None
        })
        return _obj


