# coding: utf-8

"""
    Logistics API

    <span class=\"tablenote\"><b>Note:</b> This is a <a href=\"https://developer.ebay.com/api-docs/static/versioning.html#limited\" target=\"_blank\"> <img src=\"/cms/img/docs/partners-api.svg\" class=\"legend-icon partners-icon\" title=\"Limited Release\"  alt=\"Limited Release\" />(Limited Release)</a> API available only to select developers approved by business units.</span><br /><br />The <b>Logistics API</b> resources offer the following capabilities: <ul><li><b>shipping_quote</b> &ndash; Consolidates into a list a set of live shipping rates, or quotes, from which you can select a rate to ship a package.</li> <li><b>shipment</b> &ndash; Creates a \"shipment\" for the selected shipping rate.</li></ul> Call <b>createShippingQuote</b> to get a list of live shipping rates. The rates returned are all valid for a specific time window and all quoted prices are at eBay-negotiated rates. <br><br>Select one of the live rates and using its associated <b>rateId</b>, create a \"shipment\" for the package by calling <b>createFromShippingQuote</b>. Creating a shipment completes an agreement, and the cost of the base service and any added shipping options are summed into the returned <b>totalShippingCost</b> value. This action also generates a shipping label that you can use to ship the package.  The total cost of the shipment is incurred when the package is shipped using the supplied shipping label.  <p class=\"tablenote\"><b>Important!</b> Sellers must set up a payment method via their eBay account before they can use the methods in this API to create a shipment and the associated shipping label.</p>

    The version of the OpenAPI document: v1_beta.0.0
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictStr
from typing import Any, ClassVar, Dict, List, Optional
from openapi_client.models.additional_option import AdditionalOption
from openapi_client.models.amount import Amount
from openapi_client.models.pickup_slot import PickupSlot
from typing import Optional, Set
from typing_extensions import Self

class Rate(BaseModel):
    """
    This complex type contains live quote information about a shipping service that's available for a given shipping quote request, including the shipping carrier and service, delivery window, shipping cost, and additional shipping options.
    """ # noqa: E501
    additional_options: Optional[List[AdditionalOption]] = Field(default=None, description="Contains service and pricing information for one or more shipping options that are offered by the carrier and can be purchased in addition to the base shipping service provided by this rate. Shipping options can include items such as <code>INSURANCE</code> and <code>SIGNATURE</code>.", alias="additionalOptions")
    base_shipping_cost: Optional[Amount] = Field(default=None, alias="baseShippingCost")
    destination_time_zone: Optional[StrictStr] = Field(default=None, description="The name of the time zone region, as defined in the <a href=\"http://www.iana.org/time-zones\"  target=\"_blank\">IANA Time Zone Database</a>, to which the package is being shipped.  <br><br>Delivery dates are calculated relative to this time zone.  <br><br><span class=\"tablenote\"><strong>Note:</strong> This is different from a Coordinated Universal Time (UTC) offset. For example, the <i>America/Los_Angeles</i> time zone identifies a region with the UTC standard time offset of <code>-08:00</code>, but so do several other time zones, including <i>America/Tijuana</i>,<i>America/Dawson</i>, and <i>Pacific/Pitcairn</i>.</span>", alias="destinationTimeZone")
    max_estimated_delivery_date: Optional[StrictStr] = Field(default=None, description="The latest stated date and time the shipment will be delivered at this rate.  <br><br>The time stamp is formatted as an <a href=\"https://www.iso.org/iso-8601-date-and-time-format.html\" title=\"https://www.iso.org\" target=\"_blank\">ISO 8601</a> string, which is based on the 24-hour Coordinated Universal Time (UTC) clock.  <br><br><b>Format:</b> <code>[YYYY]-[MM]-[DD]T[HH]:[MM]:[SS].[SSS]Z</code> <br><b>Example:</b> <code>2018-08-20T07:09:00.000Z</code>", alias="maxEstimatedDeliveryDate")
    min_estimated_delivery_date: Optional[StrictStr] = Field(default=None, description="The estimated earliest date and time the shipment will be delivered at this rate. The time stamp is formatted as an ISO 8601 UTC string.", alias="minEstimatedDeliveryDate")
    pickup_networks: Optional[List[StrictStr]] = Field(default=None, description="A list of pickup networks compatible with the shipping service.", alias="pickupNetworks")
    pickup_slots: Optional[List[PickupSlot]] = Field(default=None, description="A list of available pickup slots for the package.", alias="pickupSlots")
    pickup_type: Optional[StrictStr] = Field(default=None, description="The type of pickup or drop-off service associated with the <b>pickupSlots</b> time frames. For implementation help, refer to <a href='https://developer.ebay.com/api-docs/sell/logistics/types/api:PickupTypeEnum'>eBay API documentation</a>", alias="pickupType")
    rate_id: Optional[StrictStr] = Field(default=None, description="The unique eBay-assigned ID for this shipping rate.", alias="rateId")
    rate_recommendation: Optional[List[StrictStr]] = Field(default=None, description="A list of reasons this rate is recommended. Available values are: <ul> <li><code>BUYER_CHOSEN</code> &mdash; The rate meets or exceeds the requirements of the buyer's preferred shipping option.</li> <li><code>CHEAPEST_ON_TIME</code> &mdash; The rate is the cheapest rate available that will provide delivery within the seller's time frame commitment.</li>  <li><code>EBAY_PLUS_OK</code> &mdash; The rate complies with the shipping requirements of the eBay Plus program.</li> <li><code>FASTEST_ON_TIME</code> &mdash; The rate has the fastest shipping time, and will provide delivery within the seller's time frame commitment.</li> <li><code>GUARANTEED_DELIVERY_OK</code> &mdash; The rate complies with the shipping requirements of the eBay Guaranteed Delivery program.</li></ul>", alias="rateRecommendation")
    shipping_carrier_code: Optional[StrictStr] = Field(default=None, description="The code name of the shipping carrier who will provide the service identified by <b>shippingServiceCode</b>.", alias="shippingCarrierCode")
    shipping_carrier_name: Optional[StrictStr] = Field(default=None, description="The common name of the shipping carrier.", alias="shippingCarrierName")
    shipping_service_code: Optional[StrictStr] = Field(default=None, description="The code name of the shipping service to be provided by the carrier identified by <b>shippingCarrierCode</b>.", alias="shippingServiceCode")
    shipping_service_name: Optional[StrictStr] = Field(default=None, description="The common name of the shipping service.", alias="shippingServiceName")
    __properties: ClassVar[List[str]] = ["additionalOptions", "baseShippingCost", "destinationTimeZone", "maxEstimatedDeliveryDate", "minEstimatedDeliveryDate", "pickupNetworks", "pickupSlots", "pickupType", "rateId", "rateRecommendation", "shippingCarrierCode", "shippingCarrierName", "shippingServiceCode", "shippingServiceName"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of Rate from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of each item in additional_options (list)
        _items = []
        if self.additional_options:
            for _item_additional_options in self.additional_options:
                if _item_additional_options:
                    _items.append(_item_additional_options.to_dict())
            _dict['additionalOptions'] = _items
        # override the default output from pydantic by calling `to_dict()` of base_shipping_cost
        if self.base_shipping_cost:
            _dict['baseShippingCost'] = self.base_shipping_cost.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in pickup_slots (list)
        _items = []
        if self.pickup_slots:
            for _item_pickup_slots in self.pickup_slots:
                if _item_pickup_slots:
                    _items.append(_item_pickup_slots.to_dict())
            _dict['pickupSlots'] = _items
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of Rate from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "additionalOptions": [AdditionalOption.from_dict(_item) for _item in obj["additionalOptions"]] if obj.get("additionalOptions") is not None else None,
            "baseShippingCost": Amount.from_dict(obj["baseShippingCost"]) if obj.get("baseShippingCost") is not None else None,
            "destinationTimeZone": obj.get("destinationTimeZone"),
            "maxEstimatedDeliveryDate": obj.get("maxEstimatedDeliveryDate"),
            "minEstimatedDeliveryDate": obj.get("minEstimatedDeliveryDate"),
            "pickupNetworks": obj.get("pickupNetworks"),
            "pickupSlots": [PickupSlot.from_dict(_item) for _item in obj["pickupSlots"]] if obj.get("pickupSlots") is not None else None,
            "pickupType": obj.get("pickupType"),
            "rateId": obj.get("rateId"),
            "rateRecommendation": obj.get("rateRecommendation"),
            "shippingCarrierCode": obj.get("shippingCarrierCode"),
            "shippingCarrierName": obj.get("shippingCarrierName"),
            "shippingServiceCode": obj.get("shippingServiceCode"),
            "shippingServiceName": obj.get("shippingServiceName")
        })
        return _obj


