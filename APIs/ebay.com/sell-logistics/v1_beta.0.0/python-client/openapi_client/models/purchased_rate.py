# coding: utf-8

"""
    Logistics API

    <span class=\"tablenote\"><b>Note:</b> This is a <a href=\"https://developer.ebay.com/api-docs/static/versioning.html#limited\" target=\"_blank\"> <img src=\"/cms/img/docs/partners-api.svg\" class=\"legend-icon partners-icon\" title=\"Limited Release\"  alt=\"Limited Release\" />(Limited Release)</a> API available only to select developers approved by business units.</span><br /><br />The <b>Logistics API</b> resources offer the following capabilities: <ul><li><b>shipping_quote</b> &ndash; Consolidates into a list a set of live shipping rates, or quotes, from which you can select a rate to ship a package.</li> <li><b>shipment</b> &ndash; Creates a \"shipment\" for the selected shipping rate.</li></ul> Call <b>createShippingQuote</b> to get a list of live shipping rates. The rates returned are all valid for a specific time window and all quoted prices are at eBay-negotiated rates. <br><br>Select one of the live rates and using its associated <b>rateId</b>, create a \"shipment\" for the package by calling <b>createFromShippingQuote</b>. Creating a shipment completes an agreement, and the cost of the base service and any added shipping options are summed into the returned <b>totalShippingCost</b> value. This action also generates a shipping label that you can use to ship the package.  The total cost of the shipment is incurred when the package is shipped using the supplied shipping label.  <p class=\"tablenote\"><b>Important!</b> Sellers must set up a payment method via their eBay account before they can use the methods in this API to create a shipment and the associated shipping label.</p>

    The version of the OpenAPI document: v1_beta.0.0
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictStr
from typing import Any, ClassVar, Dict, List, Optional
from openapi_client.models.additional_option import AdditionalOption
from openapi_client.models.amount import Amount
from typing import Optional, Set
from typing_extensions import Self

class PurchasedRate(BaseModel):
    """
    The \"rate\" that has been selected and purchased for the shipment, as referenced by the <b>rateId</b> value.
    """ # noqa: E501
    additional_options: Optional[List[AdditionalOption]] = Field(default=None, description="An list of additional, optional features that have been purchased for the shipment.", alias="additionalOptions")
    base_shipping_cost: Optional[Amount] = Field(default=None, alias="baseShippingCost")
    destination_time_zone: Optional[StrictStr] = Field(default=None, description="The time zone of the destination according to <a href=\"https://www.iana.org/time-zones\" target=\"_blank\">Time Zone Database</a>. For example, \"America/Los_Angeles\".", alias="destinationTimeZone")
    max_estimated_delivery_date: Optional[StrictStr] = Field(default=None, description="A string value representing maximum (latest) estimated delivery time, formatted as an <a href=\"https://www.iso.org/iso-8601-date-and-time-format.html\" title=\"https://www.iso.org\" target=\"_blank\">ISO 8601</a> string, which is based on the 24-hour Coordinated Universal Time (UTC) clock.  <br><br><b>Format:</b> <code>[YYYY]-[MM]-[DD]T[HH]:[MM]:[SS].[SSS]Z</code> <br><b>Example:</b> <code>2018-08-20T07:09:00.000Z</code>", alias="maxEstimatedDeliveryDate")
    min_estimated_delivery_date: Optional[StrictStr] = Field(default=None, description="A string value representing minimum (earliest) estimated delivery time, formatted as an <a href=\"https://www.iso.org/iso-8601-date-and-time-format.html\" title=\"https://www.iso.org\" target=\"_blank\">ISO 8601</a>ISO 8601</a> UTC string.", alias="minEstimatedDeliveryDate")
    pickup_networks: Optional[List[StrictStr]] = Field(default=None, description="A list of pickup networks compatible with the shipping service.", alias="pickupNetworks")
    pickup_slot_id: Optional[StrictStr] = Field(default=None, description="This unique eBay-assigned ID value is returned only if the shipment has been configured for a scheduled pickup.", alias="pickupSlotId")
    pickup_type: Optional[StrictStr] = Field(default=None, description="The type of pickup or drop off configured for the shipment. For implementation help, refer to <a href='https://developer.ebay.com/api-docs/sell/logistics/types/api:PickupTypeEnum'>eBay API documentation</a>", alias="pickupType")
    rate_id: Optional[StrictStr] = Field(default=None, description="The eBay-generated ID of the shipping rate that the seller has chosen to purchase for the shipment.", alias="rateId")
    shipping_carrier_code: Optional[StrictStr] = Field(default=None, description="The ID code for the carrier that was selected for the package shipment.", alias="shippingCarrierCode")
    shipping_carrier_name: Optional[StrictStr] = Field(default=None, description="The name of the shipping carrier.", alias="shippingCarrierName")
    shipping_quote_id: Optional[StrictStr] = Field(default=None, description="The unique eBay-generated ID of the <i>shipping quote</i> from which the seller selected a shipping rate (<b>rateId</b>).", alias="shippingQuoteId")
    shipping_service_code: Optional[StrictStr] = Field(default=None, description="String ID code for the shipping service selected for the package shipment. This is a service that the shipping carrier supplies.", alias="shippingServiceCode")
    shipping_service_name: Optional[StrictStr] = Field(default=None, description="The name of the shipping service.", alias="shippingServiceName")
    total_shipping_cost: Optional[Amount] = Field(default=None, alias="totalShippingCost")
    __properties: ClassVar[List[str]] = ["additionalOptions", "baseShippingCost", "destinationTimeZone", "maxEstimatedDeliveryDate", "minEstimatedDeliveryDate", "pickupNetworks", "pickupSlotId", "pickupType", "rateId", "shippingCarrierCode", "shippingCarrierName", "shippingQuoteId", "shippingServiceCode", "shippingServiceName", "totalShippingCost"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of PurchasedRate from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of each item in additional_options (list)
        _items = []
        if self.additional_options:
            for _item_additional_options in self.additional_options:
                if _item_additional_options:
                    _items.append(_item_additional_options.to_dict())
            _dict['additionalOptions'] = _items
        # override the default output from pydantic by calling `to_dict()` of base_shipping_cost
        if self.base_shipping_cost:
            _dict['baseShippingCost'] = self.base_shipping_cost.to_dict()
        # override the default output from pydantic by calling `to_dict()` of total_shipping_cost
        if self.total_shipping_cost:
            _dict['totalShippingCost'] = self.total_shipping_cost.to_dict()
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of PurchasedRate from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "additionalOptions": [AdditionalOption.from_dict(_item) for _item in obj["additionalOptions"]] if obj.get("additionalOptions") is not None else None,
            "baseShippingCost": Amount.from_dict(obj["baseShippingCost"]) if obj.get("baseShippingCost") is not None else None,
            "destinationTimeZone": obj.get("destinationTimeZone"),
            "maxEstimatedDeliveryDate": obj.get("maxEstimatedDeliveryDate"),
            "minEstimatedDeliveryDate": obj.get("minEstimatedDeliveryDate"),
            "pickupNetworks": obj.get("pickupNetworks"),
            "pickupSlotId": obj.get("pickupSlotId"),
            "pickupType": obj.get("pickupType"),
            "rateId": obj.get("rateId"),
            "shippingCarrierCode": obj.get("shippingCarrierCode"),
            "shippingCarrierName": obj.get("shippingCarrierName"),
            "shippingQuoteId": obj.get("shippingQuoteId"),
            "shippingServiceCode": obj.get("shippingServiceCode"),
            "shippingServiceName": obj.get("shippingServiceName"),
            "totalShippingCost": Amount.from_dict(obj["totalShippingCost"]) if obj.get("totalShippingCost") is not None else None
        })
        return _obj


