# coding: utf-8

"""
    Logistics API

    <span class=\"tablenote\"><b>Note:</b> This is a <a href=\"https://developer.ebay.com/api-docs/static/versioning.html#limited\" target=\"_blank\"> <img src=\"/cms/img/docs/partners-api.svg\" class=\"legend-icon partners-icon\" title=\"Limited Release\"  alt=\"Limited Release\" />(Limited Release)</a> API available only to select developers approved by business units.</span><br /><br />The <b>Logistics API</b> resources offer the following capabilities: <ul><li><b>shipping_quote</b> &ndash; Consolidates into a list a set of live shipping rates, or quotes, from which you can select a rate to ship a package.</li> <li><b>shipment</b> &ndash; Creates a \"shipment\" for the selected shipping rate.</li></ul> Call <b>createShippingQuote</b> to get a list of live shipping rates. The rates returned are all valid for a specific time window and all quoted prices are at eBay-negotiated rates. <br><br>Select one of the live rates and using its associated <b>rateId</b>, create a \"shipment\" for the package by calling <b>createFromShippingQuote</b>. Creating a shipment completes an agreement, and the cost of the base service and any added shipping options are summed into the returned <b>totalShippingCost</b> value. This action also generates a shipping label that you can use to ship the package.  The total cost of the shipment is incurred when the package is shipped using the supplied shipping label.  <p class=\"tablenote\"><b>Important!</b> Sellers must set up a payment method via their eBay account before they can use the methods in this API to create a shipment and the associated shipping label.</p>

    The version of the OpenAPI document: v1_beta.0.0
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictStr
from typing import Any, ClassVar, Dict, List, Optional
from openapi_client.models.contact import Contact
from openapi_client.models.order import Order
from openapi_client.models.package_specification import PackageSpecification
from openapi_client.models.purchased_rate import PurchasedRate
from openapi_client.models.shipment_cancellation import ShipmentCancellation
from typing import Optional, Set
from typing_extensions import Self

class Shipment(BaseModel):
    """
    This complex type defines a shipment for a specific package (for example, a box or letter). Shipments are always linked to a purchased shipping label. 
    """ # noqa: E501
    cancellation: Optional[ShipmentCancellation] = None
    creation_date: Optional[StrictStr] = Field(default=None, description="The date and time the shipment was created, formatted as an <a href=\"https://www.iso.org/iso-8601-date-and-time-format.html\" title=\"https://www.iso.org\" target=\"_blank\">ISO 8601</a> string, which is based on the 24-hour Coordinated Universal Time (UTC) clock.  <br><br><b>Format:</b> <code>[YYYY]-[MM]-[DD]T[HH]:[MM]:[SS].[SSS]Z</code> <br><b>Example:</b> <code>2018-08-20T07:09:00.000Z</code>", alias="creationDate")
    label_custom_message: Optional[StrictStr] = Field(default=None, description="If supported by the selected shipping carrier, this field can contain optional seller text to be printed on the shipping label.", alias="labelCustomMessage")
    label_download_url: Optional[StrictStr] = Field(default=None, description="The direct URL the seller can use to download an image of the shipping label. By default, the file format is PDF. See <a href=\"/api-docs/sell/logistics/resources/shipment/methods/downloadLabelFile\">downloadLabelFile</a> for requesting different response file formats.", alias="labelDownloadUrl")
    label_size: Optional[StrictStr] = Field(default=None, description="The seller's desired label size. The support for multi-sized labels is shipping-carrier specific and if the size requested in the <b>creaateFromShippingQuote</b> call matches a size the carrier supports, the value will be represented here in the shipment. <br><br>Currently, the only valid value is: <code>4\"x6\"</code>", alias="labelSize")
    orders: Optional[List[Order]] = Field(default=None, description="This list value is optionally assigned by the seller. When present, each element in the returned list contains seller-assigned information about an order (such as an order number). Because a package can contain all or part of one or more orders, this field provides a way for sellers to identify the packages that contain specific orders.")
    package_specification: Optional[PackageSpecification] = Field(default=None, alias="packageSpecification")
    rate: Optional[PurchasedRate] = None
    return_to: Optional[Contact] = Field(default=None, alias="returnTo")
    ship_from: Optional[Contact] = Field(default=None, alias="shipFrom")
    ship_to: Optional[Contact] = Field(default=None, alias="shipTo")
    shipment_id: Optional[StrictStr] = Field(default=None, description="The unique eBay-assigned ID for the shipment. The ID is generated when the shipment is created by a call to <b>createFromShippingQuote</b>.", alias="shipmentId")
    shipment_tracking_number: Optional[StrictStr] = Field(default=None, description="A unique carrier-assigned ID string that can be used to track the shipment.", alias="shipmentTrackingNumber")
    __properties: ClassVar[List[str]] = ["cancellation", "creationDate", "labelCustomMessage", "labelDownloadUrl", "labelSize", "orders", "packageSpecification", "rate", "returnTo", "shipFrom", "shipTo", "shipmentId", "shipmentTrackingNumber"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of Shipment from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of cancellation
        if self.cancellation:
            _dict['cancellation'] = self.cancellation.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in orders (list)
        _items = []
        if self.orders:
            for _item_orders in self.orders:
                if _item_orders:
                    _items.append(_item_orders.to_dict())
            _dict['orders'] = _items
        # override the default output from pydantic by calling `to_dict()` of package_specification
        if self.package_specification:
            _dict['packageSpecification'] = self.package_specification.to_dict()
        # override the default output from pydantic by calling `to_dict()` of rate
        if self.rate:
            _dict['rate'] = self.rate.to_dict()
        # override the default output from pydantic by calling `to_dict()` of return_to
        if self.return_to:
            _dict['returnTo'] = self.return_to.to_dict()
        # override the default output from pydantic by calling `to_dict()` of ship_from
        if self.ship_from:
            _dict['shipFrom'] = self.ship_from.to_dict()
        # override the default output from pydantic by calling `to_dict()` of ship_to
        if self.ship_to:
            _dict['shipTo'] = self.ship_to.to_dict()
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of Shipment from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "cancellation": ShipmentCancellation.from_dict(obj["cancellation"]) if obj.get("cancellation") is not None else None,
            "creationDate": obj.get("creationDate"),
            "labelCustomMessage": obj.get("labelCustomMessage"),
            "labelDownloadUrl": obj.get("labelDownloadUrl"),
            "labelSize": obj.get("labelSize"),
            "orders": [Order.from_dict(_item) for _item in obj["orders"]] if obj.get("orders") is not None else None,
            "packageSpecification": PackageSpecification.from_dict(obj["packageSpecification"]) if obj.get("packageSpecification") is not None else None,
            "rate": PurchasedRate.from_dict(obj["rate"]) if obj.get("rate") is not None else None,
            "returnTo": Contact.from_dict(obj["returnTo"]) if obj.get("returnTo") is not None else None,
            "shipFrom": Contact.from_dict(obj["shipFrom"]) if obj.get("shipFrom") is not None else None,
            "shipTo": Contact.from_dict(obj["shipTo"]) if obj.get("shipTo") is not None else None,
            "shipmentId": obj.get("shipmentId"),
            "shipmentTrackingNumber": obj.get("shipmentTrackingNumber")
        })
        return _obj


