# coding: utf-8

"""
    Fulfillment API

    Use the Fulfillment API to complete the process of packaging, addressing, handling, and shipping each order on behalf of the seller, in accordance with the payment method and timing specified at checkout.

    The version of the OpenAPI document: v1.20.0
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictInt, StrictStr
from typing import Any, ClassVar, Dict, List, Optional
from openapi_client.models.amount import Amount
from openapi_client.models.applied_promotion import AppliedPromotion
from openapi_client.models.delivery_cost import DeliveryCost
from openapi_client.models.ebay_collect_and_remit_tax import EbayCollectAndRemitTax
from openapi_client.models.ebay_collected_charges import EbayCollectedCharges
from openapi_client.models.gift_details import GiftDetails
from openapi_client.models.item_location import ItemLocation
from openapi_client.models.line_item_fulfillment_instructions import LineItemFulfillmentInstructions
from openapi_client.models.line_item_properties import LineItemProperties
from openapi_client.models.line_item_refund import LineItemRefund
from openapi_client.models.linked_order_line_item import LinkedOrderLineItem
from openapi_client.models.name_value_pair import NameValuePair
from openapi_client.models.tax import Tax
from typing import Optional, Set
from typing_extensions import Self

class LineItem(BaseModel):
    """
    This type contains the details of each line item in an order.
    """ # noqa: E501
    applied_promotions: Optional[List[AppliedPromotion]] = Field(default=None, description="This array contains information about one or more sales promotions or discounts applied to the line item. It is always returned, but will be returned as an empty array if no special sales promotions or discounts apply to the order line item.", alias="appliedPromotions")
    delivery_cost: Optional[DeliveryCost] = Field(default=None, alias="deliveryCost")
    discounted_line_item_cost: Optional[Amount] = Field(default=None, alias="discountedLineItemCost")
    ebay_collect_and_remit_taxes: Optional[List[EbayCollectAndRemitTax]] = Field(default=None, description="This container will be returned if the order line item is subject to a 'Collect and Remit' tax that eBay will collect and remit to the proper taxing authority on the buyer's behalf.<br><br>'Collect and Remit' tax includes:<ul><li>US state-mandated sales tax</li><li>Federal and Provincial Sales Tax in Canada</li><li>'Goods and Services' tax in Canada, Australia, and New Zealand</li><li>VAT collected for the UK and EU countries</li></ul>The amount of this tax is shown in the <strong>amount</strong> field, and the type of tax is shown in the <strong>taxType</strong> field.<br><br>eBay will display the tax type and amount during checkout in accordance with the buyer's address, and handle collection and remittance of the tax without requiring the seller to take any action.", alias="ebayCollectAndRemitTaxes")
    ebay_collected_charges: Optional[EbayCollectedCharges] = Field(default=None, alias="ebayCollectedCharges")
    gift_details: Optional[GiftDetails] = Field(default=None, alias="giftDetails")
    item_location: Optional[ItemLocation] = Field(default=None, alias="itemLocation")
    legacy_item_id: Optional[StrictStr] = Field(default=None, description="The eBay-generated legacy listing item ID of the listing. Note that the unique identifier of a listing in REST-based APIs is called the <strong>listingId</strong> instead.", alias="legacyItemId")
    legacy_variation_id: Optional[StrictStr] = Field(default=None, description="The unique identifier of a single variation within a multiple-variation listing. This field is only returned if the line item purchased was from a multiple-variation listing.", alias="legacyVariationId")
    line_item_cost: Optional[Amount] = Field(default=None, alias="lineItemCost")
    line_item_fulfillment_instructions: Optional[LineItemFulfillmentInstructions] = Field(default=None, alias="lineItemFulfillmentInstructions")
    line_item_fulfillment_status: Optional[StrictStr] = Field(default=None, description="This enumeration value indicates the current fulfillment status of the line item. For implementation help, refer to <a href='https://developer.ebay.com/api-docs/sell/fulfillment/types/sel:LineItemFulfillmentStatusEnum'>eBay API documentation</a>", alias="lineItemFulfillmentStatus")
    line_item_id: Optional[StrictStr] = Field(default=None, description="This is the unique identifier of an eBay order line item. This field is created as soon as there is a commitment to buy from the seller.", alias="lineItemId")
    linked_order_line_items: Optional[List[LinkedOrderLineItem]] = Field(default=None, description="An array of one or more line items related to the corresponding order, but not a part of that order. Details include the order ID, line item ID, and title of the linked line item, the seller of that item, item specifics, estimated delivery times, and shipment tracking (if available).", alias="linkedOrderLineItems")
    listing_marketplace_id: Optional[StrictStr] = Field(default=None, description="The unique identifier of the eBay marketplace where the line item was listed. For implementation help, refer to <a href='https://developer.ebay.com/api-docs/sell/fulfillment/types/ba:MarketplaceIdEnum'>eBay API documentation</a>", alias="listingMarketplaceId")
    properties: Optional[LineItemProperties] = None
    purchase_marketplace_id: Optional[StrictStr] = Field(default=None, description="The unique identifier of the eBay marketplace where the line item was listed. Often, the <strong>listingMarketplaceId</strong> and the <strong>purchaseMarketplaceId</strong> identifier are the same, but there are occasions when an item will surface on multiple eBay marketplaces. For implementation help, refer to <a href='https://developer.ebay.com/api-docs/sell/fulfillment/types/ba:MarketplaceIdEnum'>eBay API documentation</a>", alias="purchaseMarketplaceId")
    quantity: Optional[StrictInt] = Field(default=None, description="The number of units of the line item in the order. These are represented as a group by a single <b>lineItemId</b>.")
    refunds: Optional[List[LineItemRefund]] = Field(default=None, description="This array is always returned, but is returned as an empty array unless the seller has submitted a partial or full refund to the buyer for the order. If a refund has occurred, the refund amount and refund date will be shown for each refund.")
    sku: Optional[StrictStr] = Field(default=None, description="Seller-defined Stock-Keeping Unit (SKU). This inventory identifier must be unique within the seller's eBay inventory. SKUs are optional when listing in the legacy/Trading API system, but SKUs are required when listing items through the Inventory API model.")
    sold_format: Optional[StrictStr] = Field(default=None, description="The eBay listing type of the line item. The most common listing types are <code>AUCTION</code> and <code>FIXED_PRICE</code>. For implementation help, refer to <a href='https://developer.ebay.com/api-docs/sell/fulfillment/types/sel:SoldFormatEnum'>eBay API documentation</a>", alias="soldFormat")
    taxes: Optional[List[Tax]] = Field(default=None, description="Contains a list of taxes applied to the line item, if any. This array is always returned, but will be returned as empty if no taxes are applicable to the line item.")
    title: Optional[StrictStr] = Field(default=None, description="The title of the listing.")
    total: Optional[Amount] = None
    variation_aspects: Optional[List[NameValuePair]] = Field(default=None, description="An array of aspect name-value pairs that identifies the specific variation of a multi-variation listing. This array can contain multiple name-value pairs, such as <code>color:blue</code> and <code>size:large</code>, and will only be returned for orders created from a multiple-variation listing.", alias="variationAspects")
    __properties: ClassVar[List[str]] = ["appliedPromotions", "deliveryCost", "discountedLineItemCost", "ebayCollectAndRemitTaxes", "ebayCollectedCharges", "giftDetails", "itemLocation", "legacyItemId", "legacyVariationId", "lineItemCost", "lineItemFulfillmentInstructions", "lineItemFulfillmentStatus", "lineItemId", "linkedOrderLineItems", "listingMarketplaceId", "properties", "purchaseMarketplaceId", "quantity", "refunds", "sku", "soldFormat", "taxes", "title", "total", "variationAspects"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of LineItem from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of each item in applied_promotions (list)
        _items = []
        if self.applied_promotions:
            for _item_applied_promotions in self.applied_promotions:
                if _item_applied_promotions:
                    _items.append(_item_applied_promotions.to_dict())
            _dict['appliedPromotions'] = _items
        # override the default output from pydantic by calling `to_dict()` of delivery_cost
        if self.delivery_cost:
            _dict['deliveryCost'] = self.delivery_cost.to_dict()
        # override the default output from pydantic by calling `to_dict()` of discounted_line_item_cost
        if self.discounted_line_item_cost:
            _dict['discountedLineItemCost'] = self.discounted_line_item_cost.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in ebay_collect_and_remit_taxes (list)
        _items = []
        if self.ebay_collect_and_remit_taxes:
            for _item_ebay_collect_and_remit_taxes in self.ebay_collect_and_remit_taxes:
                if _item_ebay_collect_and_remit_taxes:
                    _items.append(_item_ebay_collect_and_remit_taxes.to_dict())
            _dict['ebayCollectAndRemitTaxes'] = _items
        # override the default output from pydantic by calling `to_dict()` of ebay_collected_charges
        if self.ebay_collected_charges:
            _dict['ebayCollectedCharges'] = self.ebay_collected_charges.to_dict()
        # override the default output from pydantic by calling `to_dict()` of gift_details
        if self.gift_details:
            _dict['giftDetails'] = self.gift_details.to_dict()
        # override the default output from pydantic by calling `to_dict()` of item_location
        if self.item_location:
            _dict['itemLocation'] = self.item_location.to_dict()
        # override the default output from pydantic by calling `to_dict()` of line_item_cost
        if self.line_item_cost:
            _dict['lineItemCost'] = self.line_item_cost.to_dict()
        # override the default output from pydantic by calling `to_dict()` of line_item_fulfillment_instructions
        if self.line_item_fulfillment_instructions:
            _dict['lineItemFulfillmentInstructions'] = self.line_item_fulfillment_instructions.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in linked_order_line_items (list)
        _items = []
        if self.linked_order_line_items:
            for _item_linked_order_line_items in self.linked_order_line_items:
                if _item_linked_order_line_items:
                    _items.append(_item_linked_order_line_items.to_dict())
            _dict['linkedOrderLineItems'] = _items
        # override the default output from pydantic by calling `to_dict()` of properties
        if self.properties:
            _dict['properties'] = self.properties.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in refunds (list)
        _items = []
        if self.refunds:
            for _item_refunds in self.refunds:
                if _item_refunds:
                    _items.append(_item_refunds.to_dict())
            _dict['refunds'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in taxes (list)
        _items = []
        if self.taxes:
            for _item_taxes in self.taxes:
                if _item_taxes:
                    _items.append(_item_taxes.to_dict())
            _dict['taxes'] = _items
        # override the default output from pydantic by calling `to_dict()` of total
        if self.total:
            _dict['total'] = self.total.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in variation_aspects (list)
        _items = []
        if self.variation_aspects:
            for _item_variation_aspects in self.variation_aspects:
                if _item_variation_aspects:
                    _items.append(_item_variation_aspects.to_dict())
            _dict['variationAspects'] = _items
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of LineItem from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "appliedPromotions": [AppliedPromotion.from_dict(_item) for _item in obj["appliedPromotions"]] if obj.get("appliedPromotions") is not None else None,
            "deliveryCost": DeliveryCost.from_dict(obj["deliveryCost"]) if obj.get("deliveryCost") is not None else None,
            "discountedLineItemCost": Amount.from_dict(obj["discountedLineItemCost"]) if obj.get("discountedLineItemCost") is not None else None,
            "ebayCollectAndRemitTaxes": [EbayCollectAndRemitTax.from_dict(_item) for _item in obj["ebayCollectAndRemitTaxes"]] if obj.get("ebayCollectAndRemitTaxes") is not None else None,
            "ebayCollectedCharges": EbayCollectedCharges.from_dict(obj["ebayCollectedCharges"]) if obj.get("ebayCollectedCharges") is not None else None,
            "giftDetails": GiftDetails.from_dict(obj["giftDetails"]) if obj.get("giftDetails") is not None else None,
            "itemLocation": ItemLocation.from_dict(obj["itemLocation"]) if obj.get("itemLocation") is not None else None,
            "legacyItemId": obj.get("legacyItemId"),
            "legacyVariationId": obj.get("legacyVariationId"),
            "lineItemCost": Amount.from_dict(obj["lineItemCost"]) if obj.get("lineItemCost") is not None else None,
            "lineItemFulfillmentInstructions": LineItemFulfillmentInstructions.from_dict(obj["lineItemFulfillmentInstructions"]) if obj.get("lineItemFulfillmentInstructions") is not None else None,
            "lineItemFulfillmentStatus": obj.get("lineItemFulfillmentStatus"),
            "lineItemId": obj.get("lineItemId"),
            "linkedOrderLineItems": [LinkedOrderLineItem.from_dict(_item) for _item in obj["linkedOrderLineItems"]] if obj.get("linkedOrderLineItems") is not None else None,
            "listingMarketplaceId": obj.get("listingMarketplaceId"),
            "properties": LineItemProperties.from_dict(obj["properties"]) if obj.get("properties") is not None else None,
            "purchaseMarketplaceId": obj.get("purchaseMarketplaceId"),
            "quantity": obj.get("quantity"),
            "refunds": [LineItemRefund.from_dict(_item) for _item in obj["refunds"]] if obj.get("refunds") is not None else None,
            "sku": obj.get("sku"),
            "soldFormat": obj.get("soldFormat"),
            "taxes": [Tax.from_dict(_item) for _item in obj["taxes"]] if obj.get("taxes") is not None else None,
            "title": obj.get("title"),
            "total": Amount.from_dict(obj["total"]) if obj.get("total") is not None else None,
            "variationAspects": [NameValuePair.from_dict(_item) for _item in obj["variationAspects"]] if obj.get("variationAspects") is not None else None
        })
        return _obj


