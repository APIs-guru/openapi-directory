# coding: utf-8

"""
    Inventory Management

    Maintaining up-to-date inventory for your items on Walmart.com ensures a great experience for your customers and greater sales opportunities for you.

    The version of the OpenAPI document: 1.0.0
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501

import warnings
from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
from typing import Any, Dict, List, Optional, Tuple, Union
from typing_extensions import Annotated

from pydantic import Field, StrictBytes, StrictStr, field_validator
from typing import Optional, Tuple, Union
from typing_extensions import Annotated
from openapi_client.models.get_inventory200_response import GetInventory200Response
from openapi_client.models.get_multi_node_inventory_for_all_sku_and_all_ship_nodes200_response import GetMultiNodeInventoryForAllSkuAndAllShipNodes200Response
from openapi_client.models.get_multi_node_inventory_for_sku_and_all_shipnodes200_response import GetMultiNodeInventoryForSkuAndAllShipnodes200Response
from openapi_client.models.get_wfs_inventory200_response import GetWFSInventory200Response
from openapi_client.models.update_bulk_inventory200_response import UpdateBulkInventory200Response
from openapi_client.models.update_multi_node_inventory200_response import UpdateMultiNodeInventory200Response
from openapi_client.models.update_multi_node_inventory_request import UpdateMultiNodeInventoryRequest

from openapi_client.api_client import ApiClient, RequestSerialized
from openapi_client.api_response import ApiResponse
from openapi_client.rest import RESTResponseType


class InventoryApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client


    @validate_call
    def get_inventory(
        self,
        sku: Annotated[StrictStr, Field(description="An arbitrary alphanumeric unique ID, specified by the seller, which identifies each item. This will be used by the seller in the XSD file to refer to each item. Special characters in the sku needing encoding are: ':', '/', '?', '#', '[', ']', '@', '!', '$', '&', \"'\", '(', ')', '*', '+', ',', ';', '=', ‘ ’, '{', '}' as well as '%' itself if it's a part of sku. Make sure to encode space with %20. Other characters don't need to be encoded.")],
        wm_sec_access_token: Annotated[StrictStr, Field(description="The access token retrieved in the Token API call")],
        wm_qos_correlation_id: Annotated[StrictStr, Field(description="A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID")],
        wm_svc_name: Annotated[StrictStr, Field(description="Walmart Service Name")],
        ship_node: Annotated[Optional[StrictStr], Field(description="The shipNode for which the inventory is requested")] = None,
        wm_consumer_channel_type: Annotated[Optional[StrictStr], Field(description="A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GetInventory200Response:
        """Inventory

        You can use this API to get the inventory for a given item.

        :param sku: An arbitrary alphanumeric unique ID, specified by the seller, which identifies each item. This will be used by the seller in the XSD file to refer to each item. Special characters in the sku needing encoding are: ':', '/', '?', '#', '[', ']', '@', '!', '$', '&', \"'\", '(', ')', '*', '+', ',', ';', '=', ‘ ’, '{', '}' as well as '%' itself if it's a part of sku. Make sure to encode space with %20. Other characters don't need to be encoded. (required)
        :type sku: str
        :param wm_sec_access_token: The access token retrieved in the Token API call (required)
        :type wm_sec_access_token: str
        :param wm_qos_correlation_id: A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID (required)
        :type wm_qos_correlation_id: str
        :param wm_svc_name: Walmart Service Name (required)
        :type wm_svc_name: str
        :param ship_node: The shipNode for which the inventory is requested
        :type ship_node: str
        :param wm_consumer_channel_type: A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
        :type wm_consumer_channel_type: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_inventory_serialize(
            sku=sku,
            wm_sec_access_token=wm_sec_access_token,
            wm_qos_correlation_id=wm_qos_correlation_id,
            wm_svc_name=wm_svc_name,
            ship_node=ship_node,
            wm_consumer_channel_type=wm_consumer_channel_type,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetInventory200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_inventory_with_http_info(
        self,
        sku: Annotated[StrictStr, Field(description="An arbitrary alphanumeric unique ID, specified by the seller, which identifies each item. This will be used by the seller in the XSD file to refer to each item. Special characters in the sku needing encoding are: ':', '/', '?', '#', '[', ']', '@', '!', '$', '&', \"'\", '(', ')', '*', '+', ',', ';', '=', ‘ ’, '{', '}' as well as '%' itself if it's a part of sku. Make sure to encode space with %20. Other characters don't need to be encoded.")],
        wm_sec_access_token: Annotated[StrictStr, Field(description="The access token retrieved in the Token API call")],
        wm_qos_correlation_id: Annotated[StrictStr, Field(description="A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID")],
        wm_svc_name: Annotated[StrictStr, Field(description="Walmart Service Name")],
        ship_node: Annotated[Optional[StrictStr], Field(description="The shipNode for which the inventory is requested")] = None,
        wm_consumer_channel_type: Annotated[Optional[StrictStr], Field(description="A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GetInventory200Response]:
        """Inventory

        You can use this API to get the inventory for a given item.

        :param sku: An arbitrary alphanumeric unique ID, specified by the seller, which identifies each item. This will be used by the seller in the XSD file to refer to each item. Special characters in the sku needing encoding are: ':', '/', '?', '#', '[', ']', '@', '!', '$', '&', \"'\", '(', ')', '*', '+', ',', ';', '=', ‘ ’, '{', '}' as well as '%' itself if it's a part of sku. Make sure to encode space with %20. Other characters don't need to be encoded. (required)
        :type sku: str
        :param wm_sec_access_token: The access token retrieved in the Token API call (required)
        :type wm_sec_access_token: str
        :param wm_qos_correlation_id: A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID (required)
        :type wm_qos_correlation_id: str
        :param wm_svc_name: Walmart Service Name (required)
        :type wm_svc_name: str
        :param ship_node: The shipNode for which the inventory is requested
        :type ship_node: str
        :param wm_consumer_channel_type: A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
        :type wm_consumer_channel_type: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_inventory_serialize(
            sku=sku,
            wm_sec_access_token=wm_sec_access_token,
            wm_qos_correlation_id=wm_qos_correlation_id,
            wm_svc_name=wm_svc_name,
            ship_node=ship_node,
            wm_consumer_channel_type=wm_consumer_channel_type,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetInventory200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_inventory_without_preload_content(
        self,
        sku: Annotated[StrictStr, Field(description="An arbitrary alphanumeric unique ID, specified by the seller, which identifies each item. This will be used by the seller in the XSD file to refer to each item. Special characters in the sku needing encoding are: ':', '/', '?', '#', '[', ']', '@', '!', '$', '&', \"'\", '(', ')', '*', '+', ',', ';', '=', ‘ ’, '{', '}' as well as '%' itself if it's a part of sku. Make sure to encode space with %20. Other characters don't need to be encoded.")],
        wm_sec_access_token: Annotated[StrictStr, Field(description="The access token retrieved in the Token API call")],
        wm_qos_correlation_id: Annotated[StrictStr, Field(description="A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID")],
        wm_svc_name: Annotated[StrictStr, Field(description="Walmart Service Name")],
        ship_node: Annotated[Optional[StrictStr], Field(description="The shipNode for which the inventory is requested")] = None,
        wm_consumer_channel_type: Annotated[Optional[StrictStr], Field(description="A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Inventory

        You can use this API to get the inventory for a given item.

        :param sku: An arbitrary alphanumeric unique ID, specified by the seller, which identifies each item. This will be used by the seller in the XSD file to refer to each item. Special characters in the sku needing encoding are: ':', '/', '?', '#', '[', ']', '@', '!', '$', '&', \"'\", '(', ')', '*', '+', ',', ';', '=', ‘ ’, '{', '}' as well as '%' itself if it's a part of sku. Make sure to encode space with %20. Other characters don't need to be encoded. (required)
        :type sku: str
        :param wm_sec_access_token: The access token retrieved in the Token API call (required)
        :type wm_sec_access_token: str
        :param wm_qos_correlation_id: A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID (required)
        :type wm_qos_correlation_id: str
        :param wm_svc_name: Walmart Service Name (required)
        :type wm_svc_name: str
        :param ship_node: The shipNode for which the inventory is requested
        :type ship_node: str
        :param wm_consumer_channel_type: A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
        :type wm_consumer_channel_type: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_inventory_serialize(
            sku=sku,
            wm_sec_access_token=wm_sec_access_token,
            wm_qos_correlation_id=wm_qos_correlation_id,
            wm_svc_name=wm_svc_name,
            ship_node=ship_node,
            wm_consumer_channel_type=wm_consumer_channel_type,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetInventory200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_inventory_serialize(
        self,
        sku,
        wm_sec_access_token,
        wm_qos_correlation_id,
        wm_svc_name,
        ship_node,
        wm_consumer_channel_type,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if sku is not None:
            
            _query_params.append(('sku', sku))
            
        if ship_node is not None:
            
            _query_params.append(('shipNode', ship_node))
            
        # process the header parameters
        if wm_sec_access_token is not None:
            _header_params['WM_SEC.ACCESS_TOKEN'] = wm_sec_access_token
        if wm_consumer_channel_type is not None:
            _header_params['WM_CONSUMER.CHANNEL.TYPE'] = wm_consumer_channel_type
        if wm_qos_correlation_id is not None:
            _header_params['WM_QOS.CORRELATION_ID'] = wm_qos_correlation_id
        if wm_svc_name is not None:
            _header_params['WM_SVC.NAME'] = wm_svc_name
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json', 
                    'application/xml'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/v3/inventory',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_multi_node_inventory_for_all_sku_and_all_ship_nodes(
        self,
        wm_sec_access_token: Annotated[StrictStr, Field(description="The access token retrieved in the Token API call")],
        wm_qos_correlation_id: Annotated[StrictStr, Field(description="A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID")],
        wm_svc_name: Annotated[StrictStr, Field(description="Walmart Service Name")],
        limit: Annotated[Optional[StrictStr], Field(description="The number of items returned. Cannot be more than 50.")] = None,
        next_cursor: Annotated[Optional[StrictStr], Field(description="String returned from initial API call to indicate pagination. Specify nextCursor value to retrieve the next 50 items.")] = None,
        wm_consumer_channel_type: Annotated[Optional[StrictStr], Field(description="A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GetMultiNodeInventoryForAllSkuAndAllShipNodes200Response:
        """Multiple Item Inventory for All Ship Nodes

        This API will retrieve the inventory count for all of a seller's items across all ship nodes by item to ship node mapping. Inventory can be zero or non-zero. Please note that NextCursor value changes and it needs to be passed on from the previous call to next call.

        :param wm_sec_access_token: The access token retrieved in the Token API call (required)
        :type wm_sec_access_token: str
        :param wm_qos_correlation_id: A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID (required)
        :type wm_qos_correlation_id: str
        :param wm_svc_name: Walmart Service Name (required)
        :type wm_svc_name: str
        :param limit: The number of items returned. Cannot be more than 50.
        :type limit: str
        :param next_cursor: String returned from initial API call to indicate pagination. Specify nextCursor value to retrieve the next 50 items.
        :type next_cursor: str
        :param wm_consumer_channel_type: A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
        :type wm_consumer_channel_type: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_multi_node_inventory_for_all_sku_and_all_ship_nodes_serialize(
            wm_sec_access_token=wm_sec_access_token,
            wm_qos_correlation_id=wm_qos_correlation_id,
            wm_svc_name=wm_svc_name,
            limit=limit,
            next_cursor=next_cursor,
            wm_consumer_channel_type=wm_consumer_channel_type,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetMultiNodeInventoryForAllSkuAndAllShipNodes200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_multi_node_inventory_for_all_sku_and_all_ship_nodes_with_http_info(
        self,
        wm_sec_access_token: Annotated[StrictStr, Field(description="The access token retrieved in the Token API call")],
        wm_qos_correlation_id: Annotated[StrictStr, Field(description="A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID")],
        wm_svc_name: Annotated[StrictStr, Field(description="Walmart Service Name")],
        limit: Annotated[Optional[StrictStr], Field(description="The number of items returned. Cannot be more than 50.")] = None,
        next_cursor: Annotated[Optional[StrictStr], Field(description="String returned from initial API call to indicate pagination. Specify nextCursor value to retrieve the next 50 items.")] = None,
        wm_consumer_channel_type: Annotated[Optional[StrictStr], Field(description="A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GetMultiNodeInventoryForAllSkuAndAllShipNodes200Response]:
        """Multiple Item Inventory for All Ship Nodes

        This API will retrieve the inventory count for all of a seller's items across all ship nodes by item to ship node mapping. Inventory can be zero or non-zero. Please note that NextCursor value changes and it needs to be passed on from the previous call to next call.

        :param wm_sec_access_token: The access token retrieved in the Token API call (required)
        :type wm_sec_access_token: str
        :param wm_qos_correlation_id: A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID (required)
        :type wm_qos_correlation_id: str
        :param wm_svc_name: Walmart Service Name (required)
        :type wm_svc_name: str
        :param limit: The number of items returned. Cannot be more than 50.
        :type limit: str
        :param next_cursor: String returned from initial API call to indicate pagination. Specify nextCursor value to retrieve the next 50 items.
        :type next_cursor: str
        :param wm_consumer_channel_type: A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
        :type wm_consumer_channel_type: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_multi_node_inventory_for_all_sku_and_all_ship_nodes_serialize(
            wm_sec_access_token=wm_sec_access_token,
            wm_qos_correlation_id=wm_qos_correlation_id,
            wm_svc_name=wm_svc_name,
            limit=limit,
            next_cursor=next_cursor,
            wm_consumer_channel_type=wm_consumer_channel_type,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetMultiNodeInventoryForAllSkuAndAllShipNodes200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_multi_node_inventory_for_all_sku_and_all_ship_nodes_without_preload_content(
        self,
        wm_sec_access_token: Annotated[StrictStr, Field(description="The access token retrieved in the Token API call")],
        wm_qos_correlation_id: Annotated[StrictStr, Field(description="A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID")],
        wm_svc_name: Annotated[StrictStr, Field(description="Walmart Service Name")],
        limit: Annotated[Optional[StrictStr], Field(description="The number of items returned. Cannot be more than 50.")] = None,
        next_cursor: Annotated[Optional[StrictStr], Field(description="String returned from initial API call to indicate pagination. Specify nextCursor value to retrieve the next 50 items.")] = None,
        wm_consumer_channel_type: Annotated[Optional[StrictStr], Field(description="A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Multiple Item Inventory for All Ship Nodes

        This API will retrieve the inventory count for all of a seller's items across all ship nodes by item to ship node mapping. Inventory can be zero or non-zero. Please note that NextCursor value changes and it needs to be passed on from the previous call to next call.

        :param wm_sec_access_token: The access token retrieved in the Token API call (required)
        :type wm_sec_access_token: str
        :param wm_qos_correlation_id: A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID (required)
        :type wm_qos_correlation_id: str
        :param wm_svc_name: Walmart Service Name (required)
        :type wm_svc_name: str
        :param limit: The number of items returned. Cannot be more than 50.
        :type limit: str
        :param next_cursor: String returned from initial API call to indicate pagination. Specify nextCursor value to retrieve the next 50 items.
        :type next_cursor: str
        :param wm_consumer_channel_type: A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
        :type wm_consumer_channel_type: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_multi_node_inventory_for_all_sku_and_all_ship_nodes_serialize(
            wm_sec_access_token=wm_sec_access_token,
            wm_qos_correlation_id=wm_qos_correlation_id,
            wm_svc_name=wm_svc_name,
            limit=limit,
            next_cursor=next_cursor,
            wm_consumer_channel_type=wm_consumer_channel_type,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetMultiNodeInventoryForAllSkuAndAllShipNodes200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_multi_node_inventory_for_all_sku_and_all_ship_nodes_serialize(
        self,
        wm_sec_access_token,
        wm_qos_correlation_id,
        wm_svc_name,
        limit,
        next_cursor,
        wm_consumer_channel_type,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        if next_cursor is not None:
            
            _query_params.append(('nextCursor', next_cursor))
            
        # process the header parameters
        if wm_sec_access_token is not None:
            _header_params['WM_SEC.ACCESS_TOKEN'] = wm_sec_access_token
        if wm_consumer_channel_type is not None:
            _header_params['WM_CONSUMER.CHANNEL.TYPE'] = wm_consumer_channel_type
        if wm_qos_correlation_id is not None:
            _header_params['WM_QOS.CORRELATION_ID'] = wm_qos_correlation_id
        if wm_svc_name is not None:
            _header_params['WM_SVC.NAME'] = wm_svc_name
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/v3/inventories',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_multi_node_inventory_for_sku_and_all_shipnodes(
        self,
        sku: Annotated[StrictStr, Field(description="An arbitrary alphanumeric unique ID, specified by the seller, which identifies each item. This will be used by the seller in the XSD file to refer to each item. Special characters in the sku needing encoding are: ':', '/', '?', '#', '[', ']', '@', '!', '$', '&', \"'\", '(', ')', '*', '+', ',', ';', '=', ‘ ’ as well as '%' itself if it's a part of sku. Make sure to encode space with %20. Other characters don't need to be encoded.")],
        wm_sec_access_token: Annotated[StrictStr, Field(description="The access token retrieved in the Token API call")],
        wm_qos_correlation_id: Annotated[StrictStr, Field(description="A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID")],
        wm_svc_name: Annotated[StrictStr, Field(description="Walmart Service Name")],
        ship_node: Annotated[Optional[StrictStr], Field(description="ShipNode Id of the ship node for which the inventory is requested")] = None,
        wm_consumer_channel_type: Annotated[Optional[StrictStr], Field(description="A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GetMultiNodeInventoryForSkuAndAllShipnodes200Response:
        """Single Item Inventory by Ship Node

        This API will retrieve the inventory count for an item across all ship nodes or one specific ship node. You can specify the ship node for which you want to fetch the inventory

        :param sku: An arbitrary alphanumeric unique ID, specified by the seller, which identifies each item. This will be used by the seller in the XSD file to refer to each item. Special characters in the sku needing encoding are: ':', '/', '?', '#', '[', ']', '@', '!', '$', '&', \"'\", '(', ')', '*', '+', ',', ';', '=', ‘ ’ as well as '%' itself if it's a part of sku. Make sure to encode space with %20. Other characters don't need to be encoded. (required)
        :type sku: str
        :param wm_sec_access_token: The access token retrieved in the Token API call (required)
        :type wm_sec_access_token: str
        :param wm_qos_correlation_id: A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID (required)
        :type wm_qos_correlation_id: str
        :param wm_svc_name: Walmart Service Name (required)
        :type wm_svc_name: str
        :param ship_node: ShipNode Id of the ship node for which the inventory is requested
        :type ship_node: str
        :param wm_consumer_channel_type: A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
        :type wm_consumer_channel_type: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_multi_node_inventory_for_sku_and_all_shipnodes_serialize(
            sku=sku,
            wm_sec_access_token=wm_sec_access_token,
            wm_qos_correlation_id=wm_qos_correlation_id,
            wm_svc_name=wm_svc_name,
            ship_node=ship_node,
            wm_consumer_channel_type=wm_consumer_channel_type,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetMultiNodeInventoryForSkuAndAllShipnodes200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_multi_node_inventory_for_sku_and_all_shipnodes_with_http_info(
        self,
        sku: Annotated[StrictStr, Field(description="An arbitrary alphanumeric unique ID, specified by the seller, which identifies each item. This will be used by the seller in the XSD file to refer to each item. Special characters in the sku needing encoding are: ':', '/', '?', '#', '[', ']', '@', '!', '$', '&', \"'\", '(', ')', '*', '+', ',', ';', '=', ‘ ’ as well as '%' itself if it's a part of sku. Make sure to encode space with %20. Other characters don't need to be encoded.")],
        wm_sec_access_token: Annotated[StrictStr, Field(description="The access token retrieved in the Token API call")],
        wm_qos_correlation_id: Annotated[StrictStr, Field(description="A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID")],
        wm_svc_name: Annotated[StrictStr, Field(description="Walmart Service Name")],
        ship_node: Annotated[Optional[StrictStr], Field(description="ShipNode Id of the ship node for which the inventory is requested")] = None,
        wm_consumer_channel_type: Annotated[Optional[StrictStr], Field(description="A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GetMultiNodeInventoryForSkuAndAllShipnodes200Response]:
        """Single Item Inventory by Ship Node

        This API will retrieve the inventory count for an item across all ship nodes or one specific ship node. You can specify the ship node for which you want to fetch the inventory

        :param sku: An arbitrary alphanumeric unique ID, specified by the seller, which identifies each item. This will be used by the seller in the XSD file to refer to each item. Special characters in the sku needing encoding are: ':', '/', '?', '#', '[', ']', '@', '!', '$', '&', \"'\", '(', ')', '*', '+', ',', ';', '=', ‘ ’ as well as '%' itself if it's a part of sku. Make sure to encode space with %20. Other characters don't need to be encoded. (required)
        :type sku: str
        :param wm_sec_access_token: The access token retrieved in the Token API call (required)
        :type wm_sec_access_token: str
        :param wm_qos_correlation_id: A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID (required)
        :type wm_qos_correlation_id: str
        :param wm_svc_name: Walmart Service Name (required)
        :type wm_svc_name: str
        :param ship_node: ShipNode Id of the ship node for which the inventory is requested
        :type ship_node: str
        :param wm_consumer_channel_type: A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
        :type wm_consumer_channel_type: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_multi_node_inventory_for_sku_and_all_shipnodes_serialize(
            sku=sku,
            wm_sec_access_token=wm_sec_access_token,
            wm_qos_correlation_id=wm_qos_correlation_id,
            wm_svc_name=wm_svc_name,
            ship_node=ship_node,
            wm_consumer_channel_type=wm_consumer_channel_type,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetMultiNodeInventoryForSkuAndAllShipnodes200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_multi_node_inventory_for_sku_and_all_shipnodes_without_preload_content(
        self,
        sku: Annotated[StrictStr, Field(description="An arbitrary alphanumeric unique ID, specified by the seller, which identifies each item. This will be used by the seller in the XSD file to refer to each item. Special characters in the sku needing encoding are: ':', '/', '?', '#', '[', ']', '@', '!', '$', '&', \"'\", '(', ')', '*', '+', ',', ';', '=', ‘ ’ as well as '%' itself if it's a part of sku. Make sure to encode space with %20. Other characters don't need to be encoded.")],
        wm_sec_access_token: Annotated[StrictStr, Field(description="The access token retrieved in the Token API call")],
        wm_qos_correlation_id: Annotated[StrictStr, Field(description="A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID")],
        wm_svc_name: Annotated[StrictStr, Field(description="Walmart Service Name")],
        ship_node: Annotated[Optional[StrictStr], Field(description="ShipNode Id of the ship node for which the inventory is requested")] = None,
        wm_consumer_channel_type: Annotated[Optional[StrictStr], Field(description="A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Single Item Inventory by Ship Node

        This API will retrieve the inventory count for an item across all ship nodes or one specific ship node. You can specify the ship node for which you want to fetch the inventory

        :param sku: An arbitrary alphanumeric unique ID, specified by the seller, which identifies each item. This will be used by the seller in the XSD file to refer to each item. Special characters in the sku needing encoding are: ':', '/', '?', '#', '[', ']', '@', '!', '$', '&', \"'\", '(', ')', '*', '+', ',', ';', '=', ‘ ’ as well as '%' itself if it's a part of sku. Make sure to encode space with %20. Other characters don't need to be encoded. (required)
        :type sku: str
        :param wm_sec_access_token: The access token retrieved in the Token API call (required)
        :type wm_sec_access_token: str
        :param wm_qos_correlation_id: A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID (required)
        :type wm_qos_correlation_id: str
        :param wm_svc_name: Walmart Service Name (required)
        :type wm_svc_name: str
        :param ship_node: ShipNode Id of the ship node for which the inventory is requested
        :type ship_node: str
        :param wm_consumer_channel_type: A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
        :type wm_consumer_channel_type: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_multi_node_inventory_for_sku_and_all_shipnodes_serialize(
            sku=sku,
            wm_sec_access_token=wm_sec_access_token,
            wm_qos_correlation_id=wm_qos_correlation_id,
            wm_svc_name=wm_svc_name,
            ship_node=ship_node,
            wm_consumer_channel_type=wm_consumer_channel_type,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetMultiNodeInventoryForSkuAndAllShipnodes200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_multi_node_inventory_for_sku_and_all_shipnodes_serialize(
        self,
        sku,
        wm_sec_access_token,
        wm_qos_correlation_id,
        wm_svc_name,
        ship_node,
        wm_consumer_channel_type,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if sku is not None:
            _path_params['sku'] = sku
        # process the query parameters
        if ship_node is not None:
            
            _query_params.append(('shipNode', ship_node))
            
        # process the header parameters
        if wm_sec_access_token is not None:
            _header_params['WM_SEC.ACCESS_TOKEN'] = wm_sec_access_token
        if wm_consumer_channel_type is not None:
            _header_params['WM_CONSUMER.CHANNEL.TYPE'] = wm_consumer_channel_type
        if wm_qos_correlation_id is not None:
            _header_params['WM_QOS.CORRELATION_ID'] = wm_qos_correlation_id
        if wm_svc_name is not None:
            _header_params['WM_SVC.NAME'] = wm_svc_name
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/v3/inventories/{sku}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_wfs_inventory(
        self,
        wm_sec_access_token: Annotated[StrictStr, Field(description="The access token retrieved in the Token API call")],
        wm_qos_correlation_id: Annotated[StrictStr, Field(description="A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID")],
        wm_svc_name: Annotated[StrictStr, Field(description="Walmart Service Name")],
        sku: Annotated[Optional[StrictStr], Field(description="An arbitrary alphanumeric unique ID, specified by the seller, which identifies each item. This will be used by the seller in the XSD file to refer to each item. Special characters in the sku needing encoding are: ':', '/', '?', '#', '[', ']', '@', '!', '$', '&', \"'\", '(', ')', '*', '+', ',', ';', '=', ‘ ’ as well as '%' itself if it's a part of sku. Make sure to encode space with %20. Other characters don't need to be encoded.")] = None,
        from_modified_date: Annotated[Optional[StrictStr], Field(description="last inventory modified date - starting range.")] = None,
        to_modified_date: Annotated[Optional[StrictStr], Field(description="last inventory modified date - starting range.")] = None,
        limit: Annotated[Optional[StrictStr], Field(description="Number of Sku to be returned. Cannot be larger than 300.")] = None,
        offset: Annotated[Optional[StrictStr], Field(description="Offset is the number of records you wish to skip before selecting records.")] = None,
        wm_consumer_channel_type: Annotated[Optional[StrictStr], Field(description="A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GetWFSInventory200Response:
        """WFS Inventory

        You can use this API to get the current Available to Sell inventory quantities for all WFS items in your catalog. You can also query specific SKUs or filter to only items updated after a specific date in order to reduce the response size.

        :param wm_sec_access_token: The access token retrieved in the Token API call (required)
        :type wm_sec_access_token: str
        :param wm_qos_correlation_id: A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID (required)
        :type wm_qos_correlation_id: str
        :param wm_svc_name: Walmart Service Name (required)
        :type wm_svc_name: str
        :param sku: An arbitrary alphanumeric unique ID, specified by the seller, which identifies each item. This will be used by the seller in the XSD file to refer to each item. Special characters in the sku needing encoding are: ':', '/', '?', '#', '[', ']', '@', '!', '$', '&', \"'\", '(', ')', '*', '+', ',', ';', '=', ‘ ’ as well as '%' itself if it's a part of sku. Make sure to encode space with %20. Other characters don't need to be encoded.
        :type sku: str
        :param from_modified_date: last inventory modified date - starting range.
        :type from_modified_date: str
        :param to_modified_date: last inventory modified date - starting range.
        :type to_modified_date: str
        :param limit: Number of Sku to be returned. Cannot be larger than 300.
        :type limit: str
        :param offset: Offset is the number of records you wish to skip before selecting records.
        :type offset: str
        :param wm_consumer_channel_type: A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
        :type wm_consumer_channel_type: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_wfs_inventory_serialize(
            wm_sec_access_token=wm_sec_access_token,
            wm_qos_correlation_id=wm_qos_correlation_id,
            wm_svc_name=wm_svc_name,
            sku=sku,
            from_modified_date=from_modified_date,
            to_modified_date=to_modified_date,
            limit=limit,
            offset=offset,
            wm_consumer_channel_type=wm_consumer_channel_type,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetWFSInventory200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_wfs_inventory_with_http_info(
        self,
        wm_sec_access_token: Annotated[StrictStr, Field(description="The access token retrieved in the Token API call")],
        wm_qos_correlation_id: Annotated[StrictStr, Field(description="A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID")],
        wm_svc_name: Annotated[StrictStr, Field(description="Walmart Service Name")],
        sku: Annotated[Optional[StrictStr], Field(description="An arbitrary alphanumeric unique ID, specified by the seller, which identifies each item. This will be used by the seller in the XSD file to refer to each item. Special characters in the sku needing encoding are: ':', '/', '?', '#', '[', ']', '@', '!', '$', '&', \"'\", '(', ')', '*', '+', ',', ';', '=', ‘ ’ as well as '%' itself if it's a part of sku. Make sure to encode space with %20. Other characters don't need to be encoded.")] = None,
        from_modified_date: Annotated[Optional[StrictStr], Field(description="last inventory modified date - starting range.")] = None,
        to_modified_date: Annotated[Optional[StrictStr], Field(description="last inventory modified date - starting range.")] = None,
        limit: Annotated[Optional[StrictStr], Field(description="Number of Sku to be returned. Cannot be larger than 300.")] = None,
        offset: Annotated[Optional[StrictStr], Field(description="Offset is the number of records you wish to skip before selecting records.")] = None,
        wm_consumer_channel_type: Annotated[Optional[StrictStr], Field(description="A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GetWFSInventory200Response]:
        """WFS Inventory

        You can use this API to get the current Available to Sell inventory quantities for all WFS items in your catalog. You can also query specific SKUs or filter to only items updated after a specific date in order to reduce the response size.

        :param wm_sec_access_token: The access token retrieved in the Token API call (required)
        :type wm_sec_access_token: str
        :param wm_qos_correlation_id: A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID (required)
        :type wm_qos_correlation_id: str
        :param wm_svc_name: Walmart Service Name (required)
        :type wm_svc_name: str
        :param sku: An arbitrary alphanumeric unique ID, specified by the seller, which identifies each item. This will be used by the seller in the XSD file to refer to each item. Special characters in the sku needing encoding are: ':', '/', '?', '#', '[', ']', '@', '!', '$', '&', \"'\", '(', ')', '*', '+', ',', ';', '=', ‘ ’ as well as '%' itself if it's a part of sku. Make sure to encode space with %20. Other characters don't need to be encoded.
        :type sku: str
        :param from_modified_date: last inventory modified date - starting range.
        :type from_modified_date: str
        :param to_modified_date: last inventory modified date - starting range.
        :type to_modified_date: str
        :param limit: Number of Sku to be returned. Cannot be larger than 300.
        :type limit: str
        :param offset: Offset is the number of records you wish to skip before selecting records.
        :type offset: str
        :param wm_consumer_channel_type: A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
        :type wm_consumer_channel_type: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_wfs_inventory_serialize(
            wm_sec_access_token=wm_sec_access_token,
            wm_qos_correlation_id=wm_qos_correlation_id,
            wm_svc_name=wm_svc_name,
            sku=sku,
            from_modified_date=from_modified_date,
            to_modified_date=to_modified_date,
            limit=limit,
            offset=offset,
            wm_consumer_channel_type=wm_consumer_channel_type,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetWFSInventory200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_wfs_inventory_without_preload_content(
        self,
        wm_sec_access_token: Annotated[StrictStr, Field(description="The access token retrieved in the Token API call")],
        wm_qos_correlation_id: Annotated[StrictStr, Field(description="A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID")],
        wm_svc_name: Annotated[StrictStr, Field(description="Walmart Service Name")],
        sku: Annotated[Optional[StrictStr], Field(description="An arbitrary alphanumeric unique ID, specified by the seller, which identifies each item. This will be used by the seller in the XSD file to refer to each item. Special characters in the sku needing encoding are: ':', '/', '?', '#', '[', ']', '@', '!', '$', '&', \"'\", '(', ')', '*', '+', ',', ';', '=', ‘ ’ as well as '%' itself if it's a part of sku. Make sure to encode space with %20. Other characters don't need to be encoded.")] = None,
        from_modified_date: Annotated[Optional[StrictStr], Field(description="last inventory modified date - starting range.")] = None,
        to_modified_date: Annotated[Optional[StrictStr], Field(description="last inventory modified date - starting range.")] = None,
        limit: Annotated[Optional[StrictStr], Field(description="Number of Sku to be returned. Cannot be larger than 300.")] = None,
        offset: Annotated[Optional[StrictStr], Field(description="Offset is the number of records you wish to skip before selecting records.")] = None,
        wm_consumer_channel_type: Annotated[Optional[StrictStr], Field(description="A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """WFS Inventory

        You can use this API to get the current Available to Sell inventory quantities for all WFS items in your catalog. You can also query specific SKUs or filter to only items updated after a specific date in order to reduce the response size.

        :param wm_sec_access_token: The access token retrieved in the Token API call (required)
        :type wm_sec_access_token: str
        :param wm_qos_correlation_id: A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID (required)
        :type wm_qos_correlation_id: str
        :param wm_svc_name: Walmart Service Name (required)
        :type wm_svc_name: str
        :param sku: An arbitrary alphanumeric unique ID, specified by the seller, which identifies each item. This will be used by the seller in the XSD file to refer to each item. Special characters in the sku needing encoding are: ':', '/', '?', '#', '[', ']', '@', '!', '$', '&', \"'\", '(', ')', '*', '+', ',', ';', '=', ‘ ’ as well as '%' itself if it's a part of sku. Make sure to encode space with %20. Other characters don't need to be encoded.
        :type sku: str
        :param from_modified_date: last inventory modified date - starting range.
        :type from_modified_date: str
        :param to_modified_date: last inventory modified date - starting range.
        :type to_modified_date: str
        :param limit: Number of Sku to be returned. Cannot be larger than 300.
        :type limit: str
        :param offset: Offset is the number of records you wish to skip before selecting records.
        :type offset: str
        :param wm_consumer_channel_type: A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
        :type wm_consumer_channel_type: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_wfs_inventory_serialize(
            wm_sec_access_token=wm_sec_access_token,
            wm_qos_correlation_id=wm_qos_correlation_id,
            wm_svc_name=wm_svc_name,
            sku=sku,
            from_modified_date=from_modified_date,
            to_modified_date=to_modified_date,
            limit=limit,
            offset=offset,
            wm_consumer_channel_type=wm_consumer_channel_type,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetWFSInventory200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_wfs_inventory_serialize(
        self,
        wm_sec_access_token,
        wm_qos_correlation_id,
        wm_svc_name,
        sku,
        from_modified_date,
        to_modified_date,
        limit,
        offset,
        wm_consumer_channel_type,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if sku is not None:
            
            _query_params.append(('sku', sku))
            
        if from_modified_date is not None:
            
            _query_params.append(('fromModifiedDate', from_modified_date))
            
        if to_modified_date is not None:
            
            _query_params.append(('toModifiedDate', to_modified_date))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        if offset is not None:
            
            _query_params.append(('offset', offset))
            
        # process the header parameters
        if wm_sec_access_token is not None:
            _header_params['WM_SEC.ACCESS_TOKEN'] = wm_sec_access_token
        if wm_consumer_channel_type is not None:
            _header_params['WM_CONSUMER.CHANNEL.TYPE'] = wm_consumer_channel_type
        if wm_qos_correlation_id is not None:
            _header_params['WM_QOS.CORRELATION_ID'] = wm_qos_correlation_id
        if wm_svc_name is not None:
            _header_params['WM_SVC.NAME'] = wm_svc_name
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/v3/fulfillment/inventory',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def update_bulk_inventory(
        self,
        feed_type: Annotated[StrictStr, Field(description="The feed Type")],
        wm_sec_access_token: Annotated[StrictStr, Field(description="The access token retrieved in the Token API call")],
        wm_qos_correlation_id: Annotated[StrictStr, Field(description="A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID")],
        wm_svc_name: Annotated[StrictStr, Field(description="Walmart Service Name")],
        file: Annotated[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]], Field(description="Feed file to upload")],
        ship_node: Annotated[Optional[StrictStr], Field(description="The shipNode for which the inventory is to be updated. Not required in case of Multi Node Inventory Update Feed (feedType=MP_INVENTORY)")] = None,
        wm_consumer_channel_type: Annotated[Optional[StrictStr], Field(description="A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> UpdateBulkInventory200Response:
        """Bulk Item Inventory Update

        Updates inventory for items in bulk.  Seller Can either use feed type \"inventory\" or \"MP_INVENTORY\"  * Inventory spec 1.4 feed type: inventory  * Inventory spec 1.5 feed type: MP_INVENTORY   Please Note: Multi Node Inventory Update Feed (feedType=MP_INVENTORY) only supports JSON Request and Responses. Refer to \"MultiNode_Bulk_Inventory_Update_Request.json\" for the corresponding request sample    Refer to the <a href=\"https://developer.walmart.com/doc/us/us-mp/us-mp-inventory/\">guide section</a> for more detailed guide around each of the feed types    Refer to the throttling limits before uploading the Feed Files.

        :param feed_type: The feed Type (required)
        :type feed_type: str
        :param wm_sec_access_token: The access token retrieved in the Token API call (required)
        :type wm_sec_access_token: str
        :param wm_qos_correlation_id: A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID (required)
        :type wm_qos_correlation_id: str
        :param wm_svc_name: Walmart Service Name (required)
        :type wm_svc_name: str
        :param file: Feed file to upload (required)
        :type file: bytearray
        :param ship_node: The shipNode for which the inventory is to be updated. Not required in case of Multi Node Inventory Update Feed (feedType=MP_INVENTORY)
        :type ship_node: str
        :param wm_consumer_channel_type: A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
        :type wm_consumer_channel_type: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_bulk_inventory_serialize(
            feed_type=feed_type,
            wm_sec_access_token=wm_sec_access_token,
            wm_qos_correlation_id=wm_qos_correlation_id,
            wm_svc_name=wm_svc_name,
            file=file,
            ship_node=ship_node,
            wm_consumer_channel_type=wm_consumer_channel_type,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "UpdateBulkInventory200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def update_bulk_inventory_with_http_info(
        self,
        feed_type: Annotated[StrictStr, Field(description="The feed Type")],
        wm_sec_access_token: Annotated[StrictStr, Field(description="The access token retrieved in the Token API call")],
        wm_qos_correlation_id: Annotated[StrictStr, Field(description="A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID")],
        wm_svc_name: Annotated[StrictStr, Field(description="Walmart Service Name")],
        file: Annotated[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]], Field(description="Feed file to upload")],
        ship_node: Annotated[Optional[StrictStr], Field(description="The shipNode for which the inventory is to be updated. Not required in case of Multi Node Inventory Update Feed (feedType=MP_INVENTORY)")] = None,
        wm_consumer_channel_type: Annotated[Optional[StrictStr], Field(description="A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[UpdateBulkInventory200Response]:
        """Bulk Item Inventory Update

        Updates inventory for items in bulk.  Seller Can either use feed type \"inventory\" or \"MP_INVENTORY\"  * Inventory spec 1.4 feed type: inventory  * Inventory spec 1.5 feed type: MP_INVENTORY   Please Note: Multi Node Inventory Update Feed (feedType=MP_INVENTORY) only supports JSON Request and Responses. Refer to \"MultiNode_Bulk_Inventory_Update_Request.json\" for the corresponding request sample    Refer to the <a href=\"https://developer.walmart.com/doc/us/us-mp/us-mp-inventory/\">guide section</a> for more detailed guide around each of the feed types    Refer to the throttling limits before uploading the Feed Files.

        :param feed_type: The feed Type (required)
        :type feed_type: str
        :param wm_sec_access_token: The access token retrieved in the Token API call (required)
        :type wm_sec_access_token: str
        :param wm_qos_correlation_id: A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID (required)
        :type wm_qos_correlation_id: str
        :param wm_svc_name: Walmart Service Name (required)
        :type wm_svc_name: str
        :param file: Feed file to upload (required)
        :type file: bytearray
        :param ship_node: The shipNode for which the inventory is to be updated. Not required in case of Multi Node Inventory Update Feed (feedType=MP_INVENTORY)
        :type ship_node: str
        :param wm_consumer_channel_type: A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
        :type wm_consumer_channel_type: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_bulk_inventory_serialize(
            feed_type=feed_type,
            wm_sec_access_token=wm_sec_access_token,
            wm_qos_correlation_id=wm_qos_correlation_id,
            wm_svc_name=wm_svc_name,
            file=file,
            ship_node=ship_node,
            wm_consumer_channel_type=wm_consumer_channel_type,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "UpdateBulkInventory200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def update_bulk_inventory_without_preload_content(
        self,
        feed_type: Annotated[StrictStr, Field(description="The feed Type")],
        wm_sec_access_token: Annotated[StrictStr, Field(description="The access token retrieved in the Token API call")],
        wm_qos_correlation_id: Annotated[StrictStr, Field(description="A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID")],
        wm_svc_name: Annotated[StrictStr, Field(description="Walmart Service Name")],
        file: Annotated[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]], Field(description="Feed file to upload")],
        ship_node: Annotated[Optional[StrictStr], Field(description="The shipNode for which the inventory is to be updated. Not required in case of Multi Node Inventory Update Feed (feedType=MP_INVENTORY)")] = None,
        wm_consumer_channel_type: Annotated[Optional[StrictStr], Field(description="A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Bulk Item Inventory Update

        Updates inventory for items in bulk.  Seller Can either use feed type \"inventory\" or \"MP_INVENTORY\"  * Inventory spec 1.4 feed type: inventory  * Inventory spec 1.5 feed type: MP_INVENTORY   Please Note: Multi Node Inventory Update Feed (feedType=MP_INVENTORY) only supports JSON Request and Responses. Refer to \"MultiNode_Bulk_Inventory_Update_Request.json\" for the corresponding request sample    Refer to the <a href=\"https://developer.walmart.com/doc/us/us-mp/us-mp-inventory/\">guide section</a> for more detailed guide around each of the feed types    Refer to the throttling limits before uploading the Feed Files.

        :param feed_type: The feed Type (required)
        :type feed_type: str
        :param wm_sec_access_token: The access token retrieved in the Token API call (required)
        :type wm_sec_access_token: str
        :param wm_qos_correlation_id: A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID (required)
        :type wm_qos_correlation_id: str
        :param wm_svc_name: Walmart Service Name (required)
        :type wm_svc_name: str
        :param file: Feed file to upload (required)
        :type file: bytearray
        :param ship_node: The shipNode for which the inventory is to be updated. Not required in case of Multi Node Inventory Update Feed (feedType=MP_INVENTORY)
        :type ship_node: str
        :param wm_consumer_channel_type: A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
        :type wm_consumer_channel_type: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_bulk_inventory_serialize(
            feed_type=feed_type,
            wm_sec_access_token=wm_sec_access_token,
            wm_qos_correlation_id=wm_qos_correlation_id,
            wm_svc_name=wm_svc_name,
            file=file,
            ship_node=ship_node,
            wm_consumer_channel_type=wm_consumer_channel_type,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "UpdateBulkInventory200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _update_bulk_inventory_serialize(
        self,
        feed_type,
        wm_sec_access_token,
        wm_qos_correlation_id,
        wm_svc_name,
        file,
        ship_node,
        wm_consumer_channel_type,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if feed_type is not None:
            
            _query_params.append(('feedType', feed_type))
            
        if ship_node is not None:
            
            _query_params.append(('shipNode', ship_node))
            
        # process the header parameters
        if wm_sec_access_token is not None:
            _header_params['WM_SEC.ACCESS_TOKEN'] = wm_sec_access_token
        if wm_consumer_channel_type is not None:
            _header_params['WM_CONSUMER.CHANNEL.TYPE'] = wm_consumer_channel_type
        if wm_qos_correlation_id is not None:
            _header_params['WM_QOS.CORRELATION_ID'] = wm_qos_correlation_id
        if wm_svc_name is not None:
            _header_params['WM_SVC.NAME'] = wm_svc_name
        # process the form parameters
        if file is not None:
            _files['file'] = file
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json', 
                    'application/xml'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'multipart/form-data'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/v3/feeds',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def update_inventory_for_an_item(
        self,
        sku: Annotated[StrictStr, Field(description="An arbitrary alphanumeric unique ID, specified by the seller, which identifies each item. This will be used by the seller in the XSD file to refer to each item. Special characters in the sku needing encoding are: ':', '/', '?', '#', '[', ']', '@', '!', '$', '&', \"'\", '(', ')', '*', '+', ',', ';', '=', ‘ ’, '{', '}' as well as '%' itself if it's a part of sku. Make sure to encode space with %20. Other characters don't need to be encoded.")],
        wm_sec_access_token: Annotated[StrictStr, Field(description="The access token retrieved in the Token API call")],
        wm_qos_correlation_id: Annotated[StrictStr, Field(description="A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID")],
        wm_svc_name: Annotated[StrictStr, Field(description="Walmart Service Name")],
        get_inventory200_response: Annotated[GetInventory200Response, Field(description="File fields")],
        ship_node: Annotated[Optional[StrictStr], Field(description="The shipNode for which the inventory is to be updated.")] = None,
        wm_consumer_channel_type: Annotated[Optional[StrictStr], Field(description="A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GetInventory200Response:
        """Update inventory

        Updates the inventory for a given item.

        :param sku: An arbitrary alphanumeric unique ID, specified by the seller, which identifies each item. This will be used by the seller in the XSD file to refer to each item. Special characters in the sku needing encoding are: ':', '/', '?', '#', '[', ']', '@', '!', '$', '&', \"'\", '(', ')', '*', '+', ',', ';', '=', ‘ ’, '{', '}' as well as '%' itself if it's a part of sku. Make sure to encode space with %20. Other characters don't need to be encoded. (required)
        :type sku: str
        :param wm_sec_access_token: The access token retrieved in the Token API call (required)
        :type wm_sec_access_token: str
        :param wm_qos_correlation_id: A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID (required)
        :type wm_qos_correlation_id: str
        :param wm_svc_name: Walmart Service Name (required)
        :type wm_svc_name: str
        :param get_inventory200_response: File fields (required)
        :type get_inventory200_response: GetInventory200Response
        :param ship_node: The shipNode for which the inventory is to be updated.
        :type ship_node: str
        :param wm_consumer_channel_type: A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
        :type wm_consumer_channel_type: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_inventory_for_an_item_serialize(
            sku=sku,
            wm_sec_access_token=wm_sec_access_token,
            wm_qos_correlation_id=wm_qos_correlation_id,
            wm_svc_name=wm_svc_name,
            get_inventory200_response=get_inventory200_response,
            ship_node=ship_node,
            wm_consumer_channel_type=wm_consumer_channel_type,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetInventory200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def update_inventory_for_an_item_with_http_info(
        self,
        sku: Annotated[StrictStr, Field(description="An arbitrary alphanumeric unique ID, specified by the seller, which identifies each item. This will be used by the seller in the XSD file to refer to each item. Special characters in the sku needing encoding are: ':', '/', '?', '#', '[', ']', '@', '!', '$', '&', \"'\", '(', ')', '*', '+', ',', ';', '=', ‘ ’, '{', '}' as well as '%' itself if it's a part of sku. Make sure to encode space with %20. Other characters don't need to be encoded.")],
        wm_sec_access_token: Annotated[StrictStr, Field(description="The access token retrieved in the Token API call")],
        wm_qos_correlation_id: Annotated[StrictStr, Field(description="A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID")],
        wm_svc_name: Annotated[StrictStr, Field(description="Walmart Service Name")],
        get_inventory200_response: Annotated[GetInventory200Response, Field(description="File fields")],
        ship_node: Annotated[Optional[StrictStr], Field(description="The shipNode for which the inventory is to be updated.")] = None,
        wm_consumer_channel_type: Annotated[Optional[StrictStr], Field(description="A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GetInventory200Response]:
        """Update inventory

        Updates the inventory for a given item.

        :param sku: An arbitrary alphanumeric unique ID, specified by the seller, which identifies each item. This will be used by the seller in the XSD file to refer to each item. Special characters in the sku needing encoding are: ':', '/', '?', '#', '[', ']', '@', '!', '$', '&', \"'\", '(', ')', '*', '+', ',', ';', '=', ‘ ’, '{', '}' as well as '%' itself if it's a part of sku. Make sure to encode space with %20. Other characters don't need to be encoded. (required)
        :type sku: str
        :param wm_sec_access_token: The access token retrieved in the Token API call (required)
        :type wm_sec_access_token: str
        :param wm_qos_correlation_id: A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID (required)
        :type wm_qos_correlation_id: str
        :param wm_svc_name: Walmart Service Name (required)
        :type wm_svc_name: str
        :param get_inventory200_response: File fields (required)
        :type get_inventory200_response: GetInventory200Response
        :param ship_node: The shipNode for which the inventory is to be updated.
        :type ship_node: str
        :param wm_consumer_channel_type: A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
        :type wm_consumer_channel_type: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_inventory_for_an_item_serialize(
            sku=sku,
            wm_sec_access_token=wm_sec_access_token,
            wm_qos_correlation_id=wm_qos_correlation_id,
            wm_svc_name=wm_svc_name,
            get_inventory200_response=get_inventory200_response,
            ship_node=ship_node,
            wm_consumer_channel_type=wm_consumer_channel_type,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetInventory200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def update_inventory_for_an_item_without_preload_content(
        self,
        sku: Annotated[StrictStr, Field(description="An arbitrary alphanumeric unique ID, specified by the seller, which identifies each item. This will be used by the seller in the XSD file to refer to each item. Special characters in the sku needing encoding are: ':', '/', '?', '#', '[', ']', '@', '!', '$', '&', \"'\", '(', ')', '*', '+', ',', ';', '=', ‘ ’, '{', '}' as well as '%' itself if it's a part of sku. Make sure to encode space with %20. Other characters don't need to be encoded.")],
        wm_sec_access_token: Annotated[StrictStr, Field(description="The access token retrieved in the Token API call")],
        wm_qos_correlation_id: Annotated[StrictStr, Field(description="A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID")],
        wm_svc_name: Annotated[StrictStr, Field(description="Walmart Service Name")],
        get_inventory200_response: Annotated[GetInventory200Response, Field(description="File fields")],
        ship_node: Annotated[Optional[StrictStr], Field(description="The shipNode for which the inventory is to be updated.")] = None,
        wm_consumer_channel_type: Annotated[Optional[StrictStr], Field(description="A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Update inventory

        Updates the inventory for a given item.

        :param sku: An arbitrary alphanumeric unique ID, specified by the seller, which identifies each item. This will be used by the seller in the XSD file to refer to each item. Special characters in the sku needing encoding are: ':', '/', '?', '#', '[', ']', '@', '!', '$', '&', \"'\", '(', ')', '*', '+', ',', ';', '=', ‘ ’, '{', '}' as well as '%' itself if it's a part of sku. Make sure to encode space with %20. Other characters don't need to be encoded. (required)
        :type sku: str
        :param wm_sec_access_token: The access token retrieved in the Token API call (required)
        :type wm_sec_access_token: str
        :param wm_qos_correlation_id: A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID (required)
        :type wm_qos_correlation_id: str
        :param wm_svc_name: Walmart Service Name (required)
        :type wm_svc_name: str
        :param get_inventory200_response: File fields (required)
        :type get_inventory200_response: GetInventory200Response
        :param ship_node: The shipNode for which the inventory is to be updated.
        :type ship_node: str
        :param wm_consumer_channel_type: A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
        :type wm_consumer_channel_type: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_inventory_for_an_item_serialize(
            sku=sku,
            wm_sec_access_token=wm_sec_access_token,
            wm_qos_correlation_id=wm_qos_correlation_id,
            wm_svc_name=wm_svc_name,
            get_inventory200_response=get_inventory200_response,
            ship_node=ship_node,
            wm_consumer_channel_type=wm_consumer_channel_type,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetInventory200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _update_inventory_for_an_item_serialize(
        self,
        sku,
        wm_sec_access_token,
        wm_qos_correlation_id,
        wm_svc_name,
        get_inventory200_response,
        ship_node,
        wm_consumer_channel_type,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if sku is not None:
            
            _query_params.append(('sku', sku))
            
        if ship_node is not None:
            
            _query_params.append(('shipNode', ship_node))
            
        # process the header parameters
        if wm_sec_access_token is not None:
            _header_params['WM_SEC.ACCESS_TOKEN'] = wm_sec_access_token
        if wm_consumer_channel_type is not None:
            _header_params['WM_CONSUMER.CHANNEL.TYPE'] = wm_consumer_channel_type
        if wm_qos_correlation_id is not None:
            _header_params['WM_QOS.CORRELATION_ID'] = wm_qos_correlation_id
        if wm_svc_name is not None:
            _header_params['WM_SVC.NAME'] = wm_svc_name
        # process the form parameters
        # process the body parameter
        if get_inventory200_response is not None:
            _body_params = get_inventory200_response


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json', 
                    'application/xml'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json', 
                        'application/xml'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='PUT',
            resource_path='/v3/inventory',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def update_multi_node_inventory(
        self,
        sku: Annotated[StrictStr, Field(description="An arbitrary alphanumeric unique ID, specified by the seller, which identifies each item. This will be used by the seller in the XSD file to refer to each item. Special characters in the sku needing encoding are: ':', '/', '?', '#', '[', ']', '@', '!', '$', '&', \"'\", '(', ')', '*', '+', ',', ';', '=', ‘ ’ as well as '%' itself if it's a part of sku. Make sure to encode space with %20. Other characters don't need to be encoded.")],
        wm_sec_access_token: Annotated[StrictStr, Field(description="The access token retrieved in the Token API call")],
        wm_qos_correlation_id: Annotated[StrictStr, Field(description="A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID")],
        wm_svc_name: Annotated[StrictStr, Field(description="Walmart Service Name")],
        update_multi_node_inventory_request: Annotated[UpdateMultiNodeInventoryRequest, Field(description="Request fields")],
        wm_consumer_channel_type: Annotated[Optional[StrictStr], Field(description="A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> UpdateMultiNodeInventory200Response:
        """Update Item Inventory per Ship Node

        This API will update the inventory for an item across one or more fulfillment centers, known as ship nodes.

        :param sku: An arbitrary alphanumeric unique ID, specified by the seller, which identifies each item. This will be used by the seller in the XSD file to refer to each item. Special characters in the sku needing encoding are: ':', '/', '?', '#', '[', ']', '@', '!', '$', '&', \"'\", '(', ')', '*', '+', ',', ';', '=', ‘ ’ as well as '%' itself if it's a part of sku. Make sure to encode space with %20. Other characters don't need to be encoded. (required)
        :type sku: str
        :param wm_sec_access_token: The access token retrieved in the Token API call (required)
        :type wm_sec_access_token: str
        :param wm_qos_correlation_id: A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID (required)
        :type wm_qos_correlation_id: str
        :param wm_svc_name: Walmart Service Name (required)
        :type wm_svc_name: str
        :param update_multi_node_inventory_request: Request fields (required)
        :type update_multi_node_inventory_request: UpdateMultiNodeInventoryRequest
        :param wm_consumer_channel_type: A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
        :type wm_consumer_channel_type: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_multi_node_inventory_serialize(
            sku=sku,
            wm_sec_access_token=wm_sec_access_token,
            wm_qos_correlation_id=wm_qos_correlation_id,
            wm_svc_name=wm_svc_name,
            update_multi_node_inventory_request=update_multi_node_inventory_request,
            wm_consumer_channel_type=wm_consumer_channel_type,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "UpdateMultiNodeInventory200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def update_multi_node_inventory_with_http_info(
        self,
        sku: Annotated[StrictStr, Field(description="An arbitrary alphanumeric unique ID, specified by the seller, which identifies each item. This will be used by the seller in the XSD file to refer to each item. Special characters in the sku needing encoding are: ':', '/', '?', '#', '[', ']', '@', '!', '$', '&', \"'\", '(', ')', '*', '+', ',', ';', '=', ‘ ’ as well as '%' itself if it's a part of sku. Make sure to encode space with %20. Other characters don't need to be encoded.")],
        wm_sec_access_token: Annotated[StrictStr, Field(description="The access token retrieved in the Token API call")],
        wm_qos_correlation_id: Annotated[StrictStr, Field(description="A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID")],
        wm_svc_name: Annotated[StrictStr, Field(description="Walmart Service Name")],
        update_multi_node_inventory_request: Annotated[UpdateMultiNodeInventoryRequest, Field(description="Request fields")],
        wm_consumer_channel_type: Annotated[Optional[StrictStr], Field(description="A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[UpdateMultiNodeInventory200Response]:
        """Update Item Inventory per Ship Node

        This API will update the inventory for an item across one or more fulfillment centers, known as ship nodes.

        :param sku: An arbitrary alphanumeric unique ID, specified by the seller, which identifies each item. This will be used by the seller in the XSD file to refer to each item. Special characters in the sku needing encoding are: ':', '/', '?', '#', '[', ']', '@', '!', '$', '&', \"'\", '(', ')', '*', '+', ',', ';', '=', ‘ ’ as well as '%' itself if it's a part of sku. Make sure to encode space with %20. Other characters don't need to be encoded. (required)
        :type sku: str
        :param wm_sec_access_token: The access token retrieved in the Token API call (required)
        :type wm_sec_access_token: str
        :param wm_qos_correlation_id: A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID (required)
        :type wm_qos_correlation_id: str
        :param wm_svc_name: Walmart Service Name (required)
        :type wm_svc_name: str
        :param update_multi_node_inventory_request: Request fields (required)
        :type update_multi_node_inventory_request: UpdateMultiNodeInventoryRequest
        :param wm_consumer_channel_type: A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
        :type wm_consumer_channel_type: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_multi_node_inventory_serialize(
            sku=sku,
            wm_sec_access_token=wm_sec_access_token,
            wm_qos_correlation_id=wm_qos_correlation_id,
            wm_svc_name=wm_svc_name,
            update_multi_node_inventory_request=update_multi_node_inventory_request,
            wm_consumer_channel_type=wm_consumer_channel_type,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "UpdateMultiNodeInventory200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def update_multi_node_inventory_without_preload_content(
        self,
        sku: Annotated[StrictStr, Field(description="An arbitrary alphanumeric unique ID, specified by the seller, which identifies each item. This will be used by the seller in the XSD file to refer to each item. Special characters in the sku needing encoding are: ':', '/', '?', '#', '[', ']', '@', '!', '$', '&', \"'\", '(', ')', '*', '+', ',', ';', '=', ‘ ’ as well as '%' itself if it's a part of sku. Make sure to encode space with %20. Other characters don't need to be encoded.")],
        wm_sec_access_token: Annotated[StrictStr, Field(description="The access token retrieved in the Token API call")],
        wm_qos_correlation_id: Annotated[StrictStr, Field(description="A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID")],
        wm_svc_name: Annotated[StrictStr, Field(description="Walmart Service Name")],
        update_multi_node_inventory_request: Annotated[UpdateMultiNodeInventoryRequest, Field(description="Request fields")],
        wm_consumer_channel_type: Annotated[Optional[StrictStr], Field(description="A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Update Item Inventory per Ship Node

        This API will update the inventory for an item across one or more fulfillment centers, known as ship nodes.

        :param sku: An arbitrary alphanumeric unique ID, specified by the seller, which identifies each item. This will be used by the seller in the XSD file to refer to each item. Special characters in the sku needing encoding are: ':', '/', '?', '#', '[', ']', '@', '!', '$', '&', \"'\", '(', ')', '*', '+', ',', ';', '=', ‘ ’ as well as '%' itself if it's a part of sku. Make sure to encode space with %20. Other characters don't need to be encoded. (required)
        :type sku: str
        :param wm_sec_access_token: The access token retrieved in the Token API call (required)
        :type wm_sec_access_token: str
        :param wm_qos_correlation_id: A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID (required)
        :type wm_qos_correlation_id: str
        :param wm_svc_name: Walmart Service Name (required)
        :type wm_svc_name: str
        :param update_multi_node_inventory_request: Request fields (required)
        :type update_multi_node_inventory_request: UpdateMultiNodeInventoryRequest
        :param wm_consumer_channel_type: A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
        :type wm_consumer_channel_type: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_multi_node_inventory_serialize(
            sku=sku,
            wm_sec_access_token=wm_sec_access_token,
            wm_qos_correlation_id=wm_qos_correlation_id,
            wm_svc_name=wm_svc_name,
            update_multi_node_inventory_request=update_multi_node_inventory_request,
            wm_consumer_channel_type=wm_consumer_channel_type,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "UpdateMultiNodeInventory200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _update_multi_node_inventory_serialize(
        self,
        sku,
        wm_sec_access_token,
        wm_qos_correlation_id,
        wm_svc_name,
        update_multi_node_inventory_request,
        wm_consumer_channel_type,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if sku is not None:
            _path_params['sku'] = sku
        # process the query parameters
        # process the header parameters
        if wm_sec_access_token is not None:
            _header_params['WM_SEC.ACCESS_TOKEN'] = wm_sec_access_token
        if wm_consumer_channel_type is not None:
            _header_params['WM_CONSUMER.CHANNEL.TYPE'] = wm_consumer_channel_type
        if wm_qos_correlation_id is not None:
            _header_params['WM_QOS.CORRELATION_ID'] = wm_qos_correlation_id
        if wm_svc_name is not None:
            _header_params['WM_SVC.NAME'] = wm_svc_name
        # process the form parameters
        # process the body parameter
        if update_multi_node_inventory_request is not None:
            _body_params = update_multi_node_inventory_request


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='PUT',
            resource_path='/v3/inventories/{sku}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )


