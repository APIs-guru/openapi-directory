# coding: utf-8

"""
    Orders API

    Please make sure you use the correct version of the APIs for your use case. To find out the appropriate version, go to the API Docs  drop down on the menu.

    The version of the OpenAPI document: 3.0.1
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501

import warnings
from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
from typing import Any, Dict, List, Optional, Tuple, Union
from typing_extensions import Annotated

from pydantic import Field, StrictInt, StrictStr, field_validator
from typing import Optional
from typing_extensions import Annotated

from openapi_client.api_client import ApiClient, RequestSerialized
from openapi_client.api_response import ApiResponse
from openapi_client.rest import RESTResponseType


class Version3Api:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client


    @validate_call
    def acknowledge_orders(
        self,
        purchase_order_id: Annotated[StrictStr, Field(description="Purchase Order ID")],
        content_type: Annotated[StrictStr, Field(description="application/xml, application/json")],
        accept: Annotated[StrictStr, Field(description="application/xml, application/json")],
        wm_consumer_channel_type: Annotated[StrictStr, Field(description="Channel Type")],
        wm_consumer_id: Annotated[StrictStr, Field(description="Your Consumer ID")],
        wm_sec_timestamp: Annotated[StrictStr, Field(description="Epoch timestamp")],
        wm_sec_auth_signature: Annotated[StrictStr, Field(description="Authentication signature")],
        wm_svc_name: Annotated[StrictStr, Field(description="The Service name")],
        wm_qos_correlation_id: Annotated[StrictStr, Field(description="A Transaction ID")],
        ship_node: Annotated[Optional[StrictStr], Field(description="Ship Node")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """Acknowledge orders

        You can acknowledge an entire order, including all of its order lines. Walmart business rules require to acknowledge orders within four hour of receipt of the order, except in extenuating circumstances.

        :param purchase_order_id: Purchase Order ID (required)
        :type purchase_order_id: str
        :param content_type: application/xml, application/json (required)
        :type content_type: str
        :param accept: application/xml, application/json (required)
        :type accept: str
        :param wm_consumer_channel_type: Channel Type (required)
        :type wm_consumer_channel_type: str
        :param wm_consumer_id: Your Consumer ID (required)
        :type wm_consumer_id: str
        :param wm_sec_timestamp: Epoch timestamp (required)
        :type wm_sec_timestamp: str
        :param wm_sec_auth_signature: Authentication signature (required)
        :type wm_sec_auth_signature: str
        :param wm_svc_name: The Service name (required)
        :type wm_svc_name: str
        :param wm_qos_correlation_id: A Transaction ID (required)
        :type wm_qos_correlation_id: str
        :param ship_node: Ship Node
        :type ship_node: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._acknowledge_orders_serialize(
            purchase_order_id=purchase_order_id,
            content_type=content_type,
            accept=accept,
            wm_consumer_channel_type=wm_consumer_channel_type,
            wm_consumer_id=wm_consumer_id,
            wm_sec_timestamp=wm_sec_timestamp,
            wm_sec_auth_signature=wm_sec_auth_signature,
            wm_svc_name=wm_svc_name,
            wm_qos_correlation_id=wm_qos_correlation_id,
            ship_node=ship_node,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def acknowledge_orders_with_http_info(
        self,
        purchase_order_id: Annotated[StrictStr, Field(description="Purchase Order ID")],
        content_type: Annotated[StrictStr, Field(description="application/xml, application/json")],
        accept: Annotated[StrictStr, Field(description="application/xml, application/json")],
        wm_consumer_channel_type: Annotated[StrictStr, Field(description="Channel Type")],
        wm_consumer_id: Annotated[StrictStr, Field(description="Your Consumer ID")],
        wm_sec_timestamp: Annotated[StrictStr, Field(description="Epoch timestamp")],
        wm_sec_auth_signature: Annotated[StrictStr, Field(description="Authentication signature")],
        wm_svc_name: Annotated[StrictStr, Field(description="The Service name")],
        wm_qos_correlation_id: Annotated[StrictStr, Field(description="A Transaction ID")],
        ship_node: Annotated[Optional[StrictStr], Field(description="Ship Node")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """Acknowledge orders

        You can acknowledge an entire order, including all of its order lines. Walmart business rules require to acknowledge orders within four hour of receipt of the order, except in extenuating circumstances.

        :param purchase_order_id: Purchase Order ID (required)
        :type purchase_order_id: str
        :param content_type: application/xml, application/json (required)
        :type content_type: str
        :param accept: application/xml, application/json (required)
        :type accept: str
        :param wm_consumer_channel_type: Channel Type (required)
        :type wm_consumer_channel_type: str
        :param wm_consumer_id: Your Consumer ID (required)
        :type wm_consumer_id: str
        :param wm_sec_timestamp: Epoch timestamp (required)
        :type wm_sec_timestamp: str
        :param wm_sec_auth_signature: Authentication signature (required)
        :type wm_sec_auth_signature: str
        :param wm_svc_name: The Service name (required)
        :type wm_svc_name: str
        :param wm_qos_correlation_id: A Transaction ID (required)
        :type wm_qos_correlation_id: str
        :param ship_node: Ship Node
        :type ship_node: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._acknowledge_orders_serialize(
            purchase_order_id=purchase_order_id,
            content_type=content_type,
            accept=accept,
            wm_consumer_channel_type=wm_consumer_channel_type,
            wm_consumer_id=wm_consumer_id,
            wm_sec_timestamp=wm_sec_timestamp,
            wm_sec_auth_signature=wm_sec_auth_signature,
            wm_svc_name=wm_svc_name,
            wm_qos_correlation_id=wm_qos_correlation_id,
            ship_node=ship_node,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def acknowledge_orders_without_preload_content(
        self,
        purchase_order_id: Annotated[StrictStr, Field(description="Purchase Order ID")],
        content_type: Annotated[StrictStr, Field(description="application/xml, application/json")],
        accept: Annotated[StrictStr, Field(description="application/xml, application/json")],
        wm_consumer_channel_type: Annotated[StrictStr, Field(description="Channel Type")],
        wm_consumer_id: Annotated[StrictStr, Field(description="Your Consumer ID")],
        wm_sec_timestamp: Annotated[StrictStr, Field(description="Epoch timestamp")],
        wm_sec_auth_signature: Annotated[StrictStr, Field(description="Authentication signature")],
        wm_svc_name: Annotated[StrictStr, Field(description="The Service name")],
        wm_qos_correlation_id: Annotated[StrictStr, Field(description="A Transaction ID")],
        ship_node: Annotated[Optional[StrictStr], Field(description="Ship Node")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Acknowledge orders

        You can acknowledge an entire order, including all of its order lines. Walmart business rules require to acknowledge orders within four hour of receipt of the order, except in extenuating circumstances.

        :param purchase_order_id: Purchase Order ID (required)
        :type purchase_order_id: str
        :param content_type: application/xml, application/json (required)
        :type content_type: str
        :param accept: application/xml, application/json (required)
        :type accept: str
        :param wm_consumer_channel_type: Channel Type (required)
        :type wm_consumer_channel_type: str
        :param wm_consumer_id: Your Consumer ID (required)
        :type wm_consumer_id: str
        :param wm_sec_timestamp: Epoch timestamp (required)
        :type wm_sec_timestamp: str
        :param wm_sec_auth_signature: Authentication signature (required)
        :type wm_sec_auth_signature: str
        :param wm_svc_name: The Service name (required)
        :type wm_svc_name: str
        :param wm_qos_correlation_id: A Transaction ID (required)
        :type wm_qos_correlation_id: str
        :param ship_node: Ship Node
        :type ship_node: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._acknowledge_orders_serialize(
            purchase_order_id=purchase_order_id,
            content_type=content_type,
            accept=accept,
            wm_consumer_channel_type=wm_consumer_channel_type,
            wm_consumer_id=wm_consumer_id,
            wm_sec_timestamp=wm_sec_timestamp,
            wm_sec_auth_signature=wm_sec_auth_signature,
            wm_svc_name=wm_svc_name,
            wm_qos_correlation_id=wm_qos_correlation_id,
            ship_node=ship_node,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _acknowledge_orders_serialize(
        self,
        purchase_order_id,
        content_type,
        accept,
        wm_consumer_channel_type,
        wm_consumer_id,
        wm_sec_timestamp,
        wm_sec_auth_signature,
        wm_svc_name,
        wm_qos_correlation_id,
        ship_node,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if purchase_order_id is not None:
            _path_params['purchaseOrderId'] = purchase_order_id
        # process the query parameters
        if ship_node is not None:
            
            _query_params.append(('shipNode', ship_node))
            
        # process the header parameters
        if content_type is not None:
            _header_params['Content-Type'] = content_type
        if accept is not None:
            _header_params['Accept'] = accept
        if wm_consumer_channel_type is not None:
            _header_params['WM_CONSUMER.CHANNEL.TYPE'] = wm_consumer_channel_type
        if wm_consumer_id is not None:
            _header_params['WM_CONSUMER.ID'] = wm_consumer_id
        if wm_sec_timestamp is not None:
            _header_params['WM_SEC.TIMESTAMP'] = wm_sec_timestamp
        if wm_sec_auth_signature is not None:
            _header_params['WM_SEC.AUTH_SIGNATURE'] = wm_sec_auth_signature
        if wm_svc_name is not None:
            _header_params['WM_SVC.NAME'] = wm_svc_name
        if wm_qos_correlation_id is not None:
            _header_params['WM_QOS.CORRELATION_ID'] = wm_qos_correlation_id
        # process the form parameters
        # process the body parameter




        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/v3/orders/{purchaseOrderId}/acknowledge',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def cancel_order(
        self,
        purchase_order_id: Annotated[StrictStr, Field(description="Purchase Order ID")],
        content_type: Annotated[StrictStr, Field(description="application/xml, application/json")],
        accept: Annotated[StrictStr, Field(description="application/xml, application/json")],
        wm_consumer_channel_type: Annotated[StrictStr, Field(description="Channel Type")],
        wm_consumer_id: Annotated[StrictStr, Field(description="Your Consumer ID")],
        wm_sec_timestamp: Annotated[StrictStr, Field(description="Epoch timestamp")],
        wm_sec_auth_signature: Annotated[StrictStr, Field(description="Authentication signature")],
        wm_svc_name: Annotated[StrictStr, Field(description="The Service name")],
        wm_qos_correlation_id: Annotated[StrictStr, Field(description="A Transaction ID")],
        request_body: Annotated[StrictStr, Field(description="Request body")],
        ship_node: Annotated[Optional[StrictStr], Field(description="Ship Node")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """Cancel order lines

        You can cancel one or more order lines. You must include a purchaseOrderLineNumber when cancelling an order. After cancelling your order, update the inventory for the cancelled order and send it in the next inventory feed.

        :param purchase_order_id: Purchase Order ID (required)
        :type purchase_order_id: str
        :param content_type: application/xml, application/json (required)
        :type content_type: str
        :param accept: application/xml, application/json (required)
        :type accept: str
        :param wm_consumer_channel_type: Channel Type (required)
        :type wm_consumer_channel_type: str
        :param wm_consumer_id: Your Consumer ID (required)
        :type wm_consumer_id: str
        :param wm_sec_timestamp: Epoch timestamp (required)
        :type wm_sec_timestamp: str
        :param wm_sec_auth_signature: Authentication signature (required)
        :type wm_sec_auth_signature: str
        :param wm_svc_name: The Service name (required)
        :type wm_svc_name: str
        :param wm_qos_correlation_id: A Transaction ID (required)
        :type wm_qos_correlation_id: str
        :param request_body: Request body (required)
        :type request_body: str
        :param ship_node: Ship Node
        :type ship_node: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._cancel_order_serialize(
            purchase_order_id=purchase_order_id,
            content_type=content_type,
            accept=accept,
            wm_consumer_channel_type=wm_consumer_channel_type,
            wm_consumer_id=wm_consumer_id,
            wm_sec_timestamp=wm_sec_timestamp,
            wm_sec_auth_signature=wm_sec_auth_signature,
            wm_svc_name=wm_svc_name,
            wm_qos_correlation_id=wm_qos_correlation_id,
            request_body=request_body,
            ship_node=ship_node,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def cancel_order_with_http_info(
        self,
        purchase_order_id: Annotated[StrictStr, Field(description="Purchase Order ID")],
        content_type: Annotated[StrictStr, Field(description="application/xml, application/json")],
        accept: Annotated[StrictStr, Field(description="application/xml, application/json")],
        wm_consumer_channel_type: Annotated[StrictStr, Field(description="Channel Type")],
        wm_consumer_id: Annotated[StrictStr, Field(description="Your Consumer ID")],
        wm_sec_timestamp: Annotated[StrictStr, Field(description="Epoch timestamp")],
        wm_sec_auth_signature: Annotated[StrictStr, Field(description="Authentication signature")],
        wm_svc_name: Annotated[StrictStr, Field(description="The Service name")],
        wm_qos_correlation_id: Annotated[StrictStr, Field(description="A Transaction ID")],
        request_body: Annotated[StrictStr, Field(description="Request body")],
        ship_node: Annotated[Optional[StrictStr], Field(description="Ship Node")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """Cancel order lines

        You can cancel one or more order lines. You must include a purchaseOrderLineNumber when cancelling an order. After cancelling your order, update the inventory for the cancelled order and send it in the next inventory feed.

        :param purchase_order_id: Purchase Order ID (required)
        :type purchase_order_id: str
        :param content_type: application/xml, application/json (required)
        :type content_type: str
        :param accept: application/xml, application/json (required)
        :type accept: str
        :param wm_consumer_channel_type: Channel Type (required)
        :type wm_consumer_channel_type: str
        :param wm_consumer_id: Your Consumer ID (required)
        :type wm_consumer_id: str
        :param wm_sec_timestamp: Epoch timestamp (required)
        :type wm_sec_timestamp: str
        :param wm_sec_auth_signature: Authentication signature (required)
        :type wm_sec_auth_signature: str
        :param wm_svc_name: The Service name (required)
        :type wm_svc_name: str
        :param wm_qos_correlation_id: A Transaction ID (required)
        :type wm_qos_correlation_id: str
        :param request_body: Request body (required)
        :type request_body: str
        :param ship_node: Ship Node
        :type ship_node: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._cancel_order_serialize(
            purchase_order_id=purchase_order_id,
            content_type=content_type,
            accept=accept,
            wm_consumer_channel_type=wm_consumer_channel_type,
            wm_consumer_id=wm_consumer_id,
            wm_sec_timestamp=wm_sec_timestamp,
            wm_sec_auth_signature=wm_sec_auth_signature,
            wm_svc_name=wm_svc_name,
            wm_qos_correlation_id=wm_qos_correlation_id,
            request_body=request_body,
            ship_node=ship_node,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def cancel_order_without_preload_content(
        self,
        purchase_order_id: Annotated[StrictStr, Field(description="Purchase Order ID")],
        content_type: Annotated[StrictStr, Field(description="application/xml, application/json")],
        accept: Annotated[StrictStr, Field(description="application/xml, application/json")],
        wm_consumer_channel_type: Annotated[StrictStr, Field(description="Channel Type")],
        wm_consumer_id: Annotated[StrictStr, Field(description="Your Consumer ID")],
        wm_sec_timestamp: Annotated[StrictStr, Field(description="Epoch timestamp")],
        wm_sec_auth_signature: Annotated[StrictStr, Field(description="Authentication signature")],
        wm_svc_name: Annotated[StrictStr, Field(description="The Service name")],
        wm_qos_correlation_id: Annotated[StrictStr, Field(description="A Transaction ID")],
        request_body: Annotated[StrictStr, Field(description="Request body")],
        ship_node: Annotated[Optional[StrictStr], Field(description="Ship Node")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Cancel order lines

        You can cancel one or more order lines. You must include a purchaseOrderLineNumber when cancelling an order. After cancelling your order, update the inventory for the cancelled order and send it in the next inventory feed.

        :param purchase_order_id: Purchase Order ID (required)
        :type purchase_order_id: str
        :param content_type: application/xml, application/json (required)
        :type content_type: str
        :param accept: application/xml, application/json (required)
        :type accept: str
        :param wm_consumer_channel_type: Channel Type (required)
        :type wm_consumer_channel_type: str
        :param wm_consumer_id: Your Consumer ID (required)
        :type wm_consumer_id: str
        :param wm_sec_timestamp: Epoch timestamp (required)
        :type wm_sec_timestamp: str
        :param wm_sec_auth_signature: Authentication signature (required)
        :type wm_sec_auth_signature: str
        :param wm_svc_name: The Service name (required)
        :type wm_svc_name: str
        :param wm_qos_correlation_id: A Transaction ID (required)
        :type wm_qos_correlation_id: str
        :param request_body: Request body (required)
        :type request_body: str
        :param ship_node: Ship Node
        :type ship_node: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._cancel_order_serialize(
            purchase_order_id=purchase_order_id,
            content_type=content_type,
            accept=accept,
            wm_consumer_channel_type=wm_consumer_channel_type,
            wm_consumer_id=wm_consumer_id,
            wm_sec_timestamp=wm_sec_timestamp,
            wm_sec_auth_signature=wm_sec_auth_signature,
            wm_svc_name=wm_svc_name,
            wm_qos_correlation_id=wm_qos_correlation_id,
            request_body=request_body,
            ship_node=ship_node,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _cancel_order_serialize(
        self,
        purchase_order_id,
        content_type,
        accept,
        wm_consumer_channel_type,
        wm_consumer_id,
        wm_sec_timestamp,
        wm_sec_auth_signature,
        wm_svc_name,
        wm_qos_correlation_id,
        request_body,
        ship_node,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if purchase_order_id is not None:
            _path_params['purchaseOrderId'] = purchase_order_id
        # process the query parameters
        if ship_node is not None:
            
            _query_params.append(('shipNode', ship_node))
            
        # process the header parameters
        if content_type is not None:
            _header_params['Content-Type'] = content_type
        if accept is not None:
            _header_params['Accept'] = accept
        if wm_consumer_channel_type is not None:
            _header_params['WM_CONSUMER.CHANNEL.TYPE'] = wm_consumer_channel_type
        if wm_consumer_id is not None:
            _header_params['WM_CONSUMER.ID'] = wm_consumer_id
        if wm_sec_timestamp is not None:
            _header_params['WM_SEC.TIMESTAMP'] = wm_sec_timestamp
        if wm_sec_auth_signature is not None:
            _header_params['WM_SEC.AUTH_SIGNATURE'] = wm_sec_auth_signature
        if wm_svc_name is not None:
            _header_params['WM_SVC.NAME'] = wm_svc_name
        if wm_qos_correlation_id is not None:
            _header_params['WM_QOS.CORRELATION_ID'] = wm_qos_correlation_id
        # process the form parameters
        # process the body parameter
        if request_body is not None:
            _body_params = request_body



        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/xml', 
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/v3/orders/{purchaseOrderId}/cancel',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_all_orders(
        self,
        content_type: Annotated[StrictStr, Field(description="application/xml, application/json")],
        accept: Annotated[StrictStr, Field(description="application/xml, application/json")],
        wm_consumer_channel_type: Annotated[StrictStr, Field(description="Channel Type")],
        wm_consumer_id: Annotated[StrictStr, Field(description="Your Consumer ID")],
        wm_sec_timestamp: Annotated[StrictStr, Field(description="Epoch timestamp")],
        wm_sec_auth_signature: Annotated[StrictStr, Field(description="Authentication signature")],
        wm_svc_name: Annotated[StrictStr, Field(description="The Service name")],
        wm_qos_correlation_id: Annotated[StrictStr, Field(description="A Transaction ID")],
        ship_node: Annotated[Optional[StrictStr], Field(description="Ship Node")] = None,
        sku: Annotated[Optional[StrictStr], Field(description="Retrieves all orders with the specified SKU.")] = None,
        customer_order_id: Annotated[Optional[StrictStr], Field(description="Retrives the details of the specified customerOrderId.")] = None,
        purchase_order_id: Annotated[Optional[StrictStr], Field(description="The purchase order ID associated with the order to retrieve. One customer order can have multiple purchase orders associated with it.")] = None,
        status: Annotated[Optional[StrictStr], Field(description="The list of orders corresponding to the requested status.")] = None,
        created_start_date: Annotated[Optional[StrictStr], Field(description="Limit orders to those created after this date or a timestamp.")] = None,
        created_end_date: Annotated[Optional[StrictStr], Field(description="Limit orders to those created before this date or timestamp.")] = None,
        from_expected_ship_date: Annotated[Optional[StrictStr], Field(description="Limit orders to those that have order lines with an expected ship date after this date.")] = None,
        to_expected_ship_date: Annotated[Optional[StrictStr], Field(description="Limit orders to those that have order lines with an expected ship date before this date. ")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="The number of orders to be returned. Do not set this parameter to over 200 orders.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """Get all orders

        You can display a list of all orders with the query parameter filter criteria.

        :param content_type: application/xml, application/json (required)
        :type content_type: str
        :param accept: application/xml, application/json (required)
        :type accept: str
        :param wm_consumer_channel_type: Channel Type (required)
        :type wm_consumer_channel_type: str
        :param wm_consumer_id: Your Consumer ID (required)
        :type wm_consumer_id: str
        :param wm_sec_timestamp: Epoch timestamp (required)
        :type wm_sec_timestamp: str
        :param wm_sec_auth_signature: Authentication signature (required)
        :type wm_sec_auth_signature: str
        :param wm_svc_name: The Service name (required)
        :type wm_svc_name: str
        :param wm_qos_correlation_id: A Transaction ID (required)
        :type wm_qos_correlation_id: str
        :param ship_node: Ship Node
        :type ship_node: str
        :param sku: Retrieves all orders with the specified SKU.
        :type sku: str
        :param customer_order_id: Retrives the details of the specified customerOrderId.
        :type customer_order_id: str
        :param purchase_order_id: The purchase order ID associated with the order to retrieve. One customer order can have multiple purchase orders associated with it.
        :type purchase_order_id: str
        :param status: The list of orders corresponding to the requested status.
        :type status: str
        :param created_start_date: Limit orders to those created after this date or a timestamp.
        :type created_start_date: str
        :param created_end_date: Limit orders to those created before this date or timestamp.
        :type created_end_date: str
        :param from_expected_ship_date: Limit orders to those that have order lines with an expected ship date after this date.
        :type from_expected_ship_date: str
        :param to_expected_ship_date: Limit orders to those that have order lines with an expected ship date before this date. 
        :type to_expected_ship_date: str
        :param limit: The number of orders to be returned. Do not set this parameter to over 200 orders.
        :type limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_all_orders_serialize(
            content_type=content_type,
            accept=accept,
            wm_consumer_channel_type=wm_consumer_channel_type,
            wm_consumer_id=wm_consumer_id,
            wm_sec_timestamp=wm_sec_timestamp,
            wm_sec_auth_signature=wm_sec_auth_signature,
            wm_svc_name=wm_svc_name,
            wm_qos_correlation_id=wm_qos_correlation_id,
            ship_node=ship_node,
            sku=sku,
            customer_order_id=customer_order_id,
            purchase_order_id=purchase_order_id,
            status=status,
            created_start_date=created_start_date,
            created_end_date=created_end_date,
            from_expected_ship_date=from_expected_ship_date,
            to_expected_ship_date=to_expected_ship_date,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_all_orders_with_http_info(
        self,
        content_type: Annotated[StrictStr, Field(description="application/xml, application/json")],
        accept: Annotated[StrictStr, Field(description="application/xml, application/json")],
        wm_consumer_channel_type: Annotated[StrictStr, Field(description="Channel Type")],
        wm_consumer_id: Annotated[StrictStr, Field(description="Your Consumer ID")],
        wm_sec_timestamp: Annotated[StrictStr, Field(description="Epoch timestamp")],
        wm_sec_auth_signature: Annotated[StrictStr, Field(description="Authentication signature")],
        wm_svc_name: Annotated[StrictStr, Field(description="The Service name")],
        wm_qos_correlation_id: Annotated[StrictStr, Field(description="A Transaction ID")],
        ship_node: Annotated[Optional[StrictStr], Field(description="Ship Node")] = None,
        sku: Annotated[Optional[StrictStr], Field(description="Retrieves all orders with the specified SKU.")] = None,
        customer_order_id: Annotated[Optional[StrictStr], Field(description="Retrives the details of the specified customerOrderId.")] = None,
        purchase_order_id: Annotated[Optional[StrictStr], Field(description="The purchase order ID associated with the order to retrieve. One customer order can have multiple purchase orders associated with it.")] = None,
        status: Annotated[Optional[StrictStr], Field(description="The list of orders corresponding to the requested status.")] = None,
        created_start_date: Annotated[Optional[StrictStr], Field(description="Limit orders to those created after this date or a timestamp.")] = None,
        created_end_date: Annotated[Optional[StrictStr], Field(description="Limit orders to those created before this date or timestamp.")] = None,
        from_expected_ship_date: Annotated[Optional[StrictStr], Field(description="Limit orders to those that have order lines with an expected ship date after this date.")] = None,
        to_expected_ship_date: Annotated[Optional[StrictStr], Field(description="Limit orders to those that have order lines with an expected ship date before this date. ")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="The number of orders to be returned. Do not set this parameter to over 200 orders.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """Get all orders

        You can display a list of all orders with the query parameter filter criteria.

        :param content_type: application/xml, application/json (required)
        :type content_type: str
        :param accept: application/xml, application/json (required)
        :type accept: str
        :param wm_consumer_channel_type: Channel Type (required)
        :type wm_consumer_channel_type: str
        :param wm_consumer_id: Your Consumer ID (required)
        :type wm_consumer_id: str
        :param wm_sec_timestamp: Epoch timestamp (required)
        :type wm_sec_timestamp: str
        :param wm_sec_auth_signature: Authentication signature (required)
        :type wm_sec_auth_signature: str
        :param wm_svc_name: The Service name (required)
        :type wm_svc_name: str
        :param wm_qos_correlation_id: A Transaction ID (required)
        :type wm_qos_correlation_id: str
        :param ship_node: Ship Node
        :type ship_node: str
        :param sku: Retrieves all orders with the specified SKU.
        :type sku: str
        :param customer_order_id: Retrives the details of the specified customerOrderId.
        :type customer_order_id: str
        :param purchase_order_id: The purchase order ID associated with the order to retrieve. One customer order can have multiple purchase orders associated with it.
        :type purchase_order_id: str
        :param status: The list of orders corresponding to the requested status.
        :type status: str
        :param created_start_date: Limit orders to those created after this date or a timestamp.
        :type created_start_date: str
        :param created_end_date: Limit orders to those created before this date or timestamp.
        :type created_end_date: str
        :param from_expected_ship_date: Limit orders to those that have order lines with an expected ship date after this date.
        :type from_expected_ship_date: str
        :param to_expected_ship_date: Limit orders to those that have order lines with an expected ship date before this date. 
        :type to_expected_ship_date: str
        :param limit: The number of orders to be returned. Do not set this parameter to over 200 orders.
        :type limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_all_orders_serialize(
            content_type=content_type,
            accept=accept,
            wm_consumer_channel_type=wm_consumer_channel_type,
            wm_consumer_id=wm_consumer_id,
            wm_sec_timestamp=wm_sec_timestamp,
            wm_sec_auth_signature=wm_sec_auth_signature,
            wm_svc_name=wm_svc_name,
            wm_qos_correlation_id=wm_qos_correlation_id,
            ship_node=ship_node,
            sku=sku,
            customer_order_id=customer_order_id,
            purchase_order_id=purchase_order_id,
            status=status,
            created_start_date=created_start_date,
            created_end_date=created_end_date,
            from_expected_ship_date=from_expected_ship_date,
            to_expected_ship_date=to_expected_ship_date,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_all_orders_without_preload_content(
        self,
        content_type: Annotated[StrictStr, Field(description="application/xml, application/json")],
        accept: Annotated[StrictStr, Field(description="application/xml, application/json")],
        wm_consumer_channel_type: Annotated[StrictStr, Field(description="Channel Type")],
        wm_consumer_id: Annotated[StrictStr, Field(description="Your Consumer ID")],
        wm_sec_timestamp: Annotated[StrictStr, Field(description="Epoch timestamp")],
        wm_sec_auth_signature: Annotated[StrictStr, Field(description="Authentication signature")],
        wm_svc_name: Annotated[StrictStr, Field(description="The Service name")],
        wm_qos_correlation_id: Annotated[StrictStr, Field(description="A Transaction ID")],
        ship_node: Annotated[Optional[StrictStr], Field(description="Ship Node")] = None,
        sku: Annotated[Optional[StrictStr], Field(description="Retrieves all orders with the specified SKU.")] = None,
        customer_order_id: Annotated[Optional[StrictStr], Field(description="Retrives the details of the specified customerOrderId.")] = None,
        purchase_order_id: Annotated[Optional[StrictStr], Field(description="The purchase order ID associated with the order to retrieve. One customer order can have multiple purchase orders associated with it.")] = None,
        status: Annotated[Optional[StrictStr], Field(description="The list of orders corresponding to the requested status.")] = None,
        created_start_date: Annotated[Optional[StrictStr], Field(description="Limit orders to those created after this date or a timestamp.")] = None,
        created_end_date: Annotated[Optional[StrictStr], Field(description="Limit orders to those created before this date or timestamp.")] = None,
        from_expected_ship_date: Annotated[Optional[StrictStr], Field(description="Limit orders to those that have order lines with an expected ship date after this date.")] = None,
        to_expected_ship_date: Annotated[Optional[StrictStr], Field(description="Limit orders to those that have order lines with an expected ship date before this date. ")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="The number of orders to be returned. Do not set this parameter to over 200 orders.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get all orders

        You can display a list of all orders with the query parameter filter criteria.

        :param content_type: application/xml, application/json (required)
        :type content_type: str
        :param accept: application/xml, application/json (required)
        :type accept: str
        :param wm_consumer_channel_type: Channel Type (required)
        :type wm_consumer_channel_type: str
        :param wm_consumer_id: Your Consumer ID (required)
        :type wm_consumer_id: str
        :param wm_sec_timestamp: Epoch timestamp (required)
        :type wm_sec_timestamp: str
        :param wm_sec_auth_signature: Authentication signature (required)
        :type wm_sec_auth_signature: str
        :param wm_svc_name: The Service name (required)
        :type wm_svc_name: str
        :param wm_qos_correlation_id: A Transaction ID (required)
        :type wm_qos_correlation_id: str
        :param ship_node: Ship Node
        :type ship_node: str
        :param sku: Retrieves all orders with the specified SKU.
        :type sku: str
        :param customer_order_id: Retrives the details of the specified customerOrderId.
        :type customer_order_id: str
        :param purchase_order_id: The purchase order ID associated with the order to retrieve. One customer order can have multiple purchase orders associated with it.
        :type purchase_order_id: str
        :param status: The list of orders corresponding to the requested status.
        :type status: str
        :param created_start_date: Limit orders to those created after this date or a timestamp.
        :type created_start_date: str
        :param created_end_date: Limit orders to those created before this date or timestamp.
        :type created_end_date: str
        :param from_expected_ship_date: Limit orders to those that have order lines with an expected ship date after this date.
        :type from_expected_ship_date: str
        :param to_expected_ship_date: Limit orders to those that have order lines with an expected ship date before this date. 
        :type to_expected_ship_date: str
        :param limit: The number of orders to be returned. Do not set this parameter to over 200 orders.
        :type limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_all_orders_serialize(
            content_type=content_type,
            accept=accept,
            wm_consumer_channel_type=wm_consumer_channel_type,
            wm_consumer_id=wm_consumer_id,
            wm_sec_timestamp=wm_sec_timestamp,
            wm_sec_auth_signature=wm_sec_auth_signature,
            wm_svc_name=wm_svc_name,
            wm_qos_correlation_id=wm_qos_correlation_id,
            ship_node=ship_node,
            sku=sku,
            customer_order_id=customer_order_id,
            purchase_order_id=purchase_order_id,
            status=status,
            created_start_date=created_start_date,
            created_end_date=created_end_date,
            from_expected_ship_date=from_expected_ship_date,
            to_expected_ship_date=to_expected_ship_date,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_all_orders_serialize(
        self,
        content_type,
        accept,
        wm_consumer_channel_type,
        wm_consumer_id,
        wm_sec_timestamp,
        wm_sec_auth_signature,
        wm_svc_name,
        wm_qos_correlation_id,
        ship_node,
        sku,
        customer_order_id,
        purchase_order_id,
        status,
        created_start_date,
        created_end_date,
        from_expected_ship_date,
        to_expected_ship_date,
        limit,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if ship_node is not None:
            
            _query_params.append(('shipNode', ship_node))
            
        if sku is not None:
            
            _query_params.append(('sku', sku))
            
        if customer_order_id is not None:
            
            _query_params.append(('customerOrderId', customer_order_id))
            
        if purchase_order_id is not None:
            
            _query_params.append(('purchaseOrderId', purchase_order_id))
            
        if status is not None:
            
            _query_params.append(('status', status))
            
        if created_start_date is not None:
            
            _query_params.append(('createdStartDate', created_start_date))
            
        if created_end_date is not None:
            
            _query_params.append(('createdEndDate', created_end_date))
            
        if from_expected_ship_date is not None:
            
            _query_params.append(('fromExpectedShipDate', from_expected_ship_date))
            
        if to_expected_ship_date is not None:
            
            _query_params.append(('toExpectedShipDate', to_expected_ship_date))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        # process the header parameters
        if content_type is not None:
            _header_params['Content-Type'] = content_type
        if accept is not None:
            _header_params['Accept'] = accept
        if wm_consumer_channel_type is not None:
            _header_params['WM_CONSUMER.CHANNEL.TYPE'] = wm_consumer_channel_type
        if wm_consumer_id is not None:
            _header_params['WM_CONSUMER.ID'] = wm_consumer_id
        if wm_sec_timestamp is not None:
            _header_params['WM_SEC.TIMESTAMP'] = wm_sec_timestamp
        if wm_sec_auth_signature is not None:
            _header_params['WM_SEC.AUTH_SIGNATURE'] = wm_sec_auth_signature
        if wm_svc_name is not None:
            _header_params['WM_SVC.NAME'] = wm_svc_name
        if wm_qos_correlation_id is not None:
            _header_params['WM_QOS.CORRELATION_ID'] = wm_qos_correlation_id
        # process the form parameters
        # process the body parameter




        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/v3/orders',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_all_orders_next(
        self,
        next_cursor: Annotated[StrictStr, Field(description="Used for pagination when there are more than 200 orders to retrieve. The nextCursor value of the returned response includes a link to another GET call to retrieve the next page. Copy the link and paste it in the next call.")],
        content_type: Annotated[StrictStr, Field(description="application/xml, application/json")],
        accept: Annotated[StrictStr, Field(description="application/xml, application/json")],
        wm_consumer_channel_type: Annotated[StrictStr, Field(description="Channel Type")],
        wm_consumer_id: Annotated[StrictStr, Field(description="Your Consumer ID")],
        wm_sec_timestamp: Annotated[StrictStr, Field(description="Epoch timestamp")],
        wm_sec_auth_signature: Annotated[StrictStr, Field(description="Authentication signature")],
        wm_svc_name: Annotated[StrictStr, Field(description="The Service name")],
        wm_qos_correlation_id: Annotated[StrictStr, Field(description="A Transaction ID")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """Get orders for next page

        You can display a list of all orders with nextCursor path parameter pagination criteria.

        :param next_cursor: Used for pagination when there are more than 200 orders to retrieve. The nextCursor value of the returned response includes a link to another GET call to retrieve the next page. Copy the link and paste it in the next call. (required)
        :type next_cursor: str
        :param content_type: application/xml, application/json (required)
        :type content_type: str
        :param accept: application/xml, application/json (required)
        :type accept: str
        :param wm_consumer_channel_type: Channel Type (required)
        :type wm_consumer_channel_type: str
        :param wm_consumer_id: Your Consumer ID (required)
        :type wm_consumer_id: str
        :param wm_sec_timestamp: Epoch timestamp (required)
        :type wm_sec_timestamp: str
        :param wm_sec_auth_signature: Authentication signature (required)
        :type wm_sec_auth_signature: str
        :param wm_svc_name: The Service name (required)
        :type wm_svc_name: str
        :param wm_qos_correlation_id: A Transaction ID (required)
        :type wm_qos_correlation_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_all_orders_next_serialize(
            next_cursor=next_cursor,
            content_type=content_type,
            accept=accept,
            wm_consumer_channel_type=wm_consumer_channel_type,
            wm_consumer_id=wm_consumer_id,
            wm_sec_timestamp=wm_sec_timestamp,
            wm_sec_auth_signature=wm_sec_auth_signature,
            wm_svc_name=wm_svc_name,
            wm_qos_correlation_id=wm_qos_correlation_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_all_orders_next_with_http_info(
        self,
        next_cursor: Annotated[StrictStr, Field(description="Used for pagination when there are more than 200 orders to retrieve. The nextCursor value of the returned response includes a link to another GET call to retrieve the next page. Copy the link and paste it in the next call.")],
        content_type: Annotated[StrictStr, Field(description="application/xml, application/json")],
        accept: Annotated[StrictStr, Field(description="application/xml, application/json")],
        wm_consumer_channel_type: Annotated[StrictStr, Field(description="Channel Type")],
        wm_consumer_id: Annotated[StrictStr, Field(description="Your Consumer ID")],
        wm_sec_timestamp: Annotated[StrictStr, Field(description="Epoch timestamp")],
        wm_sec_auth_signature: Annotated[StrictStr, Field(description="Authentication signature")],
        wm_svc_name: Annotated[StrictStr, Field(description="The Service name")],
        wm_qos_correlation_id: Annotated[StrictStr, Field(description="A Transaction ID")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """Get orders for next page

        You can display a list of all orders with nextCursor path parameter pagination criteria.

        :param next_cursor: Used for pagination when there are more than 200 orders to retrieve. The nextCursor value of the returned response includes a link to another GET call to retrieve the next page. Copy the link and paste it in the next call. (required)
        :type next_cursor: str
        :param content_type: application/xml, application/json (required)
        :type content_type: str
        :param accept: application/xml, application/json (required)
        :type accept: str
        :param wm_consumer_channel_type: Channel Type (required)
        :type wm_consumer_channel_type: str
        :param wm_consumer_id: Your Consumer ID (required)
        :type wm_consumer_id: str
        :param wm_sec_timestamp: Epoch timestamp (required)
        :type wm_sec_timestamp: str
        :param wm_sec_auth_signature: Authentication signature (required)
        :type wm_sec_auth_signature: str
        :param wm_svc_name: The Service name (required)
        :type wm_svc_name: str
        :param wm_qos_correlation_id: A Transaction ID (required)
        :type wm_qos_correlation_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_all_orders_next_serialize(
            next_cursor=next_cursor,
            content_type=content_type,
            accept=accept,
            wm_consumer_channel_type=wm_consumer_channel_type,
            wm_consumer_id=wm_consumer_id,
            wm_sec_timestamp=wm_sec_timestamp,
            wm_sec_auth_signature=wm_sec_auth_signature,
            wm_svc_name=wm_svc_name,
            wm_qos_correlation_id=wm_qos_correlation_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_all_orders_next_without_preload_content(
        self,
        next_cursor: Annotated[StrictStr, Field(description="Used for pagination when there are more than 200 orders to retrieve. The nextCursor value of the returned response includes a link to another GET call to retrieve the next page. Copy the link and paste it in the next call.")],
        content_type: Annotated[StrictStr, Field(description="application/xml, application/json")],
        accept: Annotated[StrictStr, Field(description="application/xml, application/json")],
        wm_consumer_channel_type: Annotated[StrictStr, Field(description="Channel Type")],
        wm_consumer_id: Annotated[StrictStr, Field(description="Your Consumer ID")],
        wm_sec_timestamp: Annotated[StrictStr, Field(description="Epoch timestamp")],
        wm_sec_auth_signature: Annotated[StrictStr, Field(description="Authentication signature")],
        wm_svc_name: Annotated[StrictStr, Field(description="The Service name")],
        wm_qos_correlation_id: Annotated[StrictStr, Field(description="A Transaction ID")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get orders for next page

        You can display a list of all orders with nextCursor path parameter pagination criteria.

        :param next_cursor: Used for pagination when there are more than 200 orders to retrieve. The nextCursor value of the returned response includes a link to another GET call to retrieve the next page. Copy the link and paste it in the next call. (required)
        :type next_cursor: str
        :param content_type: application/xml, application/json (required)
        :type content_type: str
        :param accept: application/xml, application/json (required)
        :type accept: str
        :param wm_consumer_channel_type: Channel Type (required)
        :type wm_consumer_channel_type: str
        :param wm_consumer_id: Your Consumer ID (required)
        :type wm_consumer_id: str
        :param wm_sec_timestamp: Epoch timestamp (required)
        :type wm_sec_timestamp: str
        :param wm_sec_auth_signature: Authentication signature (required)
        :type wm_sec_auth_signature: str
        :param wm_svc_name: The Service name (required)
        :type wm_svc_name: str
        :param wm_qos_correlation_id: A Transaction ID (required)
        :type wm_qos_correlation_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_all_orders_next_serialize(
            next_cursor=next_cursor,
            content_type=content_type,
            accept=accept,
            wm_consumer_channel_type=wm_consumer_channel_type,
            wm_consumer_id=wm_consumer_id,
            wm_sec_timestamp=wm_sec_timestamp,
            wm_sec_auth_signature=wm_sec_auth_signature,
            wm_svc_name=wm_svc_name,
            wm_qos_correlation_id=wm_qos_correlation_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_all_orders_next_serialize(
        self,
        next_cursor,
        content_type,
        accept,
        wm_consumer_channel_type,
        wm_consumer_id,
        wm_sec_timestamp,
        wm_sec_auth_signature,
        wm_svc_name,
        wm_qos_correlation_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if next_cursor is not None:
            _path_params['nextCursor'] = next_cursor
        # process the query parameters
        # process the header parameters
        if content_type is not None:
            _header_params['Content-Type'] = content_type
        if accept is not None:
            _header_params['Accept'] = accept
        if wm_consumer_channel_type is not None:
            _header_params['WM_CONSUMER.CHANNEL.TYPE'] = wm_consumer_channel_type
        if wm_consumer_id is not None:
            _header_params['WM_CONSUMER.ID'] = wm_consumer_id
        if wm_sec_timestamp is not None:
            _header_params['WM_SEC.TIMESTAMP'] = wm_sec_timestamp
        if wm_sec_auth_signature is not None:
            _header_params['WM_SEC.AUTH_SIGNATURE'] = wm_sec_auth_signature
        if wm_svc_name is not None:
            _header_params['WM_SVC.NAME'] = wm_svc_name
        if wm_qos_correlation_id is not None:
            _header_params['WM_QOS.CORRELATION_ID'] = wm_qos_correlation_id
        # process the form parameters
        # process the body parameter




        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/v3/orders{nextCursor}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_next_cursor_released_orders(
        self,
        next_cursor: Annotated[StrictStr, Field(description="Used for pagination when there are more than 200 orders to retrieve. The nextCursor value of the returned response includes a link to another GET call to retrieve the next page. Copy the link and paste it in the next call.")],
        content_type: Annotated[StrictStr, Field(description="application/xml, application/json")],
        accept: Annotated[StrictStr, Field(description="application/xml, application/json")],
        wm_consumer_channel_type: Annotated[StrictStr, Field(description="Channel Type")],
        wm_consumer_id: Annotated[StrictStr, Field(description="Your Consumer ID")],
        wm_sec_timestamp: Annotated[StrictStr, Field(description="Epoch timestamp")],
        wm_sec_auth_signature: Annotated[StrictStr, Field(description="Authentication signature")],
        wm_svc_name: Annotated[StrictStr, Field(description="The Service name")],
        wm_qos_correlation_id: Annotated[StrictStr, Field(description="A Transaction ID")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """Get released orders for next page

        You can display all released orders that have been created and are ready for fulfilment with nextCursor path parameter.

        :param next_cursor: Used for pagination when there are more than 200 orders to retrieve. The nextCursor value of the returned response includes a link to another GET call to retrieve the next page. Copy the link and paste it in the next call. (required)
        :type next_cursor: str
        :param content_type: application/xml, application/json (required)
        :type content_type: str
        :param accept: application/xml, application/json (required)
        :type accept: str
        :param wm_consumer_channel_type: Channel Type (required)
        :type wm_consumer_channel_type: str
        :param wm_consumer_id: Your Consumer ID (required)
        :type wm_consumer_id: str
        :param wm_sec_timestamp: Epoch timestamp (required)
        :type wm_sec_timestamp: str
        :param wm_sec_auth_signature: Authentication signature (required)
        :type wm_sec_auth_signature: str
        :param wm_svc_name: The Service name (required)
        :type wm_svc_name: str
        :param wm_qos_correlation_id: A Transaction ID (required)
        :type wm_qos_correlation_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_next_cursor_released_orders_serialize(
            next_cursor=next_cursor,
            content_type=content_type,
            accept=accept,
            wm_consumer_channel_type=wm_consumer_channel_type,
            wm_consumer_id=wm_consumer_id,
            wm_sec_timestamp=wm_sec_timestamp,
            wm_sec_auth_signature=wm_sec_auth_signature,
            wm_svc_name=wm_svc_name,
            wm_qos_correlation_id=wm_qos_correlation_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_next_cursor_released_orders_with_http_info(
        self,
        next_cursor: Annotated[StrictStr, Field(description="Used for pagination when there are more than 200 orders to retrieve. The nextCursor value of the returned response includes a link to another GET call to retrieve the next page. Copy the link and paste it in the next call.")],
        content_type: Annotated[StrictStr, Field(description="application/xml, application/json")],
        accept: Annotated[StrictStr, Field(description="application/xml, application/json")],
        wm_consumer_channel_type: Annotated[StrictStr, Field(description="Channel Type")],
        wm_consumer_id: Annotated[StrictStr, Field(description="Your Consumer ID")],
        wm_sec_timestamp: Annotated[StrictStr, Field(description="Epoch timestamp")],
        wm_sec_auth_signature: Annotated[StrictStr, Field(description="Authentication signature")],
        wm_svc_name: Annotated[StrictStr, Field(description="The Service name")],
        wm_qos_correlation_id: Annotated[StrictStr, Field(description="A Transaction ID")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """Get released orders for next page

        You can display all released orders that have been created and are ready for fulfilment with nextCursor path parameter.

        :param next_cursor: Used for pagination when there are more than 200 orders to retrieve. The nextCursor value of the returned response includes a link to another GET call to retrieve the next page. Copy the link and paste it in the next call. (required)
        :type next_cursor: str
        :param content_type: application/xml, application/json (required)
        :type content_type: str
        :param accept: application/xml, application/json (required)
        :type accept: str
        :param wm_consumer_channel_type: Channel Type (required)
        :type wm_consumer_channel_type: str
        :param wm_consumer_id: Your Consumer ID (required)
        :type wm_consumer_id: str
        :param wm_sec_timestamp: Epoch timestamp (required)
        :type wm_sec_timestamp: str
        :param wm_sec_auth_signature: Authentication signature (required)
        :type wm_sec_auth_signature: str
        :param wm_svc_name: The Service name (required)
        :type wm_svc_name: str
        :param wm_qos_correlation_id: A Transaction ID (required)
        :type wm_qos_correlation_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_next_cursor_released_orders_serialize(
            next_cursor=next_cursor,
            content_type=content_type,
            accept=accept,
            wm_consumer_channel_type=wm_consumer_channel_type,
            wm_consumer_id=wm_consumer_id,
            wm_sec_timestamp=wm_sec_timestamp,
            wm_sec_auth_signature=wm_sec_auth_signature,
            wm_svc_name=wm_svc_name,
            wm_qos_correlation_id=wm_qos_correlation_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_next_cursor_released_orders_without_preload_content(
        self,
        next_cursor: Annotated[StrictStr, Field(description="Used for pagination when there are more than 200 orders to retrieve. The nextCursor value of the returned response includes a link to another GET call to retrieve the next page. Copy the link and paste it in the next call.")],
        content_type: Annotated[StrictStr, Field(description="application/xml, application/json")],
        accept: Annotated[StrictStr, Field(description="application/xml, application/json")],
        wm_consumer_channel_type: Annotated[StrictStr, Field(description="Channel Type")],
        wm_consumer_id: Annotated[StrictStr, Field(description="Your Consumer ID")],
        wm_sec_timestamp: Annotated[StrictStr, Field(description="Epoch timestamp")],
        wm_sec_auth_signature: Annotated[StrictStr, Field(description="Authentication signature")],
        wm_svc_name: Annotated[StrictStr, Field(description="The Service name")],
        wm_qos_correlation_id: Annotated[StrictStr, Field(description="A Transaction ID")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get released orders for next page

        You can display all released orders that have been created and are ready for fulfilment with nextCursor path parameter.

        :param next_cursor: Used for pagination when there are more than 200 orders to retrieve. The nextCursor value of the returned response includes a link to another GET call to retrieve the next page. Copy the link and paste it in the next call. (required)
        :type next_cursor: str
        :param content_type: application/xml, application/json (required)
        :type content_type: str
        :param accept: application/xml, application/json (required)
        :type accept: str
        :param wm_consumer_channel_type: Channel Type (required)
        :type wm_consumer_channel_type: str
        :param wm_consumer_id: Your Consumer ID (required)
        :type wm_consumer_id: str
        :param wm_sec_timestamp: Epoch timestamp (required)
        :type wm_sec_timestamp: str
        :param wm_sec_auth_signature: Authentication signature (required)
        :type wm_sec_auth_signature: str
        :param wm_svc_name: The Service name (required)
        :type wm_svc_name: str
        :param wm_qos_correlation_id: A Transaction ID (required)
        :type wm_qos_correlation_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_next_cursor_released_orders_serialize(
            next_cursor=next_cursor,
            content_type=content_type,
            accept=accept,
            wm_consumer_channel_type=wm_consumer_channel_type,
            wm_consumer_id=wm_consumer_id,
            wm_sec_timestamp=wm_sec_timestamp,
            wm_sec_auth_signature=wm_sec_auth_signature,
            wm_svc_name=wm_svc_name,
            wm_qos_correlation_id=wm_qos_correlation_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_next_cursor_released_orders_serialize(
        self,
        next_cursor,
        content_type,
        accept,
        wm_consumer_channel_type,
        wm_consumer_id,
        wm_sec_timestamp,
        wm_sec_auth_signature,
        wm_svc_name,
        wm_qos_correlation_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if next_cursor is not None:
            _path_params['nextCursor'] = next_cursor
        # process the query parameters
        # process the header parameters
        if content_type is not None:
            _header_params['Content-Type'] = content_type
        if accept is not None:
            _header_params['Accept'] = accept
        if wm_consumer_channel_type is not None:
            _header_params['WM_CONSUMER.CHANNEL.TYPE'] = wm_consumer_channel_type
        if wm_consumer_id is not None:
            _header_params['WM_CONSUMER.ID'] = wm_consumer_id
        if wm_sec_timestamp is not None:
            _header_params['WM_SEC.TIMESTAMP'] = wm_sec_timestamp
        if wm_sec_auth_signature is not None:
            _header_params['WM_SEC.AUTH_SIGNATURE'] = wm_sec_auth_signature
        if wm_svc_name is not None:
            _header_params['WM_SVC.NAME'] = wm_svc_name
        if wm_qos_correlation_id is not None:
            _header_params['WM_QOS.CORRELATION_ID'] = wm_qos_correlation_id
        # process the form parameters
        # process the body parameter




        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/v3/orders/released{nextCursor}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_order_by_purchase_order_id(
        self,
        purchase_order_id: Annotated[StrictStr, Field(description="Purchase Order ID")],
        content_type: Annotated[StrictStr, Field(description="application/xml, application/json")],
        accept: Annotated[StrictStr, Field(description="application/xml, application/json")],
        wm_consumer_channel_type: Annotated[StrictStr, Field(description="Channel Type")],
        wm_consumer_id: Annotated[StrictStr, Field(description="Your Consumer ID")],
        wm_sec_timestamp: Annotated[StrictStr, Field(description="Epoch timestamp")],
        wm_sec_auth_signature: Annotated[StrictStr, Field(description="Authentication signature")],
        wm_svc_name: Annotated[StrictStr, Field(description="The Service name")],
        wm_qos_correlation_id: Annotated[StrictStr, Field(description="A Transaction ID")],
        ship_node: Annotated[Optional[StrictStr], Field(description="Ship Node")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """Get an order

        You can display details of a specific order based on the purchaseOrderId.

        :param purchase_order_id: Purchase Order ID (required)
        :type purchase_order_id: str
        :param content_type: application/xml, application/json (required)
        :type content_type: str
        :param accept: application/xml, application/json (required)
        :type accept: str
        :param wm_consumer_channel_type: Channel Type (required)
        :type wm_consumer_channel_type: str
        :param wm_consumer_id: Your Consumer ID (required)
        :type wm_consumer_id: str
        :param wm_sec_timestamp: Epoch timestamp (required)
        :type wm_sec_timestamp: str
        :param wm_sec_auth_signature: Authentication signature (required)
        :type wm_sec_auth_signature: str
        :param wm_svc_name: The Service name (required)
        :type wm_svc_name: str
        :param wm_qos_correlation_id: A Transaction ID (required)
        :type wm_qos_correlation_id: str
        :param ship_node: Ship Node
        :type ship_node: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_order_by_purchase_order_id_serialize(
            purchase_order_id=purchase_order_id,
            content_type=content_type,
            accept=accept,
            wm_consumer_channel_type=wm_consumer_channel_type,
            wm_consumer_id=wm_consumer_id,
            wm_sec_timestamp=wm_sec_timestamp,
            wm_sec_auth_signature=wm_sec_auth_signature,
            wm_svc_name=wm_svc_name,
            wm_qos_correlation_id=wm_qos_correlation_id,
            ship_node=ship_node,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_order_by_purchase_order_id_with_http_info(
        self,
        purchase_order_id: Annotated[StrictStr, Field(description="Purchase Order ID")],
        content_type: Annotated[StrictStr, Field(description="application/xml, application/json")],
        accept: Annotated[StrictStr, Field(description="application/xml, application/json")],
        wm_consumer_channel_type: Annotated[StrictStr, Field(description="Channel Type")],
        wm_consumer_id: Annotated[StrictStr, Field(description="Your Consumer ID")],
        wm_sec_timestamp: Annotated[StrictStr, Field(description="Epoch timestamp")],
        wm_sec_auth_signature: Annotated[StrictStr, Field(description="Authentication signature")],
        wm_svc_name: Annotated[StrictStr, Field(description="The Service name")],
        wm_qos_correlation_id: Annotated[StrictStr, Field(description="A Transaction ID")],
        ship_node: Annotated[Optional[StrictStr], Field(description="Ship Node")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """Get an order

        You can display details of a specific order based on the purchaseOrderId.

        :param purchase_order_id: Purchase Order ID (required)
        :type purchase_order_id: str
        :param content_type: application/xml, application/json (required)
        :type content_type: str
        :param accept: application/xml, application/json (required)
        :type accept: str
        :param wm_consumer_channel_type: Channel Type (required)
        :type wm_consumer_channel_type: str
        :param wm_consumer_id: Your Consumer ID (required)
        :type wm_consumer_id: str
        :param wm_sec_timestamp: Epoch timestamp (required)
        :type wm_sec_timestamp: str
        :param wm_sec_auth_signature: Authentication signature (required)
        :type wm_sec_auth_signature: str
        :param wm_svc_name: The Service name (required)
        :type wm_svc_name: str
        :param wm_qos_correlation_id: A Transaction ID (required)
        :type wm_qos_correlation_id: str
        :param ship_node: Ship Node
        :type ship_node: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_order_by_purchase_order_id_serialize(
            purchase_order_id=purchase_order_id,
            content_type=content_type,
            accept=accept,
            wm_consumer_channel_type=wm_consumer_channel_type,
            wm_consumer_id=wm_consumer_id,
            wm_sec_timestamp=wm_sec_timestamp,
            wm_sec_auth_signature=wm_sec_auth_signature,
            wm_svc_name=wm_svc_name,
            wm_qos_correlation_id=wm_qos_correlation_id,
            ship_node=ship_node,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_order_by_purchase_order_id_without_preload_content(
        self,
        purchase_order_id: Annotated[StrictStr, Field(description="Purchase Order ID")],
        content_type: Annotated[StrictStr, Field(description="application/xml, application/json")],
        accept: Annotated[StrictStr, Field(description="application/xml, application/json")],
        wm_consumer_channel_type: Annotated[StrictStr, Field(description="Channel Type")],
        wm_consumer_id: Annotated[StrictStr, Field(description="Your Consumer ID")],
        wm_sec_timestamp: Annotated[StrictStr, Field(description="Epoch timestamp")],
        wm_sec_auth_signature: Annotated[StrictStr, Field(description="Authentication signature")],
        wm_svc_name: Annotated[StrictStr, Field(description="The Service name")],
        wm_qos_correlation_id: Annotated[StrictStr, Field(description="A Transaction ID")],
        ship_node: Annotated[Optional[StrictStr], Field(description="Ship Node")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get an order

        You can display details of a specific order based on the purchaseOrderId.

        :param purchase_order_id: Purchase Order ID (required)
        :type purchase_order_id: str
        :param content_type: application/xml, application/json (required)
        :type content_type: str
        :param accept: application/xml, application/json (required)
        :type accept: str
        :param wm_consumer_channel_type: Channel Type (required)
        :type wm_consumer_channel_type: str
        :param wm_consumer_id: Your Consumer ID (required)
        :type wm_consumer_id: str
        :param wm_sec_timestamp: Epoch timestamp (required)
        :type wm_sec_timestamp: str
        :param wm_sec_auth_signature: Authentication signature (required)
        :type wm_sec_auth_signature: str
        :param wm_svc_name: The Service name (required)
        :type wm_svc_name: str
        :param wm_qos_correlation_id: A Transaction ID (required)
        :type wm_qos_correlation_id: str
        :param ship_node: Ship Node
        :type ship_node: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_order_by_purchase_order_id_serialize(
            purchase_order_id=purchase_order_id,
            content_type=content_type,
            accept=accept,
            wm_consumer_channel_type=wm_consumer_channel_type,
            wm_consumer_id=wm_consumer_id,
            wm_sec_timestamp=wm_sec_timestamp,
            wm_sec_auth_signature=wm_sec_auth_signature,
            wm_svc_name=wm_svc_name,
            wm_qos_correlation_id=wm_qos_correlation_id,
            ship_node=ship_node,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_order_by_purchase_order_id_serialize(
        self,
        purchase_order_id,
        content_type,
        accept,
        wm_consumer_channel_type,
        wm_consumer_id,
        wm_sec_timestamp,
        wm_sec_auth_signature,
        wm_svc_name,
        wm_qos_correlation_id,
        ship_node,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if purchase_order_id is not None:
            _path_params['purchaseOrderId'] = purchase_order_id
        # process the query parameters
        if ship_node is not None:
            
            _query_params.append(('shipNode', ship_node))
            
        # process the header parameters
        if content_type is not None:
            _header_params['Content-Type'] = content_type
        if accept is not None:
            _header_params['Accept'] = accept
        if wm_consumer_channel_type is not None:
            _header_params['WM_CONSUMER.CHANNEL.TYPE'] = wm_consumer_channel_type
        if wm_consumer_id is not None:
            _header_params['WM_CONSUMER.ID'] = wm_consumer_id
        if wm_sec_timestamp is not None:
            _header_params['WM_SEC.TIMESTAMP'] = wm_sec_timestamp
        if wm_sec_auth_signature is not None:
            _header_params['WM_SEC.AUTH_SIGNATURE'] = wm_sec_auth_signature
        if wm_svc_name is not None:
            _header_params['WM_SVC.NAME'] = wm_svc_name
        if wm_qos_correlation_id is not None:
            _header_params['WM_QOS.CORRELATION_ID'] = wm_qos_correlation_id
        # process the form parameters
        # process the body parameter




        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/v3/orders/{purchaseOrderId}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_released_orders(
        self,
        created_start_date: Annotated[StrictStr, Field(description="Limit orders to those created after this date or a timestamp.")],
        content_type: Annotated[StrictStr, Field(description="application/xml, application/json")],
        accept: Annotated[StrictStr, Field(description="application/xml, application/json")],
        wm_consumer_channel_type: Annotated[StrictStr, Field(description="Channel Type")],
        wm_consumer_id: Annotated[StrictStr, Field(description="Your Consumer ID")],
        wm_sec_timestamp: Annotated[StrictStr, Field(description="Epoch timestamp")],
        wm_sec_auth_signature: Annotated[StrictStr, Field(description="Authentication signature")],
        wm_svc_name: Annotated[StrictStr, Field(description="The Service name")],
        wm_qos_correlation_id: Annotated[StrictStr, Field(description="A Transaction ID")],
        ship_node: Annotated[Optional[StrictStr], Field(description="Ship Node")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="The number of orders to be returned. Do not set this parameter to over 200 orders.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """Get all released orders

        You can display all released orders that have been created and are ready for fulfilment.

        :param created_start_date: Limit orders to those created after this date or a timestamp. (required)
        :type created_start_date: str
        :param content_type: application/xml, application/json (required)
        :type content_type: str
        :param accept: application/xml, application/json (required)
        :type accept: str
        :param wm_consumer_channel_type: Channel Type (required)
        :type wm_consumer_channel_type: str
        :param wm_consumer_id: Your Consumer ID (required)
        :type wm_consumer_id: str
        :param wm_sec_timestamp: Epoch timestamp (required)
        :type wm_sec_timestamp: str
        :param wm_sec_auth_signature: Authentication signature (required)
        :type wm_sec_auth_signature: str
        :param wm_svc_name: The Service name (required)
        :type wm_svc_name: str
        :param wm_qos_correlation_id: A Transaction ID (required)
        :type wm_qos_correlation_id: str
        :param ship_node: Ship Node
        :type ship_node: str
        :param limit: The number of orders to be returned. Do not set this parameter to over 200 orders.
        :type limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_released_orders_serialize(
            created_start_date=created_start_date,
            content_type=content_type,
            accept=accept,
            wm_consumer_channel_type=wm_consumer_channel_type,
            wm_consumer_id=wm_consumer_id,
            wm_sec_timestamp=wm_sec_timestamp,
            wm_sec_auth_signature=wm_sec_auth_signature,
            wm_svc_name=wm_svc_name,
            wm_qos_correlation_id=wm_qos_correlation_id,
            ship_node=ship_node,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_released_orders_with_http_info(
        self,
        created_start_date: Annotated[StrictStr, Field(description="Limit orders to those created after this date or a timestamp.")],
        content_type: Annotated[StrictStr, Field(description="application/xml, application/json")],
        accept: Annotated[StrictStr, Field(description="application/xml, application/json")],
        wm_consumer_channel_type: Annotated[StrictStr, Field(description="Channel Type")],
        wm_consumer_id: Annotated[StrictStr, Field(description="Your Consumer ID")],
        wm_sec_timestamp: Annotated[StrictStr, Field(description="Epoch timestamp")],
        wm_sec_auth_signature: Annotated[StrictStr, Field(description="Authentication signature")],
        wm_svc_name: Annotated[StrictStr, Field(description="The Service name")],
        wm_qos_correlation_id: Annotated[StrictStr, Field(description="A Transaction ID")],
        ship_node: Annotated[Optional[StrictStr], Field(description="Ship Node")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="The number of orders to be returned. Do not set this parameter to over 200 orders.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """Get all released orders

        You can display all released orders that have been created and are ready for fulfilment.

        :param created_start_date: Limit orders to those created after this date or a timestamp. (required)
        :type created_start_date: str
        :param content_type: application/xml, application/json (required)
        :type content_type: str
        :param accept: application/xml, application/json (required)
        :type accept: str
        :param wm_consumer_channel_type: Channel Type (required)
        :type wm_consumer_channel_type: str
        :param wm_consumer_id: Your Consumer ID (required)
        :type wm_consumer_id: str
        :param wm_sec_timestamp: Epoch timestamp (required)
        :type wm_sec_timestamp: str
        :param wm_sec_auth_signature: Authentication signature (required)
        :type wm_sec_auth_signature: str
        :param wm_svc_name: The Service name (required)
        :type wm_svc_name: str
        :param wm_qos_correlation_id: A Transaction ID (required)
        :type wm_qos_correlation_id: str
        :param ship_node: Ship Node
        :type ship_node: str
        :param limit: The number of orders to be returned. Do not set this parameter to over 200 orders.
        :type limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_released_orders_serialize(
            created_start_date=created_start_date,
            content_type=content_type,
            accept=accept,
            wm_consumer_channel_type=wm_consumer_channel_type,
            wm_consumer_id=wm_consumer_id,
            wm_sec_timestamp=wm_sec_timestamp,
            wm_sec_auth_signature=wm_sec_auth_signature,
            wm_svc_name=wm_svc_name,
            wm_qos_correlation_id=wm_qos_correlation_id,
            ship_node=ship_node,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_released_orders_without_preload_content(
        self,
        created_start_date: Annotated[StrictStr, Field(description="Limit orders to those created after this date or a timestamp.")],
        content_type: Annotated[StrictStr, Field(description="application/xml, application/json")],
        accept: Annotated[StrictStr, Field(description="application/xml, application/json")],
        wm_consumer_channel_type: Annotated[StrictStr, Field(description="Channel Type")],
        wm_consumer_id: Annotated[StrictStr, Field(description="Your Consumer ID")],
        wm_sec_timestamp: Annotated[StrictStr, Field(description="Epoch timestamp")],
        wm_sec_auth_signature: Annotated[StrictStr, Field(description="Authentication signature")],
        wm_svc_name: Annotated[StrictStr, Field(description="The Service name")],
        wm_qos_correlation_id: Annotated[StrictStr, Field(description="A Transaction ID")],
        ship_node: Annotated[Optional[StrictStr], Field(description="Ship Node")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="The number of orders to be returned. Do not set this parameter to over 200 orders.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get all released orders

        You can display all released orders that have been created and are ready for fulfilment.

        :param created_start_date: Limit orders to those created after this date or a timestamp. (required)
        :type created_start_date: str
        :param content_type: application/xml, application/json (required)
        :type content_type: str
        :param accept: application/xml, application/json (required)
        :type accept: str
        :param wm_consumer_channel_type: Channel Type (required)
        :type wm_consumer_channel_type: str
        :param wm_consumer_id: Your Consumer ID (required)
        :type wm_consumer_id: str
        :param wm_sec_timestamp: Epoch timestamp (required)
        :type wm_sec_timestamp: str
        :param wm_sec_auth_signature: Authentication signature (required)
        :type wm_sec_auth_signature: str
        :param wm_svc_name: The Service name (required)
        :type wm_svc_name: str
        :param wm_qos_correlation_id: A Transaction ID (required)
        :type wm_qos_correlation_id: str
        :param ship_node: Ship Node
        :type ship_node: str
        :param limit: The number of orders to be returned. Do not set this parameter to over 200 orders.
        :type limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_released_orders_serialize(
            created_start_date=created_start_date,
            content_type=content_type,
            accept=accept,
            wm_consumer_channel_type=wm_consumer_channel_type,
            wm_consumer_id=wm_consumer_id,
            wm_sec_timestamp=wm_sec_timestamp,
            wm_sec_auth_signature=wm_sec_auth_signature,
            wm_svc_name=wm_svc_name,
            wm_qos_correlation_id=wm_qos_correlation_id,
            ship_node=ship_node,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_released_orders_serialize(
        self,
        created_start_date,
        content_type,
        accept,
        wm_consumer_channel_type,
        wm_consumer_id,
        wm_sec_timestamp,
        wm_sec_auth_signature,
        wm_svc_name,
        wm_qos_correlation_id,
        ship_node,
        limit,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if ship_node is not None:
            
            _query_params.append(('shipNode', ship_node))
            
        if created_start_date is not None:
            
            _query_params.append(('createdStartDate', created_start_date))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        # process the header parameters
        if content_type is not None:
            _header_params['Content-Type'] = content_type
        if accept is not None:
            _header_params['Accept'] = accept
        if wm_consumer_channel_type is not None:
            _header_params['WM_CONSUMER.CHANNEL.TYPE'] = wm_consumer_channel_type
        if wm_consumer_id is not None:
            _header_params['WM_CONSUMER.ID'] = wm_consumer_id
        if wm_sec_timestamp is not None:
            _header_params['WM_SEC.TIMESTAMP'] = wm_sec_timestamp
        if wm_sec_auth_signature is not None:
            _header_params['WM_SEC.AUTH_SIGNATURE'] = wm_sec_auth_signature
        if wm_svc_name is not None:
            _header_params['WM_SVC.NAME'] = wm_svc_name
        if wm_qos_correlation_id is not None:
            _header_params['WM_QOS.CORRELATION_ID'] = wm_qos_correlation_id
        # process the form parameters
        # process the body parameter




        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/v3/orders/released',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def refund_order(
        self,
        purchase_order_id: Annotated[StrictStr, Field(description="Purchase Order ID")],
        content_type: Annotated[StrictStr, Field(description="application/xml, application/json")],
        accept: Annotated[StrictStr, Field(description="application/xml, application/json")],
        wm_consumer_channel_type: Annotated[StrictStr, Field(description="Channel Type")],
        wm_consumer_id: Annotated[StrictStr, Field(description="Your Consumer ID")],
        wm_sec_timestamp: Annotated[StrictStr, Field(description="Epoch timestamp")],
        wm_sec_auth_signature: Annotated[StrictStr, Field(description="Authentication signature")],
        wm_svc_name: Annotated[StrictStr, Field(description="The Service name")],
        wm_qos_correlation_id: Annotated[StrictStr, Field(description="A Transaction ID")],
        request_body: Annotated[StrictStr, Field(description="Request body")],
        ship_node: Annotated[Optional[StrictStr], Field(description="Ship Node")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """Refund order lines

        You can refund one or more order lines that have been shipped. The response to a successful call contains the order with the refunded line item.

        :param purchase_order_id: Purchase Order ID (required)
        :type purchase_order_id: str
        :param content_type: application/xml, application/json (required)
        :type content_type: str
        :param accept: application/xml, application/json (required)
        :type accept: str
        :param wm_consumer_channel_type: Channel Type (required)
        :type wm_consumer_channel_type: str
        :param wm_consumer_id: Your Consumer ID (required)
        :type wm_consumer_id: str
        :param wm_sec_timestamp: Epoch timestamp (required)
        :type wm_sec_timestamp: str
        :param wm_sec_auth_signature: Authentication signature (required)
        :type wm_sec_auth_signature: str
        :param wm_svc_name: The Service name (required)
        :type wm_svc_name: str
        :param wm_qos_correlation_id: A Transaction ID (required)
        :type wm_qos_correlation_id: str
        :param request_body: Request body (required)
        :type request_body: str
        :param ship_node: Ship Node
        :type ship_node: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._refund_order_serialize(
            purchase_order_id=purchase_order_id,
            content_type=content_type,
            accept=accept,
            wm_consumer_channel_type=wm_consumer_channel_type,
            wm_consumer_id=wm_consumer_id,
            wm_sec_timestamp=wm_sec_timestamp,
            wm_sec_auth_signature=wm_sec_auth_signature,
            wm_svc_name=wm_svc_name,
            wm_qos_correlation_id=wm_qos_correlation_id,
            request_body=request_body,
            ship_node=ship_node,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def refund_order_with_http_info(
        self,
        purchase_order_id: Annotated[StrictStr, Field(description="Purchase Order ID")],
        content_type: Annotated[StrictStr, Field(description="application/xml, application/json")],
        accept: Annotated[StrictStr, Field(description="application/xml, application/json")],
        wm_consumer_channel_type: Annotated[StrictStr, Field(description="Channel Type")],
        wm_consumer_id: Annotated[StrictStr, Field(description="Your Consumer ID")],
        wm_sec_timestamp: Annotated[StrictStr, Field(description="Epoch timestamp")],
        wm_sec_auth_signature: Annotated[StrictStr, Field(description="Authentication signature")],
        wm_svc_name: Annotated[StrictStr, Field(description="The Service name")],
        wm_qos_correlation_id: Annotated[StrictStr, Field(description="A Transaction ID")],
        request_body: Annotated[StrictStr, Field(description="Request body")],
        ship_node: Annotated[Optional[StrictStr], Field(description="Ship Node")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """Refund order lines

        You can refund one or more order lines that have been shipped. The response to a successful call contains the order with the refunded line item.

        :param purchase_order_id: Purchase Order ID (required)
        :type purchase_order_id: str
        :param content_type: application/xml, application/json (required)
        :type content_type: str
        :param accept: application/xml, application/json (required)
        :type accept: str
        :param wm_consumer_channel_type: Channel Type (required)
        :type wm_consumer_channel_type: str
        :param wm_consumer_id: Your Consumer ID (required)
        :type wm_consumer_id: str
        :param wm_sec_timestamp: Epoch timestamp (required)
        :type wm_sec_timestamp: str
        :param wm_sec_auth_signature: Authentication signature (required)
        :type wm_sec_auth_signature: str
        :param wm_svc_name: The Service name (required)
        :type wm_svc_name: str
        :param wm_qos_correlation_id: A Transaction ID (required)
        :type wm_qos_correlation_id: str
        :param request_body: Request body (required)
        :type request_body: str
        :param ship_node: Ship Node
        :type ship_node: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._refund_order_serialize(
            purchase_order_id=purchase_order_id,
            content_type=content_type,
            accept=accept,
            wm_consumer_channel_type=wm_consumer_channel_type,
            wm_consumer_id=wm_consumer_id,
            wm_sec_timestamp=wm_sec_timestamp,
            wm_sec_auth_signature=wm_sec_auth_signature,
            wm_svc_name=wm_svc_name,
            wm_qos_correlation_id=wm_qos_correlation_id,
            request_body=request_body,
            ship_node=ship_node,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def refund_order_without_preload_content(
        self,
        purchase_order_id: Annotated[StrictStr, Field(description="Purchase Order ID")],
        content_type: Annotated[StrictStr, Field(description="application/xml, application/json")],
        accept: Annotated[StrictStr, Field(description="application/xml, application/json")],
        wm_consumer_channel_type: Annotated[StrictStr, Field(description="Channel Type")],
        wm_consumer_id: Annotated[StrictStr, Field(description="Your Consumer ID")],
        wm_sec_timestamp: Annotated[StrictStr, Field(description="Epoch timestamp")],
        wm_sec_auth_signature: Annotated[StrictStr, Field(description="Authentication signature")],
        wm_svc_name: Annotated[StrictStr, Field(description="The Service name")],
        wm_qos_correlation_id: Annotated[StrictStr, Field(description="A Transaction ID")],
        request_body: Annotated[StrictStr, Field(description="Request body")],
        ship_node: Annotated[Optional[StrictStr], Field(description="Ship Node")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Refund order lines

        You can refund one or more order lines that have been shipped. The response to a successful call contains the order with the refunded line item.

        :param purchase_order_id: Purchase Order ID (required)
        :type purchase_order_id: str
        :param content_type: application/xml, application/json (required)
        :type content_type: str
        :param accept: application/xml, application/json (required)
        :type accept: str
        :param wm_consumer_channel_type: Channel Type (required)
        :type wm_consumer_channel_type: str
        :param wm_consumer_id: Your Consumer ID (required)
        :type wm_consumer_id: str
        :param wm_sec_timestamp: Epoch timestamp (required)
        :type wm_sec_timestamp: str
        :param wm_sec_auth_signature: Authentication signature (required)
        :type wm_sec_auth_signature: str
        :param wm_svc_name: The Service name (required)
        :type wm_svc_name: str
        :param wm_qos_correlation_id: A Transaction ID (required)
        :type wm_qos_correlation_id: str
        :param request_body: Request body (required)
        :type request_body: str
        :param ship_node: Ship Node
        :type ship_node: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._refund_order_serialize(
            purchase_order_id=purchase_order_id,
            content_type=content_type,
            accept=accept,
            wm_consumer_channel_type=wm_consumer_channel_type,
            wm_consumer_id=wm_consumer_id,
            wm_sec_timestamp=wm_sec_timestamp,
            wm_sec_auth_signature=wm_sec_auth_signature,
            wm_svc_name=wm_svc_name,
            wm_qos_correlation_id=wm_qos_correlation_id,
            request_body=request_body,
            ship_node=ship_node,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _refund_order_serialize(
        self,
        purchase_order_id,
        content_type,
        accept,
        wm_consumer_channel_type,
        wm_consumer_id,
        wm_sec_timestamp,
        wm_sec_auth_signature,
        wm_svc_name,
        wm_qos_correlation_id,
        request_body,
        ship_node,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if purchase_order_id is not None:
            _path_params['purchaseOrderId'] = purchase_order_id
        # process the query parameters
        if ship_node is not None:
            
            _query_params.append(('shipNode', ship_node))
            
        # process the header parameters
        if content_type is not None:
            _header_params['Content-Type'] = content_type
        if accept is not None:
            _header_params['Accept'] = accept
        if wm_consumer_channel_type is not None:
            _header_params['WM_CONSUMER.CHANNEL.TYPE'] = wm_consumer_channel_type
        if wm_consumer_id is not None:
            _header_params['WM_CONSUMER.ID'] = wm_consumer_id
        if wm_sec_timestamp is not None:
            _header_params['WM_SEC.TIMESTAMP'] = wm_sec_timestamp
        if wm_sec_auth_signature is not None:
            _header_params['WM_SEC.AUTH_SIGNATURE'] = wm_sec_auth_signature
        if wm_svc_name is not None:
            _header_params['WM_SVC.NAME'] = wm_svc_name
        if wm_qos_correlation_id is not None:
            _header_params['WM_QOS.CORRELATION_ID'] = wm_qos_correlation_id
        # process the form parameters
        # process the body parameter
        if request_body is not None:
            _body_params = request_body



        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/xml', 
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/v3/orders/{purchaseOrderId}/refund',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def shipping_order(
        self,
        purchase_order_id: Annotated[StrictStr, Field(description="Purchase Order ID")],
        content_type: Annotated[StrictStr, Field(description="application/xml, application/json")],
        accept: Annotated[StrictStr, Field(description="application/xml, application/json")],
        wm_consumer_channel_type: Annotated[StrictStr, Field(description="Channel Type")],
        wm_consumer_id: Annotated[StrictStr, Field(description="Your Consumer ID")],
        wm_sec_timestamp: Annotated[StrictStr, Field(description="Epoch timestamp")],
        wm_sec_auth_signature: Annotated[StrictStr, Field(description="Authentication signature")],
        wm_svc_name: Annotated[StrictStr, Field(description="The Service name")],
        wm_qos_correlation_id: Annotated[StrictStr, Field(description="A Transaction ID")],
        request_body: Annotated[StrictStr, Field(description="Request body")],
        ship_node: Annotated[Optional[StrictStr], Field(description="Ship Node")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """Shipping updates

        You can change the status of order lines to \"Shipped\" and trigger the charge to a customer. You must acknowledge your orders before sending a shipping update to avoid underselling. An order line, once marked as shipped, cannot be updated.

        :param purchase_order_id: Purchase Order ID (required)
        :type purchase_order_id: str
        :param content_type: application/xml, application/json (required)
        :type content_type: str
        :param accept: application/xml, application/json (required)
        :type accept: str
        :param wm_consumer_channel_type: Channel Type (required)
        :type wm_consumer_channel_type: str
        :param wm_consumer_id: Your Consumer ID (required)
        :type wm_consumer_id: str
        :param wm_sec_timestamp: Epoch timestamp (required)
        :type wm_sec_timestamp: str
        :param wm_sec_auth_signature: Authentication signature (required)
        :type wm_sec_auth_signature: str
        :param wm_svc_name: The Service name (required)
        :type wm_svc_name: str
        :param wm_qos_correlation_id: A Transaction ID (required)
        :type wm_qos_correlation_id: str
        :param request_body: Request body (required)
        :type request_body: str
        :param ship_node: Ship Node
        :type ship_node: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._shipping_order_serialize(
            purchase_order_id=purchase_order_id,
            content_type=content_type,
            accept=accept,
            wm_consumer_channel_type=wm_consumer_channel_type,
            wm_consumer_id=wm_consumer_id,
            wm_sec_timestamp=wm_sec_timestamp,
            wm_sec_auth_signature=wm_sec_auth_signature,
            wm_svc_name=wm_svc_name,
            wm_qos_correlation_id=wm_qos_correlation_id,
            request_body=request_body,
            ship_node=ship_node,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def shipping_order_with_http_info(
        self,
        purchase_order_id: Annotated[StrictStr, Field(description="Purchase Order ID")],
        content_type: Annotated[StrictStr, Field(description="application/xml, application/json")],
        accept: Annotated[StrictStr, Field(description="application/xml, application/json")],
        wm_consumer_channel_type: Annotated[StrictStr, Field(description="Channel Type")],
        wm_consumer_id: Annotated[StrictStr, Field(description="Your Consumer ID")],
        wm_sec_timestamp: Annotated[StrictStr, Field(description="Epoch timestamp")],
        wm_sec_auth_signature: Annotated[StrictStr, Field(description="Authentication signature")],
        wm_svc_name: Annotated[StrictStr, Field(description="The Service name")],
        wm_qos_correlation_id: Annotated[StrictStr, Field(description="A Transaction ID")],
        request_body: Annotated[StrictStr, Field(description="Request body")],
        ship_node: Annotated[Optional[StrictStr], Field(description="Ship Node")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """Shipping updates

        You can change the status of order lines to \"Shipped\" and trigger the charge to a customer. You must acknowledge your orders before sending a shipping update to avoid underselling. An order line, once marked as shipped, cannot be updated.

        :param purchase_order_id: Purchase Order ID (required)
        :type purchase_order_id: str
        :param content_type: application/xml, application/json (required)
        :type content_type: str
        :param accept: application/xml, application/json (required)
        :type accept: str
        :param wm_consumer_channel_type: Channel Type (required)
        :type wm_consumer_channel_type: str
        :param wm_consumer_id: Your Consumer ID (required)
        :type wm_consumer_id: str
        :param wm_sec_timestamp: Epoch timestamp (required)
        :type wm_sec_timestamp: str
        :param wm_sec_auth_signature: Authentication signature (required)
        :type wm_sec_auth_signature: str
        :param wm_svc_name: The Service name (required)
        :type wm_svc_name: str
        :param wm_qos_correlation_id: A Transaction ID (required)
        :type wm_qos_correlation_id: str
        :param request_body: Request body (required)
        :type request_body: str
        :param ship_node: Ship Node
        :type ship_node: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._shipping_order_serialize(
            purchase_order_id=purchase_order_id,
            content_type=content_type,
            accept=accept,
            wm_consumer_channel_type=wm_consumer_channel_type,
            wm_consumer_id=wm_consumer_id,
            wm_sec_timestamp=wm_sec_timestamp,
            wm_sec_auth_signature=wm_sec_auth_signature,
            wm_svc_name=wm_svc_name,
            wm_qos_correlation_id=wm_qos_correlation_id,
            request_body=request_body,
            ship_node=ship_node,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def shipping_order_without_preload_content(
        self,
        purchase_order_id: Annotated[StrictStr, Field(description="Purchase Order ID")],
        content_type: Annotated[StrictStr, Field(description="application/xml, application/json")],
        accept: Annotated[StrictStr, Field(description="application/xml, application/json")],
        wm_consumer_channel_type: Annotated[StrictStr, Field(description="Channel Type")],
        wm_consumer_id: Annotated[StrictStr, Field(description="Your Consumer ID")],
        wm_sec_timestamp: Annotated[StrictStr, Field(description="Epoch timestamp")],
        wm_sec_auth_signature: Annotated[StrictStr, Field(description="Authentication signature")],
        wm_svc_name: Annotated[StrictStr, Field(description="The Service name")],
        wm_qos_correlation_id: Annotated[StrictStr, Field(description="A Transaction ID")],
        request_body: Annotated[StrictStr, Field(description="Request body")],
        ship_node: Annotated[Optional[StrictStr], Field(description="Ship Node")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Shipping updates

        You can change the status of order lines to \"Shipped\" and trigger the charge to a customer. You must acknowledge your orders before sending a shipping update to avoid underselling. An order line, once marked as shipped, cannot be updated.

        :param purchase_order_id: Purchase Order ID (required)
        :type purchase_order_id: str
        :param content_type: application/xml, application/json (required)
        :type content_type: str
        :param accept: application/xml, application/json (required)
        :type accept: str
        :param wm_consumer_channel_type: Channel Type (required)
        :type wm_consumer_channel_type: str
        :param wm_consumer_id: Your Consumer ID (required)
        :type wm_consumer_id: str
        :param wm_sec_timestamp: Epoch timestamp (required)
        :type wm_sec_timestamp: str
        :param wm_sec_auth_signature: Authentication signature (required)
        :type wm_sec_auth_signature: str
        :param wm_svc_name: The Service name (required)
        :type wm_svc_name: str
        :param wm_qos_correlation_id: A Transaction ID (required)
        :type wm_qos_correlation_id: str
        :param request_body: Request body (required)
        :type request_body: str
        :param ship_node: Ship Node
        :type ship_node: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._shipping_order_serialize(
            purchase_order_id=purchase_order_id,
            content_type=content_type,
            accept=accept,
            wm_consumer_channel_type=wm_consumer_channel_type,
            wm_consumer_id=wm_consumer_id,
            wm_sec_timestamp=wm_sec_timestamp,
            wm_sec_auth_signature=wm_sec_auth_signature,
            wm_svc_name=wm_svc_name,
            wm_qos_correlation_id=wm_qos_correlation_id,
            request_body=request_body,
            ship_node=ship_node,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _shipping_order_serialize(
        self,
        purchase_order_id,
        content_type,
        accept,
        wm_consumer_channel_type,
        wm_consumer_id,
        wm_sec_timestamp,
        wm_sec_auth_signature,
        wm_svc_name,
        wm_qos_correlation_id,
        request_body,
        ship_node,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if purchase_order_id is not None:
            _path_params['purchaseOrderId'] = purchase_order_id
        # process the query parameters
        if ship_node is not None:
            
            _query_params.append(('shipNode', ship_node))
            
        # process the header parameters
        if content_type is not None:
            _header_params['Content-Type'] = content_type
        if accept is not None:
            _header_params['Accept'] = accept
        if wm_consumer_channel_type is not None:
            _header_params['WM_CONSUMER.CHANNEL.TYPE'] = wm_consumer_channel_type
        if wm_consumer_id is not None:
            _header_params['WM_CONSUMER.ID'] = wm_consumer_id
        if wm_sec_timestamp is not None:
            _header_params['WM_SEC.TIMESTAMP'] = wm_sec_timestamp
        if wm_sec_auth_signature is not None:
            _header_params['WM_SEC.AUTH_SIGNATURE'] = wm_sec_auth_signature
        if wm_svc_name is not None:
            _header_params['WM_SVC.NAME'] = wm_svc_name
        if wm_qos_correlation_id is not None:
            _header_params['WM_QOS.CORRELATION_ID'] = wm_qos_correlation_id
        # process the form parameters
        # process the body parameter
        if request_body is not None:
            _body_params = request_body



        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/xml', 
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/v3/orders/{purchaseOrderId}/shipping',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )


