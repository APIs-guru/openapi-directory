# coding: utf-8

"""
    Price Management

    The price is a fundamental building block for your listing on Walmart.com. You can use the price management APIs to set up and manage the price for a given item

    The version of the OpenAPI document: 1.0.0
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501

import warnings
from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
from typing import Any, Dict, List, Optional, Tuple, Union
from typing_extensions import Annotated

from pydantic import Field, StrictBytes, StrictStr, field_validator
from typing import Optional, Tuple, Union
from typing_extensions import Annotated
from openapi_client.models.create_strategy200_response import CreateStrategy200Response
from openapi_client.models.create_strategy_request import CreateStrategyRequest
from openapi_client.models.delete_strategy200_response import DeleteStrategy200Response
from openapi_client.models.get_repricer_feed200_response import GetRepricerFeed200Response
from openapi_client.models.get_repricer_feed_request import GetRepricerFeedRequest
from openapi_client.models.get_strategies200_response import GetStrategies200Response
from openapi_client.models.opt_cap_program_in_price200_response import OptCapProgramInPrice200Response
from openapi_client.models.opt_cap_program_in_price_request import OptCapProgramInPriceRequest
from openapi_client.models.price_bulk_uploads200_response import PriceBulkUploads200Response
from openapi_client.models.update_price200_response import UpdatePrice200Response
from openapi_client.models.update_price_request import UpdatePriceRequest

from openapi_client.api_client import ApiClient, RequestSerialized
from openapi_client.api_response import ApiResponse
from openapi_client.rest import RESTResponseType


class PricesApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client


    @validate_call
    def create_strategy(
        self,
        wm_sec_access_token: Annotated[StrictStr, Field(description="The access token retrieved in the Token API call")],
        wm_qos_correlation_id: Annotated[StrictStr, Field(description="A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID")],
        wm_svc_name: Annotated[StrictStr, Field(description="Walmart Service Name")],
        create_strategy_request: Annotated[CreateStrategyRequest, Field(description="The request body will have the strategy related information")],
        wm_consumer_channel_type: Annotated[Optional[StrictStr], Field(description="A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> CreateStrategy200Response:
        """Create Repricer Strategy

        Creates a new strategy for the seller

        :param wm_sec_access_token: The access token retrieved in the Token API call (required)
        :type wm_sec_access_token: str
        :param wm_qos_correlation_id: A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID (required)
        :type wm_qos_correlation_id: str
        :param wm_svc_name: Walmart Service Name (required)
        :type wm_svc_name: str
        :param create_strategy_request: The request body will have the strategy related information (required)
        :type create_strategy_request: CreateStrategyRequest
        :param wm_consumer_channel_type: A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
        :type wm_consumer_channel_type: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_strategy_serialize(
            wm_sec_access_token=wm_sec_access_token,
            wm_qos_correlation_id=wm_qos_correlation_id,
            wm_svc_name=wm_svc_name,
            create_strategy_request=create_strategy_request,
            wm_consumer_channel_type=wm_consumer_channel_type,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CreateStrategy200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def create_strategy_with_http_info(
        self,
        wm_sec_access_token: Annotated[StrictStr, Field(description="The access token retrieved in the Token API call")],
        wm_qos_correlation_id: Annotated[StrictStr, Field(description="A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID")],
        wm_svc_name: Annotated[StrictStr, Field(description="Walmart Service Name")],
        create_strategy_request: Annotated[CreateStrategyRequest, Field(description="The request body will have the strategy related information")],
        wm_consumer_channel_type: Annotated[Optional[StrictStr], Field(description="A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[CreateStrategy200Response]:
        """Create Repricer Strategy

        Creates a new strategy for the seller

        :param wm_sec_access_token: The access token retrieved in the Token API call (required)
        :type wm_sec_access_token: str
        :param wm_qos_correlation_id: A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID (required)
        :type wm_qos_correlation_id: str
        :param wm_svc_name: Walmart Service Name (required)
        :type wm_svc_name: str
        :param create_strategy_request: The request body will have the strategy related information (required)
        :type create_strategy_request: CreateStrategyRequest
        :param wm_consumer_channel_type: A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
        :type wm_consumer_channel_type: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_strategy_serialize(
            wm_sec_access_token=wm_sec_access_token,
            wm_qos_correlation_id=wm_qos_correlation_id,
            wm_svc_name=wm_svc_name,
            create_strategy_request=create_strategy_request,
            wm_consumer_channel_type=wm_consumer_channel_type,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CreateStrategy200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def create_strategy_without_preload_content(
        self,
        wm_sec_access_token: Annotated[StrictStr, Field(description="The access token retrieved in the Token API call")],
        wm_qos_correlation_id: Annotated[StrictStr, Field(description="A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID")],
        wm_svc_name: Annotated[StrictStr, Field(description="Walmart Service Name")],
        create_strategy_request: Annotated[CreateStrategyRequest, Field(description="The request body will have the strategy related information")],
        wm_consumer_channel_type: Annotated[Optional[StrictStr], Field(description="A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Create Repricer Strategy

        Creates a new strategy for the seller

        :param wm_sec_access_token: The access token retrieved in the Token API call (required)
        :type wm_sec_access_token: str
        :param wm_qos_correlation_id: A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID (required)
        :type wm_qos_correlation_id: str
        :param wm_svc_name: Walmart Service Name (required)
        :type wm_svc_name: str
        :param create_strategy_request: The request body will have the strategy related information (required)
        :type create_strategy_request: CreateStrategyRequest
        :param wm_consumer_channel_type: A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
        :type wm_consumer_channel_type: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_strategy_serialize(
            wm_sec_access_token=wm_sec_access_token,
            wm_qos_correlation_id=wm_qos_correlation_id,
            wm_svc_name=wm_svc_name,
            create_strategy_request=create_strategy_request,
            wm_consumer_channel_type=wm_consumer_channel_type,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CreateStrategy200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _create_strategy_serialize(
        self,
        wm_sec_access_token,
        wm_qos_correlation_id,
        wm_svc_name,
        create_strategy_request,
        wm_consumer_channel_type,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        if wm_sec_access_token is not None:
            _header_params['WM_SEC.ACCESS_TOKEN'] = wm_sec_access_token
        if wm_consumer_channel_type is not None:
            _header_params['WM_CONSUMER.CHANNEL.TYPE'] = wm_consumer_channel_type
        if wm_qos_correlation_id is not None:
            _header_params['WM_QOS.CORRELATION_ID'] = wm_qos_correlation_id
        if wm_svc_name is not None:
            _header_params['WM_SVC.NAME'] = wm_svc_name
        # process the form parameters
        # process the body parameter
        if create_strategy_request is not None:
            _body_params = create_strategy_request


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/v3/repricer/strategy',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def delete_strategy(
        self,
        wm_sec_access_token: Annotated[StrictStr, Field(description="The access token retrieved in the Token API call")],
        wm_qos_correlation_id: Annotated[StrictStr, Field(description="A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID")],
        wm_svc_name: Annotated[StrictStr, Field(description="Walmart Service Name")],
        strategy_collection_id: Annotated[StrictStr, Field(description="Automatically added")],
        wm_consumer_channel_type: Annotated[Optional[StrictStr], Field(description="A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> DeleteStrategy200Response:
        """Delete Repricer Strategy

        Deletes the strategy

        :param wm_sec_access_token: The access token retrieved in the Token API call (required)
        :type wm_sec_access_token: str
        :param wm_qos_correlation_id: A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID (required)
        :type wm_qos_correlation_id: str
        :param wm_svc_name: Walmart Service Name (required)
        :type wm_svc_name: str
        :param strategy_collection_id: Automatically added (required)
        :type strategy_collection_id: str
        :param wm_consumer_channel_type: A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
        :type wm_consumer_channel_type: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_strategy_serialize(
            wm_sec_access_token=wm_sec_access_token,
            wm_qos_correlation_id=wm_qos_correlation_id,
            wm_svc_name=wm_svc_name,
            strategy_collection_id=strategy_collection_id,
            wm_consumer_channel_type=wm_consumer_channel_type,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "DeleteStrategy200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def delete_strategy_with_http_info(
        self,
        wm_sec_access_token: Annotated[StrictStr, Field(description="The access token retrieved in the Token API call")],
        wm_qos_correlation_id: Annotated[StrictStr, Field(description="A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID")],
        wm_svc_name: Annotated[StrictStr, Field(description="Walmart Service Name")],
        strategy_collection_id: Annotated[StrictStr, Field(description="Automatically added")],
        wm_consumer_channel_type: Annotated[Optional[StrictStr], Field(description="A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[DeleteStrategy200Response]:
        """Delete Repricer Strategy

        Deletes the strategy

        :param wm_sec_access_token: The access token retrieved in the Token API call (required)
        :type wm_sec_access_token: str
        :param wm_qos_correlation_id: A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID (required)
        :type wm_qos_correlation_id: str
        :param wm_svc_name: Walmart Service Name (required)
        :type wm_svc_name: str
        :param strategy_collection_id: Automatically added (required)
        :type strategy_collection_id: str
        :param wm_consumer_channel_type: A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
        :type wm_consumer_channel_type: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_strategy_serialize(
            wm_sec_access_token=wm_sec_access_token,
            wm_qos_correlation_id=wm_qos_correlation_id,
            wm_svc_name=wm_svc_name,
            strategy_collection_id=strategy_collection_id,
            wm_consumer_channel_type=wm_consumer_channel_type,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "DeleteStrategy200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def delete_strategy_without_preload_content(
        self,
        wm_sec_access_token: Annotated[StrictStr, Field(description="The access token retrieved in the Token API call")],
        wm_qos_correlation_id: Annotated[StrictStr, Field(description="A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID")],
        wm_svc_name: Annotated[StrictStr, Field(description="Walmart Service Name")],
        strategy_collection_id: Annotated[StrictStr, Field(description="Automatically added")],
        wm_consumer_channel_type: Annotated[Optional[StrictStr], Field(description="A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Delete Repricer Strategy

        Deletes the strategy

        :param wm_sec_access_token: The access token retrieved in the Token API call (required)
        :type wm_sec_access_token: str
        :param wm_qos_correlation_id: A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID (required)
        :type wm_qos_correlation_id: str
        :param wm_svc_name: Walmart Service Name (required)
        :type wm_svc_name: str
        :param strategy_collection_id: Automatically added (required)
        :type strategy_collection_id: str
        :param wm_consumer_channel_type: A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
        :type wm_consumer_channel_type: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_strategy_serialize(
            wm_sec_access_token=wm_sec_access_token,
            wm_qos_correlation_id=wm_qos_correlation_id,
            wm_svc_name=wm_svc_name,
            strategy_collection_id=strategy_collection_id,
            wm_consumer_channel_type=wm_consumer_channel_type,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "DeleteStrategy200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _delete_strategy_serialize(
        self,
        wm_sec_access_token,
        wm_qos_correlation_id,
        wm_svc_name,
        strategy_collection_id,
        wm_consumer_channel_type,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if strategy_collection_id is not None:
            _path_params['strategyCollectionId'] = strategy_collection_id
        # process the query parameters
        # process the header parameters
        if wm_sec_access_token is not None:
            _header_params['WM_SEC.ACCESS_TOKEN'] = wm_sec_access_token
        if wm_consumer_channel_type is not None:
            _header_params['WM_CONSUMER.CHANNEL.TYPE'] = wm_consumer_channel_type
        if wm_qos_correlation_id is not None:
            _header_params['WM_QOS.CORRELATION_ID'] = wm_qos_correlation_id
        if wm_svc_name is not None:
            _header_params['WM_SVC.NAME'] = wm_svc_name
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='DELETE',
            resource_path='/v3/repricer/strategy/{strategyCollectionId}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_repricer_feed(
        self,
        wm_sec_access_token: Annotated[StrictStr, Field(description="The access token retrieved in the Token API call")],
        wm_qos_correlation_id: Annotated[StrictStr, Field(description="A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID")],
        wm_svc_name: Annotated[StrictStr, Field(description="Walmart Service Name")],
        get_repricer_feed_request: GetRepricerFeedRequest,
        wm_consumer_channel_type: Annotated[Optional[StrictStr], Field(description="A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GetRepricerFeed200Response:
        """Assign/Unassign items to/from Repricer Strategy

        Add/Remove one or more items from a strategy

        :param wm_sec_access_token: The access token retrieved in the Token API call (required)
        :type wm_sec_access_token: str
        :param wm_qos_correlation_id: A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID (required)
        :type wm_qos_correlation_id: str
        :param wm_svc_name: Walmart Service Name (required)
        :type wm_svc_name: str
        :param get_repricer_feed_request: (required)
        :type get_repricer_feed_request: GetRepricerFeedRequest
        :param wm_consumer_channel_type: A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
        :type wm_consumer_channel_type: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_repricer_feed_serialize(
            wm_sec_access_token=wm_sec_access_token,
            wm_qos_correlation_id=wm_qos_correlation_id,
            wm_svc_name=wm_svc_name,
            get_repricer_feed_request=get_repricer_feed_request,
            wm_consumer_channel_type=wm_consumer_channel_type,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetRepricerFeed200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_repricer_feed_with_http_info(
        self,
        wm_sec_access_token: Annotated[StrictStr, Field(description="The access token retrieved in the Token API call")],
        wm_qos_correlation_id: Annotated[StrictStr, Field(description="A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID")],
        wm_svc_name: Annotated[StrictStr, Field(description="Walmart Service Name")],
        get_repricer_feed_request: GetRepricerFeedRequest,
        wm_consumer_channel_type: Annotated[Optional[StrictStr], Field(description="A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GetRepricerFeed200Response]:
        """Assign/Unassign items to/from Repricer Strategy

        Add/Remove one or more items from a strategy

        :param wm_sec_access_token: The access token retrieved in the Token API call (required)
        :type wm_sec_access_token: str
        :param wm_qos_correlation_id: A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID (required)
        :type wm_qos_correlation_id: str
        :param wm_svc_name: Walmart Service Name (required)
        :type wm_svc_name: str
        :param get_repricer_feed_request: (required)
        :type get_repricer_feed_request: GetRepricerFeedRequest
        :param wm_consumer_channel_type: A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
        :type wm_consumer_channel_type: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_repricer_feed_serialize(
            wm_sec_access_token=wm_sec_access_token,
            wm_qos_correlation_id=wm_qos_correlation_id,
            wm_svc_name=wm_svc_name,
            get_repricer_feed_request=get_repricer_feed_request,
            wm_consumer_channel_type=wm_consumer_channel_type,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetRepricerFeed200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_repricer_feed_without_preload_content(
        self,
        wm_sec_access_token: Annotated[StrictStr, Field(description="The access token retrieved in the Token API call")],
        wm_qos_correlation_id: Annotated[StrictStr, Field(description="A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID")],
        wm_svc_name: Annotated[StrictStr, Field(description="Walmart Service Name")],
        get_repricer_feed_request: GetRepricerFeedRequest,
        wm_consumer_channel_type: Annotated[Optional[StrictStr], Field(description="A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Assign/Unassign items to/from Repricer Strategy

        Add/Remove one or more items from a strategy

        :param wm_sec_access_token: The access token retrieved in the Token API call (required)
        :type wm_sec_access_token: str
        :param wm_qos_correlation_id: A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID (required)
        :type wm_qos_correlation_id: str
        :param wm_svc_name: Walmart Service Name (required)
        :type wm_svc_name: str
        :param get_repricer_feed_request: (required)
        :type get_repricer_feed_request: GetRepricerFeedRequest
        :param wm_consumer_channel_type: A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
        :type wm_consumer_channel_type: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_repricer_feed_serialize(
            wm_sec_access_token=wm_sec_access_token,
            wm_qos_correlation_id=wm_qos_correlation_id,
            wm_svc_name=wm_svc_name,
            get_repricer_feed_request=get_repricer_feed_request,
            wm_consumer_channel_type=wm_consumer_channel_type,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetRepricerFeed200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_repricer_feed_serialize(
        self,
        wm_sec_access_token,
        wm_qos_correlation_id,
        wm_svc_name,
        get_repricer_feed_request,
        wm_consumer_channel_type,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        if wm_sec_access_token is not None:
            _header_params['WM_SEC.ACCESS_TOKEN'] = wm_sec_access_token
        if wm_consumer_channel_type is not None:
            _header_params['WM_CONSUMER.CHANNEL.TYPE'] = wm_consumer_channel_type
        if wm_qos_correlation_id is not None:
            _header_params['WM_QOS.CORRELATION_ID'] = wm_qos_correlation_id
        if wm_svc_name is not None:
            _header_params['WM_SVC.NAME'] = wm_svc_name
        # process the form parameters
        # process the body parameter
        if get_repricer_feed_request is not None:
            _body_params = get_repricer_feed_request


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/v3/repricerFeeds',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_strategies(
        self,
        wm_sec_access_token: Annotated[StrictStr, Field(description="The access token retrieved in the Token API call")],
        wm_qos_correlation_id: Annotated[StrictStr, Field(description="A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID")],
        wm_svc_name: Annotated[StrictStr, Field(description="Walmart Service Name")],
        wm_consumer_channel_type: Annotated[Optional[StrictStr], Field(description="A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GetStrategies200Response:
        """List of Repricer Strategies

        Get the list of strategies

        :param wm_sec_access_token: The access token retrieved in the Token API call (required)
        :type wm_sec_access_token: str
        :param wm_qos_correlation_id: A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID (required)
        :type wm_qos_correlation_id: str
        :param wm_svc_name: Walmart Service Name (required)
        :type wm_svc_name: str
        :param wm_consumer_channel_type: A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
        :type wm_consumer_channel_type: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_strategies_serialize(
            wm_sec_access_token=wm_sec_access_token,
            wm_qos_correlation_id=wm_qos_correlation_id,
            wm_svc_name=wm_svc_name,
            wm_consumer_channel_type=wm_consumer_channel_type,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetStrategies200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_strategies_with_http_info(
        self,
        wm_sec_access_token: Annotated[StrictStr, Field(description="The access token retrieved in the Token API call")],
        wm_qos_correlation_id: Annotated[StrictStr, Field(description="A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID")],
        wm_svc_name: Annotated[StrictStr, Field(description="Walmart Service Name")],
        wm_consumer_channel_type: Annotated[Optional[StrictStr], Field(description="A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GetStrategies200Response]:
        """List of Repricer Strategies

        Get the list of strategies

        :param wm_sec_access_token: The access token retrieved in the Token API call (required)
        :type wm_sec_access_token: str
        :param wm_qos_correlation_id: A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID (required)
        :type wm_qos_correlation_id: str
        :param wm_svc_name: Walmart Service Name (required)
        :type wm_svc_name: str
        :param wm_consumer_channel_type: A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
        :type wm_consumer_channel_type: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_strategies_serialize(
            wm_sec_access_token=wm_sec_access_token,
            wm_qos_correlation_id=wm_qos_correlation_id,
            wm_svc_name=wm_svc_name,
            wm_consumer_channel_type=wm_consumer_channel_type,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetStrategies200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_strategies_without_preload_content(
        self,
        wm_sec_access_token: Annotated[StrictStr, Field(description="The access token retrieved in the Token API call")],
        wm_qos_correlation_id: Annotated[StrictStr, Field(description="A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID")],
        wm_svc_name: Annotated[StrictStr, Field(description="Walmart Service Name")],
        wm_consumer_channel_type: Annotated[Optional[StrictStr], Field(description="A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """List of Repricer Strategies

        Get the list of strategies

        :param wm_sec_access_token: The access token retrieved in the Token API call (required)
        :type wm_sec_access_token: str
        :param wm_qos_correlation_id: A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID (required)
        :type wm_qos_correlation_id: str
        :param wm_svc_name: Walmart Service Name (required)
        :type wm_svc_name: str
        :param wm_consumer_channel_type: A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
        :type wm_consumer_channel_type: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_strategies_serialize(
            wm_sec_access_token=wm_sec_access_token,
            wm_qos_correlation_id=wm_qos_correlation_id,
            wm_svc_name=wm_svc_name,
            wm_consumer_channel_type=wm_consumer_channel_type,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetStrategies200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_strategies_serialize(
        self,
        wm_sec_access_token,
        wm_qos_correlation_id,
        wm_svc_name,
        wm_consumer_channel_type,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        if wm_sec_access_token is not None:
            _header_params['WM_SEC.ACCESS_TOKEN'] = wm_sec_access_token
        if wm_consumer_channel_type is not None:
            _header_params['WM_CONSUMER.CHANNEL.TYPE'] = wm_consumer_channel_type
        if wm_qos_correlation_id is not None:
            _header_params['WM_QOS.CORRELATION_ID'] = wm_qos_correlation_id
        if wm_svc_name is not None:
            _header_params['WM_SVC.NAME'] = wm_svc_name
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/v3/repricer/strategies',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def opt_cap_program_in_price(
        self,
        wm_sec_access_token: Annotated[StrictStr, Field(description="The access token retrieved in the Token API call")],
        wm_qos_correlation_id: Annotated[StrictStr, Field(description="A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID")],
        wm_svc_name: Annotated[StrictStr, Field(description="Walmart Service Name")],
        opt_cap_program_in_price_request: Annotated[OptCapProgramInPriceRequest, Field(description="Request fields")],
        wm_consumer_channel_type: Annotated[Optional[StrictStr], Field(description="A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> OptCapProgramInPrice200Response:
        """Set up CAP SKU All

        This API helps Sellers to completely opt-in or opt-out from CAP program.  If the subsidyEnrolled value = \"true\", the Seller enrolls in the CAP program. All eligible SKUs (current and future) are by default opt-in. Seller should use the SKU opt-in/opt-out API to opt-out individual items.  If the subsidyEnrolled value = \"false\", the Seller stops participating in the CAP program and all eligible SKUs (current and future) are opt-out of the CAP program.

        :param wm_sec_access_token: The access token retrieved in the Token API call (required)
        :type wm_sec_access_token: str
        :param wm_qos_correlation_id: A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID (required)
        :type wm_qos_correlation_id: str
        :param wm_svc_name: Walmart Service Name (required)
        :type wm_svc_name: str
        :param opt_cap_program_in_price_request: Request fields (required)
        :type opt_cap_program_in_price_request: OptCapProgramInPriceRequest
        :param wm_consumer_channel_type: A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
        :type wm_consumer_channel_type: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._opt_cap_program_in_price_serialize(
            wm_sec_access_token=wm_sec_access_token,
            wm_qos_correlation_id=wm_qos_correlation_id,
            wm_svc_name=wm_svc_name,
            opt_cap_program_in_price_request=opt_cap_program_in_price_request,
            wm_consumer_channel_type=wm_consumer_channel_type,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OptCapProgramInPrice200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def opt_cap_program_in_price_with_http_info(
        self,
        wm_sec_access_token: Annotated[StrictStr, Field(description="The access token retrieved in the Token API call")],
        wm_qos_correlation_id: Annotated[StrictStr, Field(description="A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID")],
        wm_svc_name: Annotated[StrictStr, Field(description="Walmart Service Name")],
        opt_cap_program_in_price_request: Annotated[OptCapProgramInPriceRequest, Field(description="Request fields")],
        wm_consumer_channel_type: Annotated[Optional[StrictStr], Field(description="A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[OptCapProgramInPrice200Response]:
        """Set up CAP SKU All

        This API helps Sellers to completely opt-in or opt-out from CAP program.  If the subsidyEnrolled value = \"true\", the Seller enrolls in the CAP program. All eligible SKUs (current and future) are by default opt-in. Seller should use the SKU opt-in/opt-out API to opt-out individual items.  If the subsidyEnrolled value = \"false\", the Seller stops participating in the CAP program and all eligible SKUs (current and future) are opt-out of the CAP program.

        :param wm_sec_access_token: The access token retrieved in the Token API call (required)
        :type wm_sec_access_token: str
        :param wm_qos_correlation_id: A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID (required)
        :type wm_qos_correlation_id: str
        :param wm_svc_name: Walmart Service Name (required)
        :type wm_svc_name: str
        :param opt_cap_program_in_price_request: Request fields (required)
        :type opt_cap_program_in_price_request: OptCapProgramInPriceRequest
        :param wm_consumer_channel_type: A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
        :type wm_consumer_channel_type: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._opt_cap_program_in_price_serialize(
            wm_sec_access_token=wm_sec_access_token,
            wm_qos_correlation_id=wm_qos_correlation_id,
            wm_svc_name=wm_svc_name,
            opt_cap_program_in_price_request=opt_cap_program_in_price_request,
            wm_consumer_channel_type=wm_consumer_channel_type,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OptCapProgramInPrice200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def opt_cap_program_in_price_without_preload_content(
        self,
        wm_sec_access_token: Annotated[StrictStr, Field(description="The access token retrieved in the Token API call")],
        wm_qos_correlation_id: Annotated[StrictStr, Field(description="A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID")],
        wm_svc_name: Annotated[StrictStr, Field(description="Walmart Service Name")],
        opt_cap_program_in_price_request: Annotated[OptCapProgramInPriceRequest, Field(description="Request fields")],
        wm_consumer_channel_type: Annotated[Optional[StrictStr], Field(description="A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Set up CAP SKU All

        This API helps Sellers to completely opt-in or opt-out from CAP program.  If the subsidyEnrolled value = \"true\", the Seller enrolls in the CAP program. All eligible SKUs (current and future) are by default opt-in. Seller should use the SKU opt-in/opt-out API to opt-out individual items.  If the subsidyEnrolled value = \"false\", the Seller stops participating in the CAP program and all eligible SKUs (current and future) are opt-out of the CAP program.

        :param wm_sec_access_token: The access token retrieved in the Token API call (required)
        :type wm_sec_access_token: str
        :param wm_qos_correlation_id: A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID (required)
        :type wm_qos_correlation_id: str
        :param wm_svc_name: Walmart Service Name (required)
        :type wm_svc_name: str
        :param opt_cap_program_in_price_request: Request fields (required)
        :type opt_cap_program_in_price_request: OptCapProgramInPriceRequest
        :param wm_consumer_channel_type: A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
        :type wm_consumer_channel_type: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._opt_cap_program_in_price_serialize(
            wm_sec_access_token=wm_sec_access_token,
            wm_qos_correlation_id=wm_qos_correlation_id,
            wm_svc_name=wm_svc_name,
            opt_cap_program_in_price_request=opt_cap_program_in_price_request,
            wm_consumer_channel_type=wm_consumer_channel_type,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OptCapProgramInPrice200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _opt_cap_program_in_price_serialize(
        self,
        wm_sec_access_token,
        wm_qos_correlation_id,
        wm_svc_name,
        opt_cap_program_in_price_request,
        wm_consumer_channel_type,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        if wm_sec_access_token is not None:
            _header_params['WM_SEC.ACCESS_TOKEN'] = wm_sec_access_token
        if wm_consumer_channel_type is not None:
            _header_params['WM_CONSUMER.CHANNEL.TYPE'] = wm_consumer_channel_type
        if wm_qos_correlation_id is not None:
            _header_params['WM_QOS.CORRELATION_ID'] = wm_qos_correlation_id
        if wm_svc_name is not None:
            _header_params['WM_SVC.NAME'] = wm_svc_name
        # process the form parameters
        # process the body parameter
        if opt_cap_program_in_price_request is not None:
            _body_params = opt_cap_program_in_price_request


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/v3/cppreference',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def price_bulk_uploads(
        self,
        feed_type: Annotated[StrictStr, Field(description="The feed Type")],
        wm_sec_access_token: Annotated[StrictStr, Field(description="The access token retrieved in the Token API call")],
        wm_qos_correlation_id: Annotated[StrictStr, Field(description="A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID")],
        wm_svc_name: Annotated[StrictStr, Field(description="Walmart Service Name")],
        file: Annotated[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]], Field(description="Feed file to upload")],
        wm_consumer_channel_type: Annotated[Optional[StrictStr], Field(description="A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> PriceBulkUploads200Response:
        """Update bulk prices (Multiple)

        Updates prices in bulk.  In one Feed you can update up to 10,000 items in bulk. To ensure optimal Feed processing time, we recommend sending no more than 1000 items in one Feed and keeping the Feed sizes below 10 MB.  The price sequence guarantee is observed by the bulk price update functionality, subject to the following rules:  The timestamp used to determine precedence is passed in the request headers. All price updates in the feed are considered to have the same timestamp. The timestamp in the XML file is used only for auditing. You can send a single SKU multiple times in one Feed. If a SKU is repeated in a Feed, the price will be set for that SKU on Walmart.com, but there is no guarantee as to which SKU's price within that feed will be used. This API should be used in preference to the update a price. It should be called no sooner than 24 hours after a new item is set up and a wpid (Walmart Part ID) is available. Thereafter, the bulk price update has an service level agreement (SLA) of 15 minutes.  After the update is submitted, wait for at least five minutes before verifying whether the bulk price update was successful. Individual SKU price update success or failure is only available after the entire feed is processed.  If a SKU's price update fails (for example, multiple price updates were sent for the same SKU in a single feed), an error will be returned.

        :param feed_type: The feed Type (required)
        :type feed_type: str
        :param wm_sec_access_token: The access token retrieved in the Token API call (required)
        :type wm_sec_access_token: str
        :param wm_qos_correlation_id: A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID (required)
        :type wm_qos_correlation_id: str
        :param wm_svc_name: Walmart Service Name (required)
        :type wm_svc_name: str
        :param file: Feed file to upload (required)
        :type file: bytearray
        :param wm_consumer_channel_type: A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
        :type wm_consumer_channel_type: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._price_bulk_uploads_serialize(
            feed_type=feed_type,
            wm_sec_access_token=wm_sec_access_token,
            wm_qos_correlation_id=wm_qos_correlation_id,
            wm_svc_name=wm_svc_name,
            file=file,
            wm_consumer_channel_type=wm_consumer_channel_type,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PriceBulkUploads200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def price_bulk_uploads_with_http_info(
        self,
        feed_type: Annotated[StrictStr, Field(description="The feed Type")],
        wm_sec_access_token: Annotated[StrictStr, Field(description="The access token retrieved in the Token API call")],
        wm_qos_correlation_id: Annotated[StrictStr, Field(description="A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID")],
        wm_svc_name: Annotated[StrictStr, Field(description="Walmart Service Name")],
        file: Annotated[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]], Field(description="Feed file to upload")],
        wm_consumer_channel_type: Annotated[Optional[StrictStr], Field(description="A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[PriceBulkUploads200Response]:
        """Update bulk prices (Multiple)

        Updates prices in bulk.  In one Feed you can update up to 10,000 items in bulk. To ensure optimal Feed processing time, we recommend sending no more than 1000 items in one Feed and keeping the Feed sizes below 10 MB.  The price sequence guarantee is observed by the bulk price update functionality, subject to the following rules:  The timestamp used to determine precedence is passed in the request headers. All price updates in the feed are considered to have the same timestamp. The timestamp in the XML file is used only for auditing. You can send a single SKU multiple times in one Feed. If a SKU is repeated in a Feed, the price will be set for that SKU on Walmart.com, but there is no guarantee as to which SKU's price within that feed will be used. This API should be used in preference to the update a price. It should be called no sooner than 24 hours after a new item is set up and a wpid (Walmart Part ID) is available. Thereafter, the bulk price update has an service level agreement (SLA) of 15 minutes.  After the update is submitted, wait for at least five minutes before verifying whether the bulk price update was successful. Individual SKU price update success or failure is only available after the entire feed is processed.  If a SKU's price update fails (for example, multiple price updates were sent for the same SKU in a single feed), an error will be returned.

        :param feed_type: The feed Type (required)
        :type feed_type: str
        :param wm_sec_access_token: The access token retrieved in the Token API call (required)
        :type wm_sec_access_token: str
        :param wm_qos_correlation_id: A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID (required)
        :type wm_qos_correlation_id: str
        :param wm_svc_name: Walmart Service Name (required)
        :type wm_svc_name: str
        :param file: Feed file to upload (required)
        :type file: bytearray
        :param wm_consumer_channel_type: A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
        :type wm_consumer_channel_type: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._price_bulk_uploads_serialize(
            feed_type=feed_type,
            wm_sec_access_token=wm_sec_access_token,
            wm_qos_correlation_id=wm_qos_correlation_id,
            wm_svc_name=wm_svc_name,
            file=file,
            wm_consumer_channel_type=wm_consumer_channel_type,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PriceBulkUploads200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def price_bulk_uploads_without_preload_content(
        self,
        feed_type: Annotated[StrictStr, Field(description="The feed Type")],
        wm_sec_access_token: Annotated[StrictStr, Field(description="The access token retrieved in the Token API call")],
        wm_qos_correlation_id: Annotated[StrictStr, Field(description="A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID")],
        wm_svc_name: Annotated[StrictStr, Field(description="Walmart Service Name")],
        file: Annotated[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]], Field(description="Feed file to upload")],
        wm_consumer_channel_type: Annotated[Optional[StrictStr], Field(description="A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Update bulk prices (Multiple)

        Updates prices in bulk.  In one Feed you can update up to 10,000 items in bulk. To ensure optimal Feed processing time, we recommend sending no more than 1000 items in one Feed and keeping the Feed sizes below 10 MB.  The price sequence guarantee is observed by the bulk price update functionality, subject to the following rules:  The timestamp used to determine precedence is passed in the request headers. All price updates in the feed are considered to have the same timestamp. The timestamp in the XML file is used only for auditing. You can send a single SKU multiple times in one Feed. If a SKU is repeated in a Feed, the price will be set for that SKU on Walmart.com, but there is no guarantee as to which SKU's price within that feed will be used. This API should be used in preference to the update a price. It should be called no sooner than 24 hours after a new item is set up and a wpid (Walmart Part ID) is available. Thereafter, the bulk price update has an service level agreement (SLA) of 15 minutes.  After the update is submitted, wait for at least five minutes before verifying whether the bulk price update was successful. Individual SKU price update success or failure is only available after the entire feed is processed.  If a SKU's price update fails (for example, multiple price updates were sent for the same SKU in a single feed), an error will be returned.

        :param feed_type: The feed Type (required)
        :type feed_type: str
        :param wm_sec_access_token: The access token retrieved in the Token API call (required)
        :type wm_sec_access_token: str
        :param wm_qos_correlation_id: A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID (required)
        :type wm_qos_correlation_id: str
        :param wm_svc_name: Walmart Service Name (required)
        :type wm_svc_name: str
        :param file: Feed file to upload (required)
        :type file: bytearray
        :param wm_consumer_channel_type: A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
        :type wm_consumer_channel_type: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._price_bulk_uploads_serialize(
            feed_type=feed_type,
            wm_sec_access_token=wm_sec_access_token,
            wm_qos_correlation_id=wm_qos_correlation_id,
            wm_svc_name=wm_svc_name,
            file=file,
            wm_consumer_channel_type=wm_consumer_channel_type,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PriceBulkUploads200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _price_bulk_uploads_serialize(
        self,
        feed_type,
        wm_sec_access_token,
        wm_qos_correlation_id,
        wm_svc_name,
        file,
        wm_consumer_channel_type,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if feed_type is not None:
            
            _query_params.append(('feedType', feed_type))
            
        # process the header parameters
        if wm_sec_access_token is not None:
            _header_params['WM_SEC.ACCESS_TOKEN'] = wm_sec_access_token
        if wm_consumer_channel_type is not None:
            _header_params['WM_CONSUMER.CHANNEL.TYPE'] = wm_consumer_channel_type
        if wm_qos_correlation_id is not None:
            _header_params['WM_QOS.CORRELATION_ID'] = wm_qos_correlation_id
        if wm_svc_name is not None:
            _header_params['WM_SVC.NAME'] = wm_svc_name
        # process the form parameters
        if file is not None:
            _files['file'] = file
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json', 
                    'application/xml'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'multipart/form-data'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/v3/feeds',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def update_price(
        self,
        wm_sec_access_token: Annotated[StrictStr, Field(description="The access token retrieved in the Token API call")],
        wm_qos_correlation_id: Annotated[StrictStr, Field(description="A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID")],
        wm_svc_name: Annotated[StrictStr, Field(description="Walmart Service Name")],
        update_price_request: Annotated[UpdatePriceRequest, Field(description="The request body consists of a Feed file attached to the request.")],
        wm_consumer_channel_type: Annotated[Optional[StrictStr], Field(description="A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> UpdatePrice200Response:
        """Update a price

        Updates the regular price for a given item.

        :param wm_sec_access_token: The access token retrieved in the Token API call (required)
        :type wm_sec_access_token: str
        :param wm_qos_correlation_id: A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID (required)
        :type wm_qos_correlation_id: str
        :param wm_svc_name: Walmart Service Name (required)
        :type wm_svc_name: str
        :param update_price_request: The request body consists of a Feed file attached to the request. (required)
        :type update_price_request: UpdatePriceRequest
        :param wm_consumer_channel_type: A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
        :type wm_consumer_channel_type: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_price_serialize(
            wm_sec_access_token=wm_sec_access_token,
            wm_qos_correlation_id=wm_qos_correlation_id,
            wm_svc_name=wm_svc_name,
            update_price_request=update_price_request,
            wm_consumer_channel_type=wm_consumer_channel_type,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "UpdatePrice200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def update_price_with_http_info(
        self,
        wm_sec_access_token: Annotated[StrictStr, Field(description="The access token retrieved in the Token API call")],
        wm_qos_correlation_id: Annotated[StrictStr, Field(description="A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID")],
        wm_svc_name: Annotated[StrictStr, Field(description="Walmart Service Name")],
        update_price_request: Annotated[UpdatePriceRequest, Field(description="The request body consists of a Feed file attached to the request.")],
        wm_consumer_channel_type: Annotated[Optional[StrictStr], Field(description="A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[UpdatePrice200Response]:
        """Update a price

        Updates the regular price for a given item.

        :param wm_sec_access_token: The access token retrieved in the Token API call (required)
        :type wm_sec_access_token: str
        :param wm_qos_correlation_id: A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID (required)
        :type wm_qos_correlation_id: str
        :param wm_svc_name: Walmart Service Name (required)
        :type wm_svc_name: str
        :param update_price_request: The request body consists of a Feed file attached to the request. (required)
        :type update_price_request: UpdatePriceRequest
        :param wm_consumer_channel_type: A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
        :type wm_consumer_channel_type: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_price_serialize(
            wm_sec_access_token=wm_sec_access_token,
            wm_qos_correlation_id=wm_qos_correlation_id,
            wm_svc_name=wm_svc_name,
            update_price_request=update_price_request,
            wm_consumer_channel_type=wm_consumer_channel_type,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "UpdatePrice200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def update_price_without_preload_content(
        self,
        wm_sec_access_token: Annotated[StrictStr, Field(description="The access token retrieved in the Token API call")],
        wm_qos_correlation_id: Annotated[StrictStr, Field(description="A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID")],
        wm_svc_name: Annotated[StrictStr, Field(description="Walmart Service Name")],
        update_price_request: Annotated[UpdatePriceRequest, Field(description="The request body consists of a Feed file attached to the request.")],
        wm_consumer_channel_type: Annotated[Optional[StrictStr], Field(description="A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Update a price

        Updates the regular price for a given item.

        :param wm_sec_access_token: The access token retrieved in the Token API call (required)
        :type wm_sec_access_token: str
        :param wm_qos_correlation_id: A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID (required)
        :type wm_qos_correlation_id: str
        :param wm_svc_name: Walmart Service Name (required)
        :type wm_svc_name: str
        :param update_price_request: The request body consists of a Feed file attached to the request. (required)
        :type update_price_request: UpdatePriceRequest
        :param wm_consumer_channel_type: A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
        :type wm_consumer_channel_type: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_price_serialize(
            wm_sec_access_token=wm_sec_access_token,
            wm_qos_correlation_id=wm_qos_correlation_id,
            wm_svc_name=wm_svc_name,
            update_price_request=update_price_request,
            wm_consumer_channel_type=wm_consumer_channel_type,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "UpdatePrice200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _update_price_serialize(
        self,
        wm_sec_access_token,
        wm_qos_correlation_id,
        wm_svc_name,
        update_price_request,
        wm_consumer_channel_type,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        if wm_sec_access_token is not None:
            _header_params['WM_SEC.ACCESS_TOKEN'] = wm_sec_access_token
        if wm_consumer_channel_type is not None:
            _header_params['WM_CONSUMER.CHANNEL.TYPE'] = wm_consumer_channel_type
        if wm_qos_correlation_id is not None:
            _header_params['WM_QOS.CORRELATION_ID'] = wm_qos_correlation_id
        if wm_svc_name is not None:
            _header_params['WM_SVC.NAME'] = wm_svc_name
        # process the form parameters
        # process the body parameter
        if update_price_request is not None:
            _body_params = update_price_request


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json', 
                    'application/xml'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='PUT',
            resource_path='/v3/price',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def update_strategy(
        self,
        wm_sec_access_token: Annotated[StrictStr, Field(description="The access token retrieved in the Token API call")],
        wm_qos_correlation_id: Annotated[StrictStr, Field(description="A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID")],
        wm_svc_name: Annotated[StrictStr, Field(description="Walmart Service Name")],
        strategy_collection_id: Annotated[StrictStr, Field(description="Automatically added")],
        create_strategy_request: Annotated[CreateStrategyRequest, Field(description="The request body will have the strategy related information")],
        wm_consumer_channel_type: Annotated[Optional[StrictStr], Field(description="A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> CreateStrategy200Response:
        """Update Repricer Strategy

        Updates the existing strategy

        :param wm_sec_access_token: The access token retrieved in the Token API call (required)
        :type wm_sec_access_token: str
        :param wm_qos_correlation_id: A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID (required)
        :type wm_qos_correlation_id: str
        :param wm_svc_name: Walmart Service Name (required)
        :type wm_svc_name: str
        :param strategy_collection_id: Automatically added (required)
        :type strategy_collection_id: str
        :param create_strategy_request: The request body will have the strategy related information (required)
        :type create_strategy_request: CreateStrategyRequest
        :param wm_consumer_channel_type: A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
        :type wm_consumer_channel_type: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_strategy_serialize(
            wm_sec_access_token=wm_sec_access_token,
            wm_qos_correlation_id=wm_qos_correlation_id,
            wm_svc_name=wm_svc_name,
            strategy_collection_id=strategy_collection_id,
            create_strategy_request=create_strategy_request,
            wm_consumer_channel_type=wm_consumer_channel_type,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CreateStrategy200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def update_strategy_with_http_info(
        self,
        wm_sec_access_token: Annotated[StrictStr, Field(description="The access token retrieved in the Token API call")],
        wm_qos_correlation_id: Annotated[StrictStr, Field(description="A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID")],
        wm_svc_name: Annotated[StrictStr, Field(description="Walmart Service Name")],
        strategy_collection_id: Annotated[StrictStr, Field(description="Automatically added")],
        create_strategy_request: Annotated[CreateStrategyRequest, Field(description="The request body will have the strategy related information")],
        wm_consumer_channel_type: Annotated[Optional[StrictStr], Field(description="A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[CreateStrategy200Response]:
        """Update Repricer Strategy

        Updates the existing strategy

        :param wm_sec_access_token: The access token retrieved in the Token API call (required)
        :type wm_sec_access_token: str
        :param wm_qos_correlation_id: A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID (required)
        :type wm_qos_correlation_id: str
        :param wm_svc_name: Walmart Service Name (required)
        :type wm_svc_name: str
        :param strategy_collection_id: Automatically added (required)
        :type strategy_collection_id: str
        :param create_strategy_request: The request body will have the strategy related information (required)
        :type create_strategy_request: CreateStrategyRequest
        :param wm_consumer_channel_type: A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
        :type wm_consumer_channel_type: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_strategy_serialize(
            wm_sec_access_token=wm_sec_access_token,
            wm_qos_correlation_id=wm_qos_correlation_id,
            wm_svc_name=wm_svc_name,
            strategy_collection_id=strategy_collection_id,
            create_strategy_request=create_strategy_request,
            wm_consumer_channel_type=wm_consumer_channel_type,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CreateStrategy200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def update_strategy_without_preload_content(
        self,
        wm_sec_access_token: Annotated[StrictStr, Field(description="The access token retrieved in the Token API call")],
        wm_qos_correlation_id: Annotated[StrictStr, Field(description="A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID")],
        wm_svc_name: Annotated[StrictStr, Field(description="Walmart Service Name")],
        strategy_collection_id: Annotated[StrictStr, Field(description="Automatically added")],
        create_strategy_request: Annotated[CreateStrategyRequest, Field(description="The request body will have the strategy related information")],
        wm_consumer_channel_type: Annotated[Optional[StrictStr], Field(description="A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Update Repricer Strategy

        Updates the existing strategy

        :param wm_sec_access_token: The access token retrieved in the Token API call (required)
        :type wm_sec_access_token: str
        :param wm_qos_correlation_id: A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID (required)
        :type wm_qos_correlation_id: str
        :param wm_svc_name: Walmart Service Name (required)
        :type wm_svc_name: str
        :param strategy_collection_id: Automatically added (required)
        :type strategy_collection_id: str
        :param create_strategy_request: The request body will have the strategy related information (required)
        :type create_strategy_request: CreateStrategyRequest
        :param wm_consumer_channel_type: A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
        :type wm_consumer_channel_type: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_strategy_serialize(
            wm_sec_access_token=wm_sec_access_token,
            wm_qos_correlation_id=wm_qos_correlation_id,
            wm_svc_name=wm_svc_name,
            strategy_collection_id=strategy_collection_id,
            create_strategy_request=create_strategy_request,
            wm_consumer_channel_type=wm_consumer_channel_type,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CreateStrategy200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _update_strategy_serialize(
        self,
        wm_sec_access_token,
        wm_qos_correlation_id,
        wm_svc_name,
        strategy_collection_id,
        create_strategy_request,
        wm_consumer_channel_type,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if strategy_collection_id is not None:
            _path_params['strategyCollectionId'] = strategy_collection_id
        # process the query parameters
        # process the header parameters
        if wm_sec_access_token is not None:
            _header_params['WM_SEC.ACCESS_TOKEN'] = wm_sec_access_token
        if wm_consumer_channel_type is not None:
            _header_params['WM_CONSUMER.CHANNEL.TYPE'] = wm_consumer_channel_type
        if wm_qos_correlation_id is not None:
            _header_params['WM_QOS.CORRELATION_ID'] = wm_qos_correlation_id
        if wm_svc_name is not None:
            _header_params['WM_SVC.NAME'] = wm_svc_name
        # process the form parameters
        # process the body parameter
        if create_strategy_request is not None:
            _body_params = create_strategy_request


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='PUT',
            resource_path='/v3/repricer/strategy/{strategyCollectionId}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )


