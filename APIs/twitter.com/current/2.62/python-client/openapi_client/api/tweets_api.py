# coding: utf-8

"""
    Twitter API v2

    Twitter API v2 available endpoints

    The version of the OpenAPI document: 2.62
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501

import warnings
from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
from typing import Any, Dict, List, Optional, Tuple, Union
from typing_extensions import Annotated

from datetime import datetime
from pydantic import Field, StrictBool, StrictStr, field_validator
from typing import List, Optional
from typing_extensions import Annotated
from openapi_client.models.add_or_delete_rules_request import AddOrDeleteRulesRequest
from openapi_client.models.add_or_delete_rules_response import AddOrDeleteRulesResponse
from openapi_client.models.filtered_streaming_tweet_response import FilteredStreamingTweetResponse
from openapi_client.models.get2_lists_id_tweets_response import Get2ListsIdTweetsResponse
from openapi_client.models.get2_spaces_id_buyers_response import Get2SpacesIdBuyersResponse
from openapi_client.models.get2_spaces_id_tweets_response import Get2SpacesIdTweetsResponse
from openapi_client.models.get2_tweets_counts_all_response import Get2TweetsCountsAllResponse
from openapi_client.models.get2_tweets_counts_recent_response import Get2TweetsCountsRecentResponse
from openapi_client.models.get2_tweets_id_quote_tweets_response import Get2TweetsIdQuoteTweetsResponse
from openapi_client.models.get2_tweets_id_response import Get2TweetsIdResponse
from openapi_client.models.get2_tweets_response import Get2TweetsResponse
from openapi_client.models.get2_tweets_sample10_stream_response import Get2TweetsSample10StreamResponse
from openapi_client.models.get2_tweets_search_all_response import Get2TweetsSearchAllResponse
from openapi_client.models.get2_tweets_search_recent_response import Get2TweetsSearchRecentResponse
from openapi_client.models.get2_users_id_liked_tweets_response import Get2UsersIdLikedTweetsResponse
from openapi_client.models.get2_users_id_mentions_response import Get2UsersIdMentionsResponse
from openapi_client.models.get2_users_id_timelines_reverse_chronological_response import Get2UsersIdTimelinesReverseChronologicalResponse
from openapi_client.models.get2_users_id_tweets_response import Get2UsersIdTweetsResponse
from openapi_client.models.rules_lookup_response import RulesLookupResponse
from openapi_client.models.streaming_tweet_response import StreamingTweetResponse
from openapi_client.models.tweet_create_request import TweetCreateRequest
from openapi_client.models.tweet_create_response import TweetCreateResponse
from openapi_client.models.tweet_delete_response import TweetDeleteResponse
from openapi_client.models.tweet_hide_request import TweetHideRequest
from openapi_client.models.tweet_hide_response import TweetHideResponse
from openapi_client.models.users_likes_create_request import UsersLikesCreateRequest
from openapi_client.models.users_likes_create_response import UsersLikesCreateResponse
from openapi_client.models.users_likes_delete_response import UsersLikesDeleteResponse
from openapi_client.models.users_retweets_create_request import UsersRetweetsCreateRequest
from openapi_client.models.users_retweets_create_response import UsersRetweetsCreateResponse
from openapi_client.models.users_retweets_delete_response import UsersRetweetsDeleteResponse

from openapi_client.api_client import ApiClient, RequestSerialized
from openapi_client.api_response import ApiResponse
from openapi_client.rest import RESTResponseType


class TweetsApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client


    @validate_call
    def add_or_delete_rules(
        self,
        add_or_delete_rules_request: AddOrDeleteRulesRequest,
        dry_run: Annotated[Optional[StrictBool], Field(description="Dry Run can be used with both the add and delete action, with the expected result given, but without actually taking any action in the system (meaning the end state will always be as it was when the request was submitted). This is particularly useful to validate rule changes.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> AddOrDeleteRulesResponse:
        """Add/Delete rules

        Add or delete rules from a User's active rule set. Users can provide unique, optionally tagged rules to add. Users can delete their entire rule set or a subset specified by rule ids or values.

        :param add_or_delete_rules_request: (required)
        :type add_or_delete_rules_request: AddOrDeleteRulesRequest
        :param dry_run: Dry Run can be used with both the add and delete action, with the expected result given, but without actually taking any action in the system (meaning the end state will always be as it was when the request was submitted). This is particularly useful to validate rule changes.
        :type dry_run: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._add_or_delete_rules_serialize(
            add_or_delete_rules_request=add_or_delete_rules_request,
            dry_run=dry_run,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AddOrDeleteRulesResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def add_or_delete_rules_with_http_info(
        self,
        add_or_delete_rules_request: AddOrDeleteRulesRequest,
        dry_run: Annotated[Optional[StrictBool], Field(description="Dry Run can be used with both the add and delete action, with the expected result given, but without actually taking any action in the system (meaning the end state will always be as it was when the request was submitted). This is particularly useful to validate rule changes.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[AddOrDeleteRulesResponse]:
        """Add/Delete rules

        Add or delete rules from a User's active rule set. Users can provide unique, optionally tagged rules to add. Users can delete their entire rule set or a subset specified by rule ids or values.

        :param add_or_delete_rules_request: (required)
        :type add_or_delete_rules_request: AddOrDeleteRulesRequest
        :param dry_run: Dry Run can be used with both the add and delete action, with the expected result given, but without actually taking any action in the system (meaning the end state will always be as it was when the request was submitted). This is particularly useful to validate rule changes.
        :type dry_run: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._add_or_delete_rules_serialize(
            add_or_delete_rules_request=add_or_delete_rules_request,
            dry_run=dry_run,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AddOrDeleteRulesResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def add_or_delete_rules_without_preload_content(
        self,
        add_or_delete_rules_request: AddOrDeleteRulesRequest,
        dry_run: Annotated[Optional[StrictBool], Field(description="Dry Run can be used with both the add and delete action, with the expected result given, but without actually taking any action in the system (meaning the end state will always be as it was when the request was submitted). This is particularly useful to validate rule changes.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Add/Delete rules

        Add or delete rules from a User's active rule set. Users can provide unique, optionally tagged rules to add. Users can delete their entire rule set or a subset specified by rule ids or values.

        :param add_or_delete_rules_request: (required)
        :type add_or_delete_rules_request: AddOrDeleteRulesRequest
        :param dry_run: Dry Run can be used with both the add and delete action, with the expected result given, but without actually taking any action in the system (meaning the end state will always be as it was when the request was submitted). This is particularly useful to validate rule changes.
        :type dry_run: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._add_or_delete_rules_serialize(
            add_or_delete_rules_request=add_or_delete_rules_request,
            dry_run=dry_run,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AddOrDeleteRulesResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _add_or_delete_rules_serialize(
        self,
        add_or_delete_rules_request,
        dry_run,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if dry_run is not None:
            
            _query_params.append(('dry_run', dry_run))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if add_or_delete_rules_request is not None:
            _body_params = add_or_delete_rules_request


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json', 
                    'application/problem+json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'BearerToken'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/2/tweets/search/stream/rules',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def create_tweet(
        self,
        tweet_create_request: TweetCreateRequest,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> TweetCreateResponse:
        """Creation of a Tweet

        Causes the User to create a Tweet under the authorized account.

        :param tweet_create_request: (required)
        :type tweet_create_request: TweetCreateRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_tweet_serialize(
            tweet_create_request=tweet_create_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "TweetCreateResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def create_tweet_with_http_info(
        self,
        tweet_create_request: TweetCreateRequest,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[TweetCreateResponse]:
        """Creation of a Tweet

        Causes the User to create a Tweet under the authorized account.

        :param tweet_create_request: (required)
        :type tweet_create_request: TweetCreateRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_tweet_serialize(
            tweet_create_request=tweet_create_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "TweetCreateResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def create_tweet_without_preload_content(
        self,
        tweet_create_request: TweetCreateRequest,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Creation of a Tweet

        Causes the User to create a Tweet under the authorized account.

        :param tweet_create_request: (required)
        :type tweet_create_request: TweetCreateRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_tweet_serialize(
            tweet_create_request=tweet_create_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "TweetCreateResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _create_tweet_serialize(
        self,
        tweet_create_request,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if tweet_create_request is not None:
            _body_params = tweet_create_request


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json', 
                    'application/problem+json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'OAuth2UserToken', 
            'UserToken'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/2/tweets',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def delete_tweet_by_id(
        self,
        id: Annotated[str, Field(strict=True, description="The ID of the Tweet to be deleted.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> TweetDeleteResponse:
        """Tweet delete by Tweet ID

        Delete specified Tweet (in the path) by ID.

        :param id: The ID of the Tweet to be deleted. (required)
        :type id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_tweet_by_id_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TweetDeleteResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def delete_tweet_by_id_with_http_info(
        self,
        id: Annotated[str, Field(strict=True, description="The ID of the Tweet to be deleted.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[TweetDeleteResponse]:
        """Tweet delete by Tweet ID

        Delete specified Tweet (in the path) by ID.

        :param id: The ID of the Tweet to be deleted. (required)
        :type id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_tweet_by_id_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TweetDeleteResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def delete_tweet_by_id_without_preload_content(
        self,
        id: Annotated[str, Field(strict=True, description="The ID of the Tweet to be deleted.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Tweet delete by Tweet ID

        Delete specified Tweet (in the path) by ID.

        :param id: The ID of the Tweet to be deleted. (required)
        :type id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_tweet_by_id_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TweetDeleteResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _delete_tweet_by_id_serialize(
        self,
        id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json', 
                    'application/problem+json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'OAuth2UserToken', 
            'UserToken'
        ]

        return self.api_client.param_serialize(
            method='DELETE',
            resource_path='/2/tweets/{id}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def find_tweet_by_id(
        self,
        id: Annotated[str, Field(strict=True, description="A single Tweet ID.")],
        tweet_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of Tweet fields to display.")] = None,
        expansions: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of fields to expand.")] = None,
        media_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of Media fields to display.")] = None,
        poll_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of Poll fields to display.")] = None,
        user_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of User fields to display.")] = None,
        place_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of Place fields to display.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> Get2TweetsIdResponse:
        """Tweet lookup by Tweet ID

        Returns a variety of information about the Tweet specified by the requested ID.

        :param id: A single Tweet ID. (required)
        :type id: str
        :param tweet_fields: A comma separated list of Tweet fields to display.
        :type tweet_fields: List[str]
        :param expansions: A comma separated list of fields to expand.
        :type expansions: List[str]
        :param media_fields: A comma separated list of Media fields to display.
        :type media_fields: List[str]
        :param poll_fields: A comma separated list of Poll fields to display.
        :type poll_fields: List[str]
        :param user_fields: A comma separated list of User fields to display.
        :type user_fields: List[str]
        :param place_fields: A comma separated list of Place fields to display.
        :type place_fields: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._find_tweet_by_id_serialize(
            id=id,
            tweet_fields=tweet_fields,
            expansions=expansions,
            media_fields=media_fields,
            poll_fields=poll_fields,
            user_fields=user_fields,
            place_fields=place_fields,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Get2TweetsIdResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def find_tweet_by_id_with_http_info(
        self,
        id: Annotated[str, Field(strict=True, description="A single Tweet ID.")],
        tweet_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of Tweet fields to display.")] = None,
        expansions: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of fields to expand.")] = None,
        media_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of Media fields to display.")] = None,
        poll_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of Poll fields to display.")] = None,
        user_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of User fields to display.")] = None,
        place_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of Place fields to display.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[Get2TweetsIdResponse]:
        """Tweet lookup by Tweet ID

        Returns a variety of information about the Tweet specified by the requested ID.

        :param id: A single Tweet ID. (required)
        :type id: str
        :param tweet_fields: A comma separated list of Tweet fields to display.
        :type tweet_fields: List[str]
        :param expansions: A comma separated list of fields to expand.
        :type expansions: List[str]
        :param media_fields: A comma separated list of Media fields to display.
        :type media_fields: List[str]
        :param poll_fields: A comma separated list of Poll fields to display.
        :type poll_fields: List[str]
        :param user_fields: A comma separated list of User fields to display.
        :type user_fields: List[str]
        :param place_fields: A comma separated list of Place fields to display.
        :type place_fields: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._find_tweet_by_id_serialize(
            id=id,
            tweet_fields=tweet_fields,
            expansions=expansions,
            media_fields=media_fields,
            poll_fields=poll_fields,
            user_fields=user_fields,
            place_fields=place_fields,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Get2TweetsIdResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def find_tweet_by_id_without_preload_content(
        self,
        id: Annotated[str, Field(strict=True, description="A single Tweet ID.")],
        tweet_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of Tweet fields to display.")] = None,
        expansions: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of fields to expand.")] = None,
        media_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of Media fields to display.")] = None,
        poll_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of Poll fields to display.")] = None,
        user_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of User fields to display.")] = None,
        place_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of Place fields to display.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Tweet lookup by Tweet ID

        Returns a variety of information about the Tweet specified by the requested ID.

        :param id: A single Tweet ID. (required)
        :type id: str
        :param tweet_fields: A comma separated list of Tweet fields to display.
        :type tweet_fields: List[str]
        :param expansions: A comma separated list of fields to expand.
        :type expansions: List[str]
        :param media_fields: A comma separated list of Media fields to display.
        :type media_fields: List[str]
        :param poll_fields: A comma separated list of Poll fields to display.
        :type poll_fields: List[str]
        :param user_fields: A comma separated list of User fields to display.
        :type user_fields: List[str]
        :param place_fields: A comma separated list of Place fields to display.
        :type place_fields: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._find_tweet_by_id_serialize(
            id=id,
            tweet_fields=tweet_fields,
            expansions=expansions,
            media_fields=media_fields,
            poll_fields=poll_fields,
            user_fields=user_fields,
            place_fields=place_fields,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Get2TweetsIdResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _find_tweet_by_id_serialize(
        self,
        id,
        tweet_fields,
        expansions,
        media_fields,
        poll_fields,
        user_fields,
        place_fields,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'tweet.fields': 'csv',
            'expansions': 'csv',
            'media.fields': 'csv',
            'poll.fields': 'csv',
            'user.fields': 'csv',
            'place.fields': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        if tweet_fields is not None:
            
            _query_params.append(('tweet.fields', tweet_fields))
            
        if expansions is not None:
            
            _query_params.append(('expansions', expansions))
            
        if media_fields is not None:
            
            _query_params.append(('media.fields', media_fields))
            
        if poll_fields is not None:
            
            _query_params.append(('poll.fields', poll_fields))
            
        if user_fields is not None:
            
            _query_params.append(('user.fields', user_fields))
            
        if place_fields is not None:
            
            _query_params.append(('place.fields', place_fields))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json', 
                    'application/problem+json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'OAuth2UserToken', 
            'BearerToken', 
            'UserToken'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/2/tweets/{id}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def find_tweets_by_id(
        self,
        ids: Annotated[List[Annotated[str, Field(strict=True)]], Field(min_length=1, max_length=100, description="A comma separated list of Tweet IDs. Up to 100 are allowed in a single request.")],
        tweet_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of Tweet fields to display.")] = None,
        expansions: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of fields to expand.")] = None,
        media_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of Media fields to display.")] = None,
        poll_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of Poll fields to display.")] = None,
        user_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of User fields to display.")] = None,
        place_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of Place fields to display.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> Get2TweetsResponse:
        """Tweet lookup by Tweet IDs

        Returns a variety of information about the Tweet specified by the requested ID.

        :param ids: A comma separated list of Tweet IDs. Up to 100 are allowed in a single request. (required)
        :type ids: List[str]
        :param tweet_fields: A comma separated list of Tweet fields to display.
        :type tweet_fields: List[str]
        :param expansions: A comma separated list of fields to expand.
        :type expansions: List[str]
        :param media_fields: A comma separated list of Media fields to display.
        :type media_fields: List[str]
        :param poll_fields: A comma separated list of Poll fields to display.
        :type poll_fields: List[str]
        :param user_fields: A comma separated list of User fields to display.
        :type user_fields: List[str]
        :param place_fields: A comma separated list of Place fields to display.
        :type place_fields: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._find_tweets_by_id_serialize(
            ids=ids,
            tweet_fields=tweet_fields,
            expansions=expansions,
            media_fields=media_fields,
            poll_fields=poll_fields,
            user_fields=user_fields,
            place_fields=place_fields,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Get2TweetsResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def find_tweets_by_id_with_http_info(
        self,
        ids: Annotated[List[Annotated[str, Field(strict=True)]], Field(min_length=1, max_length=100, description="A comma separated list of Tweet IDs. Up to 100 are allowed in a single request.")],
        tweet_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of Tweet fields to display.")] = None,
        expansions: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of fields to expand.")] = None,
        media_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of Media fields to display.")] = None,
        poll_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of Poll fields to display.")] = None,
        user_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of User fields to display.")] = None,
        place_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of Place fields to display.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[Get2TweetsResponse]:
        """Tweet lookup by Tweet IDs

        Returns a variety of information about the Tweet specified by the requested ID.

        :param ids: A comma separated list of Tweet IDs. Up to 100 are allowed in a single request. (required)
        :type ids: List[str]
        :param tweet_fields: A comma separated list of Tweet fields to display.
        :type tweet_fields: List[str]
        :param expansions: A comma separated list of fields to expand.
        :type expansions: List[str]
        :param media_fields: A comma separated list of Media fields to display.
        :type media_fields: List[str]
        :param poll_fields: A comma separated list of Poll fields to display.
        :type poll_fields: List[str]
        :param user_fields: A comma separated list of User fields to display.
        :type user_fields: List[str]
        :param place_fields: A comma separated list of Place fields to display.
        :type place_fields: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._find_tweets_by_id_serialize(
            ids=ids,
            tweet_fields=tweet_fields,
            expansions=expansions,
            media_fields=media_fields,
            poll_fields=poll_fields,
            user_fields=user_fields,
            place_fields=place_fields,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Get2TweetsResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def find_tweets_by_id_without_preload_content(
        self,
        ids: Annotated[List[Annotated[str, Field(strict=True)]], Field(min_length=1, max_length=100, description="A comma separated list of Tweet IDs. Up to 100 are allowed in a single request.")],
        tweet_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of Tweet fields to display.")] = None,
        expansions: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of fields to expand.")] = None,
        media_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of Media fields to display.")] = None,
        poll_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of Poll fields to display.")] = None,
        user_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of User fields to display.")] = None,
        place_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of Place fields to display.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Tweet lookup by Tweet IDs

        Returns a variety of information about the Tweet specified by the requested ID.

        :param ids: A comma separated list of Tweet IDs. Up to 100 are allowed in a single request. (required)
        :type ids: List[str]
        :param tweet_fields: A comma separated list of Tweet fields to display.
        :type tweet_fields: List[str]
        :param expansions: A comma separated list of fields to expand.
        :type expansions: List[str]
        :param media_fields: A comma separated list of Media fields to display.
        :type media_fields: List[str]
        :param poll_fields: A comma separated list of Poll fields to display.
        :type poll_fields: List[str]
        :param user_fields: A comma separated list of User fields to display.
        :type user_fields: List[str]
        :param place_fields: A comma separated list of Place fields to display.
        :type place_fields: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._find_tweets_by_id_serialize(
            ids=ids,
            tweet_fields=tweet_fields,
            expansions=expansions,
            media_fields=media_fields,
            poll_fields=poll_fields,
            user_fields=user_fields,
            place_fields=place_fields,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Get2TweetsResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _find_tweets_by_id_serialize(
        self,
        ids,
        tweet_fields,
        expansions,
        media_fields,
        poll_fields,
        user_fields,
        place_fields,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'ids': 'csv',
            'tweet.fields': 'csv',
            'expansions': 'csv',
            'media.fields': 'csv',
            'poll.fields': 'csv',
            'user.fields': 'csv',
            'place.fields': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if ids is not None:
            
            _query_params.append(('ids', ids))
            
        if tweet_fields is not None:
            
            _query_params.append(('tweet.fields', tweet_fields))
            
        if expansions is not None:
            
            _query_params.append(('expansions', expansions))
            
        if media_fields is not None:
            
            _query_params.append(('media.fields', media_fields))
            
        if poll_fields is not None:
            
            _query_params.append(('poll.fields', poll_fields))
            
        if user_fields is not None:
            
            _query_params.append(('user.fields', user_fields))
            
        if place_fields is not None:
            
            _query_params.append(('place.fields', place_fields))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json', 
                    'application/problem+json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'OAuth2UserToken', 
            'BearerToken', 
            'UserToken'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/2/tweets',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def find_tweets_that_quote_a_tweet(
        self,
        id: Annotated[str, Field(strict=True, description="A single Tweet ID.")],
        max_results: Annotated[Optional[Annotated[int, Field(le=100, strict=True, ge=10)]], Field(description="The maximum number of results to be returned.")] = None,
        pagination_token: Annotated[Optional[Annotated[str, Field(min_length=1, strict=True)]], Field(description="This parameter is used to get a specified 'page' of results.")] = None,
        exclude: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="The set of entities to exclude (e.g. 'replies' or 'retweets').")] = None,
        tweet_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of Tweet fields to display.")] = None,
        expansions: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of fields to expand.")] = None,
        media_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of Media fields to display.")] = None,
        poll_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of Poll fields to display.")] = None,
        user_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of User fields to display.")] = None,
        place_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of Place fields to display.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> Get2TweetsIdQuoteTweetsResponse:
        """Retrieve Tweets that quote a Tweet.

        Returns a variety of information about each Tweet that quotes the Tweet specified by the requested ID.

        :param id: A single Tweet ID. (required)
        :type id: str
        :param max_results: The maximum number of results to be returned.
        :type max_results: int
        :param pagination_token: This parameter is used to get a specified 'page' of results.
        :type pagination_token: str
        :param exclude: The set of entities to exclude (e.g. 'replies' or 'retweets').
        :type exclude: List[str]
        :param tweet_fields: A comma separated list of Tweet fields to display.
        :type tweet_fields: List[str]
        :param expansions: A comma separated list of fields to expand.
        :type expansions: List[str]
        :param media_fields: A comma separated list of Media fields to display.
        :type media_fields: List[str]
        :param poll_fields: A comma separated list of Poll fields to display.
        :type poll_fields: List[str]
        :param user_fields: A comma separated list of User fields to display.
        :type user_fields: List[str]
        :param place_fields: A comma separated list of Place fields to display.
        :type place_fields: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._find_tweets_that_quote_a_tweet_serialize(
            id=id,
            max_results=max_results,
            pagination_token=pagination_token,
            exclude=exclude,
            tweet_fields=tweet_fields,
            expansions=expansions,
            media_fields=media_fields,
            poll_fields=poll_fields,
            user_fields=user_fields,
            place_fields=place_fields,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Get2TweetsIdQuoteTweetsResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def find_tweets_that_quote_a_tweet_with_http_info(
        self,
        id: Annotated[str, Field(strict=True, description="A single Tweet ID.")],
        max_results: Annotated[Optional[Annotated[int, Field(le=100, strict=True, ge=10)]], Field(description="The maximum number of results to be returned.")] = None,
        pagination_token: Annotated[Optional[Annotated[str, Field(min_length=1, strict=True)]], Field(description="This parameter is used to get a specified 'page' of results.")] = None,
        exclude: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="The set of entities to exclude (e.g. 'replies' or 'retweets').")] = None,
        tweet_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of Tweet fields to display.")] = None,
        expansions: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of fields to expand.")] = None,
        media_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of Media fields to display.")] = None,
        poll_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of Poll fields to display.")] = None,
        user_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of User fields to display.")] = None,
        place_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of Place fields to display.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[Get2TweetsIdQuoteTweetsResponse]:
        """Retrieve Tweets that quote a Tweet.

        Returns a variety of information about each Tweet that quotes the Tweet specified by the requested ID.

        :param id: A single Tweet ID. (required)
        :type id: str
        :param max_results: The maximum number of results to be returned.
        :type max_results: int
        :param pagination_token: This parameter is used to get a specified 'page' of results.
        :type pagination_token: str
        :param exclude: The set of entities to exclude (e.g. 'replies' or 'retweets').
        :type exclude: List[str]
        :param tweet_fields: A comma separated list of Tweet fields to display.
        :type tweet_fields: List[str]
        :param expansions: A comma separated list of fields to expand.
        :type expansions: List[str]
        :param media_fields: A comma separated list of Media fields to display.
        :type media_fields: List[str]
        :param poll_fields: A comma separated list of Poll fields to display.
        :type poll_fields: List[str]
        :param user_fields: A comma separated list of User fields to display.
        :type user_fields: List[str]
        :param place_fields: A comma separated list of Place fields to display.
        :type place_fields: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._find_tweets_that_quote_a_tweet_serialize(
            id=id,
            max_results=max_results,
            pagination_token=pagination_token,
            exclude=exclude,
            tweet_fields=tweet_fields,
            expansions=expansions,
            media_fields=media_fields,
            poll_fields=poll_fields,
            user_fields=user_fields,
            place_fields=place_fields,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Get2TweetsIdQuoteTweetsResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def find_tweets_that_quote_a_tweet_without_preload_content(
        self,
        id: Annotated[str, Field(strict=True, description="A single Tweet ID.")],
        max_results: Annotated[Optional[Annotated[int, Field(le=100, strict=True, ge=10)]], Field(description="The maximum number of results to be returned.")] = None,
        pagination_token: Annotated[Optional[Annotated[str, Field(min_length=1, strict=True)]], Field(description="This parameter is used to get a specified 'page' of results.")] = None,
        exclude: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="The set of entities to exclude (e.g. 'replies' or 'retweets').")] = None,
        tweet_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of Tweet fields to display.")] = None,
        expansions: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of fields to expand.")] = None,
        media_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of Media fields to display.")] = None,
        poll_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of Poll fields to display.")] = None,
        user_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of User fields to display.")] = None,
        place_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of Place fields to display.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Retrieve Tweets that quote a Tweet.

        Returns a variety of information about each Tweet that quotes the Tweet specified by the requested ID.

        :param id: A single Tweet ID. (required)
        :type id: str
        :param max_results: The maximum number of results to be returned.
        :type max_results: int
        :param pagination_token: This parameter is used to get a specified 'page' of results.
        :type pagination_token: str
        :param exclude: The set of entities to exclude (e.g. 'replies' or 'retweets').
        :type exclude: List[str]
        :param tweet_fields: A comma separated list of Tweet fields to display.
        :type tweet_fields: List[str]
        :param expansions: A comma separated list of fields to expand.
        :type expansions: List[str]
        :param media_fields: A comma separated list of Media fields to display.
        :type media_fields: List[str]
        :param poll_fields: A comma separated list of Poll fields to display.
        :type poll_fields: List[str]
        :param user_fields: A comma separated list of User fields to display.
        :type user_fields: List[str]
        :param place_fields: A comma separated list of Place fields to display.
        :type place_fields: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._find_tweets_that_quote_a_tweet_serialize(
            id=id,
            max_results=max_results,
            pagination_token=pagination_token,
            exclude=exclude,
            tweet_fields=tweet_fields,
            expansions=expansions,
            media_fields=media_fields,
            poll_fields=poll_fields,
            user_fields=user_fields,
            place_fields=place_fields,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Get2TweetsIdQuoteTweetsResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _find_tweets_that_quote_a_tweet_serialize(
        self,
        id,
        max_results,
        pagination_token,
        exclude,
        tweet_fields,
        expansions,
        media_fields,
        poll_fields,
        user_fields,
        place_fields,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'exclude': 'csv',
            'tweet.fields': 'csv',
            'expansions': 'csv',
            'media.fields': 'csv',
            'poll.fields': 'csv',
            'user.fields': 'csv',
            'place.fields': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        if max_results is not None:
            
            _query_params.append(('max_results', max_results))
            
        if pagination_token is not None:
            
            _query_params.append(('pagination_token', pagination_token))
            
        if exclude is not None:
            
            _query_params.append(('exclude', exclude))
            
        if tweet_fields is not None:
            
            _query_params.append(('tweet.fields', tweet_fields))
            
        if expansions is not None:
            
            _query_params.append(('expansions', expansions))
            
        if media_fields is not None:
            
            _query_params.append(('media.fields', media_fields))
            
        if poll_fields is not None:
            
            _query_params.append(('poll.fields', poll_fields))
            
        if user_fields is not None:
            
            _query_params.append(('user.fields', user_fields))
            
        if place_fields is not None:
            
            _query_params.append(('place.fields', place_fields))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json', 
                    'application/problem+json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'OAuth2UserToken', 
            'BearerToken', 
            'UserToken'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/2/tweets/{id}/quote_tweets',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_rules(
        self,
        ids: Annotated[Optional[List[Annotated[str, Field(strict=True)]]], Field(description="A comma-separated list of Rule IDs.")] = None,
        max_results: Annotated[Optional[Annotated[int, Field(le=1000, strict=True, ge=1)]], Field(description="The maximum number of results.")] = None,
        pagination_token: Annotated[Optional[Annotated[str, Field(min_length=16, strict=True, max_length=16)]], Field(description="This value is populated by passing the 'next_token' returned in a request to paginate through results.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RulesLookupResponse:
        """Rules lookup

        Returns rules from a User's active rule set. Users can fetch all of their rules or a subset, specified by the provided rule ids.

        :param ids: A comma-separated list of Rule IDs.
        :type ids: List[str]
        :param max_results: The maximum number of results.
        :type max_results: int
        :param pagination_token: This value is populated by passing the 'next_token' returned in a request to paginate through results.
        :type pagination_token: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_rules_serialize(
            ids=ids,
            max_results=max_results,
            pagination_token=pagination_token,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "RulesLookupResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_rules_with_http_info(
        self,
        ids: Annotated[Optional[List[Annotated[str, Field(strict=True)]]], Field(description="A comma-separated list of Rule IDs.")] = None,
        max_results: Annotated[Optional[Annotated[int, Field(le=1000, strict=True, ge=1)]], Field(description="The maximum number of results.")] = None,
        pagination_token: Annotated[Optional[Annotated[str, Field(min_length=16, strict=True, max_length=16)]], Field(description="This value is populated by passing the 'next_token' returned in a request to paginate through results.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[RulesLookupResponse]:
        """Rules lookup

        Returns rules from a User's active rule set. Users can fetch all of their rules or a subset, specified by the provided rule ids.

        :param ids: A comma-separated list of Rule IDs.
        :type ids: List[str]
        :param max_results: The maximum number of results.
        :type max_results: int
        :param pagination_token: This value is populated by passing the 'next_token' returned in a request to paginate through results.
        :type pagination_token: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_rules_serialize(
            ids=ids,
            max_results=max_results,
            pagination_token=pagination_token,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "RulesLookupResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_rules_without_preload_content(
        self,
        ids: Annotated[Optional[List[Annotated[str, Field(strict=True)]]], Field(description="A comma-separated list of Rule IDs.")] = None,
        max_results: Annotated[Optional[Annotated[int, Field(le=1000, strict=True, ge=1)]], Field(description="The maximum number of results.")] = None,
        pagination_token: Annotated[Optional[Annotated[str, Field(min_length=16, strict=True, max_length=16)]], Field(description="This value is populated by passing the 'next_token' returned in a request to paginate through results.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Rules lookup

        Returns rules from a User's active rule set. Users can fetch all of their rules or a subset, specified by the provided rule ids.

        :param ids: A comma-separated list of Rule IDs.
        :type ids: List[str]
        :param max_results: The maximum number of results.
        :type max_results: int
        :param pagination_token: This value is populated by passing the 'next_token' returned in a request to paginate through results.
        :type pagination_token: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_rules_serialize(
            ids=ids,
            max_results=max_results,
            pagination_token=pagination_token,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "RulesLookupResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_rules_serialize(
        self,
        ids,
        max_results,
        pagination_token,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'ids': 'multi',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if ids is not None:
            
            _query_params.append(('ids', ids))
            
        if max_results is not None:
            
            _query_params.append(('max_results', max_results))
            
        if pagination_token is not None:
            
            _query_params.append(('pagination_token', pagination_token))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json', 
                    'application/problem+json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'BearerToken'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/2/tweets/search/stream/rules',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_tweets_firehose_stream(
        self,
        partition: Annotated[int, Field(le=20, strict=True, ge=1, description="The partition number.")],
        backfill_minutes: Annotated[Optional[Annotated[int, Field(le=5, strict=True, ge=0)]], Field(description="The number of minutes of backfill requested.")] = None,
        start_time: Annotated[Optional[datetime], Field(description="YYYY-MM-DDTHH:mm:ssZ. The earliest UTC timestamp to which the Tweets will be provided.")] = None,
        end_time: Annotated[Optional[datetime], Field(description="YYYY-MM-DDTHH:mm:ssZ. The latest UTC timestamp to which the Tweets will be provided.")] = None,
        tweet_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of Tweet fields to display.")] = None,
        expansions: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of fields to expand.")] = None,
        media_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of Media fields to display.")] = None,
        poll_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of Poll fields to display.")] = None,
        user_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of User fields to display.")] = None,
        place_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of Place fields to display.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> StreamingTweetResponse:
        """Firehose stream

        Streams 100% of public Tweets.

        :param partition: The partition number. (required)
        :type partition: int
        :param backfill_minutes: The number of minutes of backfill requested.
        :type backfill_minutes: int
        :param start_time: YYYY-MM-DDTHH:mm:ssZ. The earliest UTC timestamp to which the Tweets will be provided.
        :type start_time: datetime
        :param end_time: YYYY-MM-DDTHH:mm:ssZ. The latest UTC timestamp to which the Tweets will be provided.
        :type end_time: datetime
        :param tweet_fields: A comma separated list of Tweet fields to display.
        :type tweet_fields: List[str]
        :param expansions: A comma separated list of fields to expand.
        :type expansions: List[str]
        :param media_fields: A comma separated list of Media fields to display.
        :type media_fields: List[str]
        :param poll_fields: A comma separated list of Poll fields to display.
        :type poll_fields: List[str]
        :param user_fields: A comma separated list of User fields to display.
        :type user_fields: List[str]
        :param place_fields: A comma separated list of Place fields to display.
        :type place_fields: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_tweets_firehose_stream_serialize(
            partition=partition,
            backfill_minutes=backfill_minutes,
            start_time=start_time,
            end_time=end_time,
            tweet_fields=tweet_fields,
            expansions=expansions,
            media_fields=media_fields,
            poll_fields=poll_fields,
            user_fields=user_fields,
            place_fields=place_fields,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "StreamingTweetResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_tweets_firehose_stream_with_http_info(
        self,
        partition: Annotated[int, Field(le=20, strict=True, ge=1, description="The partition number.")],
        backfill_minutes: Annotated[Optional[Annotated[int, Field(le=5, strict=True, ge=0)]], Field(description="The number of minutes of backfill requested.")] = None,
        start_time: Annotated[Optional[datetime], Field(description="YYYY-MM-DDTHH:mm:ssZ. The earliest UTC timestamp to which the Tweets will be provided.")] = None,
        end_time: Annotated[Optional[datetime], Field(description="YYYY-MM-DDTHH:mm:ssZ. The latest UTC timestamp to which the Tweets will be provided.")] = None,
        tweet_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of Tweet fields to display.")] = None,
        expansions: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of fields to expand.")] = None,
        media_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of Media fields to display.")] = None,
        poll_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of Poll fields to display.")] = None,
        user_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of User fields to display.")] = None,
        place_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of Place fields to display.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[StreamingTweetResponse]:
        """Firehose stream

        Streams 100% of public Tweets.

        :param partition: The partition number. (required)
        :type partition: int
        :param backfill_minutes: The number of minutes of backfill requested.
        :type backfill_minutes: int
        :param start_time: YYYY-MM-DDTHH:mm:ssZ. The earliest UTC timestamp to which the Tweets will be provided.
        :type start_time: datetime
        :param end_time: YYYY-MM-DDTHH:mm:ssZ. The latest UTC timestamp to which the Tweets will be provided.
        :type end_time: datetime
        :param tweet_fields: A comma separated list of Tweet fields to display.
        :type tweet_fields: List[str]
        :param expansions: A comma separated list of fields to expand.
        :type expansions: List[str]
        :param media_fields: A comma separated list of Media fields to display.
        :type media_fields: List[str]
        :param poll_fields: A comma separated list of Poll fields to display.
        :type poll_fields: List[str]
        :param user_fields: A comma separated list of User fields to display.
        :type user_fields: List[str]
        :param place_fields: A comma separated list of Place fields to display.
        :type place_fields: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_tweets_firehose_stream_serialize(
            partition=partition,
            backfill_minutes=backfill_minutes,
            start_time=start_time,
            end_time=end_time,
            tweet_fields=tweet_fields,
            expansions=expansions,
            media_fields=media_fields,
            poll_fields=poll_fields,
            user_fields=user_fields,
            place_fields=place_fields,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "StreamingTweetResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_tweets_firehose_stream_without_preload_content(
        self,
        partition: Annotated[int, Field(le=20, strict=True, ge=1, description="The partition number.")],
        backfill_minutes: Annotated[Optional[Annotated[int, Field(le=5, strict=True, ge=0)]], Field(description="The number of minutes of backfill requested.")] = None,
        start_time: Annotated[Optional[datetime], Field(description="YYYY-MM-DDTHH:mm:ssZ. The earliest UTC timestamp to which the Tweets will be provided.")] = None,
        end_time: Annotated[Optional[datetime], Field(description="YYYY-MM-DDTHH:mm:ssZ. The latest UTC timestamp to which the Tweets will be provided.")] = None,
        tweet_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of Tweet fields to display.")] = None,
        expansions: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of fields to expand.")] = None,
        media_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of Media fields to display.")] = None,
        poll_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of Poll fields to display.")] = None,
        user_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of User fields to display.")] = None,
        place_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of Place fields to display.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Firehose stream

        Streams 100% of public Tweets.

        :param partition: The partition number. (required)
        :type partition: int
        :param backfill_minutes: The number of minutes of backfill requested.
        :type backfill_minutes: int
        :param start_time: YYYY-MM-DDTHH:mm:ssZ. The earliest UTC timestamp to which the Tweets will be provided.
        :type start_time: datetime
        :param end_time: YYYY-MM-DDTHH:mm:ssZ. The latest UTC timestamp to which the Tweets will be provided.
        :type end_time: datetime
        :param tweet_fields: A comma separated list of Tweet fields to display.
        :type tweet_fields: List[str]
        :param expansions: A comma separated list of fields to expand.
        :type expansions: List[str]
        :param media_fields: A comma separated list of Media fields to display.
        :type media_fields: List[str]
        :param poll_fields: A comma separated list of Poll fields to display.
        :type poll_fields: List[str]
        :param user_fields: A comma separated list of User fields to display.
        :type user_fields: List[str]
        :param place_fields: A comma separated list of Place fields to display.
        :type place_fields: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_tweets_firehose_stream_serialize(
            partition=partition,
            backfill_minutes=backfill_minutes,
            start_time=start_time,
            end_time=end_time,
            tweet_fields=tweet_fields,
            expansions=expansions,
            media_fields=media_fields,
            poll_fields=poll_fields,
            user_fields=user_fields,
            place_fields=place_fields,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "StreamingTweetResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_tweets_firehose_stream_serialize(
        self,
        partition,
        backfill_minutes,
        start_time,
        end_time,
        tweet_fields,
        expansions,
        media_fields,
        poll_fields,
        user_fields,
        place_fields,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'tweet.fields': 'csv',
            'expansions': 'csv',
            'media.fields': 'csv',
            'poll.fields': 'csv',
            'user.fields': 'csv',
            'place.fields': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if backfill_minutes is not None:
            
            _query_params.append(('backfill_minutes', backfill_minutes))
            
        if partition is not None:
            
            _query_params.append(('partition', partition))
            
        if start_time is not None:
            if isinstance(start_time, datetime):
                _query_params.append(
                    (
                        'start_time',
                        start_time.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('start_time', start_time))
            
        if end_time is not None:
            if isinstance(end_time, datetime):
                _query_params.append(
                    (
                        'end_time',
                        end_time.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('end_time', end_time))
            
        if tweet_fields is not None:
            
            _query_params.append(('tweet.fields', tweet_fields))
            
        if expansions is not None:
            
            _query_params.append(('expansions', expansions))
            
        if media_fields is not None:
            
            _query_params.append(('media.fields', media_fields))
            
        if poll_fields is not None:
            
            _query_params.append(('poll.fields', poll_fields))
            
        if user_fields is not None:
            
            _query_params.append(('user.fields', user_fields))
            
        if place_fields is not None:
            
            _query_params.append(('place.fields', place_fields))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json', 
                    'application/problem+json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'BearerToken'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/2/tweets/firehose/stream',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_tweets_sample10_stream(
        self,
        partition: Annotated[int, Field(le=2, strict=True, ge=1, description="The partition number.")],
        backfill_minutes: Annotated[Optional[Annotated[int, Field(le=5, strict=True, ge=0)]], Field(description="The number of minutes of backfill requested.")] = None,
        start_time: Annotated[Optional[datetime], Field(description="YYYY-MM-DDTHH:mm:ssZ. The earliest UTC timestamp to which the Tweets will be provided.")] = None,
        end_time: Annotated[Optional[datetime], Field(description="YYYY-MM-DDTHH:mm:ssZ. The latest UTC timestamp to which the Tweets will be provided.")] = None,
        tweet_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of Tweet fields to display.")] = None,
        expansions: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of fields to expand.")] = None,
        media_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of Media fields to display.")] = None,
        poll_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of Poll fields to display.")] = None,
        user_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of User fields to display.")] = None,
        place_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of Place fields to display.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> Get2TweetsSample10StreamResponse:
        """Sample 10% stream

        Streams a deterministic 10% of public Tweets.

        :param partition: The partition number. (required)
        :type partition: int
        :param backfill_minutes: The number of minutes of backfill requested.
        :type backfill_minutes: int
        :param start_time: YYYY-MM-DDTHH:mm:ssZ. The earliest UTC timestamp to which the Tweets will be provided.
        :type start_time: datetime
        :param end_time: YYYY-MM-DDTHH:mm:ssZ. The latest UTC timestamp to which the Tweets will be provided.
        :type end_time: datetime
        :param tweet_fields: A comma separated list of Tweet fields to display.
        :type tweet_fields: List[str]
        :param expansions: A comma separated list of fields to expand.
        :type expansions: List[str]
        :param media_fields: A comma separated list of Media fields to display.
        :type media_fields: List[str]
        :param poll_fields: A comma separated list of Poll fields to display.
        :type poll_fields: List[str]
        :param user_fields: A comma separated list of User fields to display.
        :type user_fields: List[str]
        :param place_fields: A comma separated list of Place fields to display.
        :type place_fields: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_tweets_sample10_stream_serialize(
            partition=partition,
            backfill_minutes=backfill_minutes,
            start_time=start_time,
            end_time=end_time,
            tweet_fields=tweet_fields,
            expansions=expansions,
            media_fields=media_fields,
            poll_fields=poll_fields,
            user_fields=user_fields,
            place_fields=place_fields,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Get2TweetsSample10StreamResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_tweets_sample10_stream_with_http_info(
        self,
        partition: Annotated[int, Field(le=2, strict=True, ge=1, description="The partition number.")],
        backfill_minutes: Annotated[Optional[Annotated[int, Field(le=5, strict=True, ge=0)]], Field(description="The number of minutes of backfill requested.")] = None,
        start_time: Annotated[Optional[datetime], Field(description="YYYY-MM-DDTHH:mm:ssZ. The earliest UTC timestamp to which the Tweets will be provided.")] = None,
        end_time: Annotated[Optional[datetime], Field(description="YYYY-MM-DDTHH:mm:ssZ. The latest UTC timestamp to which the Tweets will be provided.")] = None,
        tweet_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of Tweet fields to display.")] = None,
        expansions: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of fields to expand.")] = None,
        media_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of Media fields to display.")] = None,
        poll_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of Poll fields to display.")] = None,
        user_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of User fields to display.")] = None,
        place_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of Place fields to display.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[Get2TweetsSample10StreamResponse]:
        """Sample 10% stream

        Streams a deterministic 10% of public Tweets.

        :param partition: The partition number. (required)
        :type partition: int
        :param backfill_minutes: The number of minutes of backfill requested.
        :type backfill_minutes: int
        :param start_time: YYYY-MM-DDTHH:mm:ssZ. The earliest UTC timestamp to which the Tweets will be provided.
        :type start_time: datetime
        :param end_time: YYYY-MM-DDTHH:mm:ssZ. The latest UTC timestamp to which the Tweets will be provided.
        :type end_time: datetime
        :param tweet_fields: A comma separated list of Tweet fields to display.
        :type tweet_fields: List[str]
        :param expansions: A comma separated list of fields to expand.
        :type expansions: List[str]
        :param media_fields: A comma separated list of Media fields to display.
        :type media_fields: List[str]
        :param poll_fields: A comma separated list of Poll fields to display.
        :type poll_fields: List[str]
        :param user_fields: A comma separated list of User fields to display.
        :type user_fields: List[str]
        :param place_fields: A comma separated list of Place fields to display.
        :type place_fields: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_tweets_sample10_stream_serialize(
            partition=partition,
            backfill_minutes=backfill_minutes,
            start_time=start_time,
            end_time=end_time,
            tweet_fields=tweet_fields,
            expansions=expansions,
            media_fields=media_fields,
            poll_fields=poll_fields,
            user_fields=user_fields,
            place_fields=place_fields,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Get2TweetsSample10StreamResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_tweets_sample10_stream_without_preload_content(
        self,
        partition: Annotated[int, Field(le=2, strict=True, ge=1, description="The partition number.")],
        backfill_minutes: Annotated[Optional[Annotated[int, Field(le=5, strict=True, ge=0)]], Field(description="The number of minutes of backfill requested.")] = None,
        start_time: Annotated[Optional[datetime], Field(description="YYYY-MM-DDTHH:mm:ssZ. The earliest UTC timestamp to which the Tweets will be provided.")] = None,
        end_time: Annotated[Optional[datetime], Field(description="YYYY-MM-DDTHH:mm:ssZ. The latest UTC timestamp to which the Tweets will be provided.")] = None,
        tweet_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of Tweet fields to display.")] = None,
        expansions: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of fields to expand.")] = None,
        media_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of Media fields to display.")] = None,
        poll_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of Poll fields to display.")] = None,
        user_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of User fields to display.")] = None,
        place_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of Place fields to display.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Sample 10% stream

        Streams a deterministic 10% of public Tweets.

        :param partition: The partition number. (required)
        :type partition: int
        :param backfill_minutes: The number of minutes of backfill requested.
        :type backfill_minutes: int
        :param start_time: YYYY-MM-DDTHH:mm:ssZ. The earliest UTC timestamp to which the Tweets will be provided.
        :type start_time: datetime
        :param end_time: YYYY-MM-DDTHH:mm:ssZ. The latest UTC timestamp to which the Tweets will be provided.
        :type end_time: datetime
        :param tweet_fields: A comma separated list of Tweet fields to display.
        :type tweet_fields: List[str]
        :param expansions: A comma separated list of fields to expand.
        :type expansions: List[str]
        :param media_fields: A comma separated list of Media fields to display.
        :type media_fields: List[str]
        :param poll_fields: A comma separated list of Poll fields to display.
        :type poll_fields: List[str]
        :param user_fields: A comma separated list of User fields to display.
        :type user_fields: List[str]
        :param place_fields: A comma separated list of Place fields to display.
        :type place_fields: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_tweets_sample10_stream_serialize(
            partition=partition,
            backfill_minutes=backfill_minutes,
            start_time=start_time,
            end_time=end_time,
            tweet_fields=tweet_fields,
            expansions=expansions,
            media_fields=media_fields,
            poll_fields=poll_fields,
            user_fields=user_fields,
            place_fields=place_fields,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Get2TweetsSample10StreamResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_tweets_sample10_stream_serialize(
        self,
        partition,
        backfill_minutes,
        start_time,
        end_time,
        tweet_fields,
        expansions,
        media_fields,
        poll_fields,
        user_fields,
        place_fields,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'tweet.fields': 'csv',
            'expansions': 'csv',
            'media.fields': 'csv',
            'poll.fields': 'csv',
            'user.fields': 'csv',
            'place.fields': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if backfill_minutes is not None:
            
            _query_params.append(('backfill_minutes', backfill_minutes))
            
        if partition is not None:
            
            _query_params.append(('partition', partition))
            
        if start_time is not None:
            if isinstance(start_time, datetime):
                _query_params.append(
                    (
                        'start_time',
                        start_time.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('start_time', start_time))
            
        if end_time is not None:
            if isinstance(end_time, datetime):
                _query_params.append(
                    (
                        'end_time',
                        end_time.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('end_time', end_time))
            
        if tweet_fields is not None:
            
            _query_params.append(('tweet.fields', tweet_fields))
            
        if expansions is not None:
            
            _query_params.append(('expansions', expansions))
            
        if media_fields is not None:
            
            _query_params.append(('media.fields', media_fields))
            
        if poll_fields is not None:
            
            _query_params.append(('poll.fields', poll_fields))
            
        if user_fields is not None:
            
            _query_params.append(('user.fields', user_fields))
            
        if place_fields is not None:
            
            _query_params.append(('place.fields', place_fields))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json', 
                    'application/problem+json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'BearerToken'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/2/tweets/sample10/stream',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def hide_reply_by_id(
        self,
        tweet_id: Annotated[str, Field(strict=True, description="The ID of the reply that you want to hide or unhide.")],
        tweet_hide_request: Optional[TweetHideRequest] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> TweetHideResponse:
        """Hide replies

        Hides or unhides a reply to an owned conversation.

        :param tweet_id: The ID of the reply that you want to hide or unhide. (required)
        :type tweet_id: str
        :param tweet_hide_request:
        :type tweet_hide_request: TweetHideRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._hide_reply_by_id_serialize(
            tweet_id=tweet_id,
            tweet_hide_request=tweet_hide_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TweetHideResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def hide_reply_by_id_with_http_info(
        self,
        tweet_id: Annotated[str, Field(strict=True, description="The ID of the reply that you want to hide or unhide.")],
        tweet_hide_request: Optional[TweetHideRequest] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[TweetHideResponse]:
        """Hide replies

        Hides or unhides a reply to an owned conversation.

        :param tweet_id: The ID of the reply that you want to hide or unhide. (required)
        :type tweet_id: str
        :param tweet_hide_request:
        :type tweet_hide_request: TweetHideRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._hide_reply_by_id_serialize(
            tweet_id=tweet_id,
            tweet_hide_request=tweet_hide_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TweetHideResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def hide_reply_by_id_without_preload_content(
        self,
        tweet_id: Annotated[str, Field(strict=True, description="The ID of the reply that you want to hide or unhide.")],
        tweet_hide_request: Optional[TweetHideRequest] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Hide replies

        Hides or unhides a reply to an owned conversation.

        :param tweet_id: The ID of the reply that you want to hide or unhide. (required)
        :type tweet_id: str
        :param tweet_hide_request:
        :type tweet_hide_request: TweetHideRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._hide_reply_by_id_serialize(
            tweet_id=tweet_id,
            tweet_hide_request=tweet_hide_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TweetHideResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _hide_reply_by_id_serialize(
        self,
        tweet_id,
        tweet_hide_request,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if tweet_id is not None:
            _path_params['tweet_id'] = tweet_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if tweet_hide_request is not None:
            _body_params = tweet_hide_request


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json', 
                    'application/problem+json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'OAuth2UserToken', 
            'UserToken'
        ]

        return self.api_client.param_serialize(
            method='PUT',
            resource_path='/2/tweets/{tweet_id}/hidden',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def lists_id_tweets(
        self,
        id: Annotated[str, Field(strict=True, description="The ID of the List.")],
        max_results: Annotated[Optional[Annotated[int, Field(le=100, strict=True, ge=1)]], Field(description="The maximum number of results.")] = None,
        pagination_token: Annotated[Optional[Annotated[str, Field(min_length=1, strict=True)]], Field(description="This parameter is used to get the next 'page' of results.")] = None,
        tweet_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of Tweet fields to display.")] = None,
        expansions: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of fields to expand.")] = None,
        media_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of Media fields to display.")] = None,
        poll_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of Poll fields to display.")] = None,
        user_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of User fields to display.")] = None,
        place_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of Place fields to display.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> Get2ListsIdTweetsResponse:
        """List Tweets timeline by List ID.

        Returns a list of Tweets associated with the provided List ID.

        :param id: The ID of the List. (required)
        :type id: str
        :param max_results: The maximum number of results.
        :type max_results: int
        :param pagination_token: This parameter is used to get the next 'page' of results.
        :type pagination_token: str
        :param tweet_fields: A comma separated list of Tweet fields to display.
        :type tweet_fields: List[str]
        :param expansions: A comma separated list of fields to expand.
        :type expansions: List[str]
        :param media_fields: A comma separated list of Media fields to display.
        :type media_fields: List[str]
        :param poll_fields: A comma separated list of Poll fields to display.
        :type poll_fields: List[str]
        :param user_fields: A comma separated list of User fields to display.
        :type user_fields: List[str]
        :param place_fields: A comma separated list of Place fields to display.
        :type place_fields: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._lists_id_tweets_serialize(
            id=id,
            max_results=max_results,
            pagination_token=pagination_token,
            tweet_fields=tweet_fields,
            expansions=expansions,
            media_fields=media_fields,
            poll_fields=poll_fields,
            user_fields=user_fields,
            place_fields=place_fields,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Get2ListsIdTweetsResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def lists_id_tweets_with_http_info(
        self,
        id: Annotated[str, Field(strict=True, description="The ID of the List.")],
        max_results: Annotated[Optional[Annotated[int, Field(le=100, strict=True, ge=1)]], Field(description="The maximum number of results.")] = None,
        pagination_token: Annotated[Optional[Annotated[str, Field(min_length=1, strict=True)]], Field(description="This parameter is used to get the next 'page' of results.")] = None,
        tweet_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of Tweet fields to display.")] = None,
        expansions: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of fields to expand.")] = None,
        media_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of Media fields to display.")] = None,
        poll_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of Poll fields to display.")] = None,
        user_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of User fields to display.")] = None,
        place_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of Place fields to display.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[Get2ListsIdTweetsResponse]:
        """List Tweets timeline by List ID.

        Returns a list of Tweets associated with the provided List ID.

        :param id: The ID of the List. (required)
        :type id: str
        :param max_results: The maximum number of results.
        :type max_results: int
        :param pagination_token: This parameter is used to get the next 'page' of results.
        :type pagination_token: str
        :param tweet_fields: A comma separated list of Tweet fields to display.
        :type tweet_fields: List[str]
        :param expansions: A comma separated list of fields to expand.
        :type expansions: List[str]
        :param media_fields: A comma separated list of Media fields to display.
        :type media_fields: List[str]
        :param poll_fields: A comma separated list of Poll fields to display.
        :type poll_fields: List[str]
        :param user_fields: A comma separated list of User fields to display.
        :type user_fields: List[str]
        :param place_fields: A comma separated list of Place fields to display.
        :type place_fields: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._lists_id_tweets_serialize(
            id=id,
            max_results=max_results,
            pagination_token=pagination_token,
            tweet_fields=tweet_fields,
            expansions=expansions,
            media_fields=media_fields,
            poll_fields=poll_fields,
            user_fields=user_fields,
            place_fields=place_fields,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Get2ListsIdTweetsResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def lists_id_tweets_without_preload_content(
        self,
        id: Annotated[str, Field(strict=True, description="The ID of the List.")],
        max_results: Annotated[Optional[Annotated[int, Field(le=100, strict=True, ge=1)]], Field(description="The maximum number of results.")] = None,
        pagination_token: Annotated[Optional[Annotated[str, Field(min_length=1, strict=True)]], Field(description="This parameter is used to get the next 'page' of results.")] = None,
        tweet_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of Tweet fields to display.")] = None,
        expansions: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of fields to expand.")] = None,
        media_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of Media fields to display.")] = None,
        poll_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of Poll fields to display.")] = None,
        user_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of User fields to display.")] = None,
        place_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of Place fields to display.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """List Tweets timeline by List ID.

        Returns a list of Tweets associated with the provided List ID.

        :param id: The ID of the List. (required)
        :type id: str
        :param max_results: The maximum number of results.
        :type max_results: int
        :param pagination_token: This parameter is used to get the next 'page' of results.
        :type pagination_token: str
        :param tweet_fields: A comma separated list of Tweet fields to display.
        :type tweet_fields: List[str]
        :param expansions: A comma separated list of fields to expand.
        :type expansions: List[str]
        :param media_fields: A comma separated list of Media fields to display.
        :type media_fields: List[str]
        :param poll_fields: A comma separated list of Poll fields to display.
        :type poll_fields: List[str]
        :param user_fields: A comma separated list of User fields to display.
        :type user_fields: List[str]
        :param place_fields: A comma separated list of Place fields to display.
        :type place_fields: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._lists_id_tweets_serialize(
            id=id,
            max_results=max_results,
            pagination_token=pagination_token,
            tweet_fields=tweet_fields,
            expansions=expansions,
            media_fields=media_fields,
            poll_fields=poll_fields,
            user_fields=user_fields,
            place_fields=place_fields,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Get2ListsIdTweetsResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _lists_id_tweets_serialize(
        self,
        id,
        max_results,
        pagination_token,
        tweet_fields,
        expansions,
        media_fields,
        poll_fields,
        user_fields,
        place_fields,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'tweet.fields': 'csv',
            'expansions': 'csv',
            'media.fields': 'csv',
            'poll.fields': 'csv',
            'user.fields': 'csv',
            'place.fields': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        if max_results is not None:
            
            _query_params.append(('max_results', max_results))
            
        if pagination_token is not None:
            
            _query_params.append(('pagination_token', pagination_token))
            
        if tweet_fields is not None:
            
            _query_params.append(('tweet.fields', tweet_fields))
            
        if expansions is not None:
            
            _query_params.append(('expansions', expansions))
            
        if media_fields is not None:
            
            _query_params.append(('media.fields', media_fields))
            
        if poll_fields is not None:
            
            _query_params.append(('poll.fields', poll_fields))
            
        if user_fields is not None:
            
            _query_params.append(('user.fields', user_fields))
            
        if place_fields is not None:
            
            _query_params.append(('place.fields', place_fields))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json', 
                    'application/problem+json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'OAuth2UserToken', 
            'BearerToken', 
            'UserToken'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/2/lists/{id}/tweets',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def sample_stream(
        self,
        backfill_minutes: Annotated[Optional[Annotated[int, Field(le=5, strict=True, ge=0)]], Field(description="The number of minutes of backfill requested.")] = None,
        tweet_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of Tweet fields to display.")] = None,
        expansions: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of fields to expand.")] = None,
        media_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of Media fields to display.")] = None,
        poll_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of Poll fields to display.")] = None,
        user_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of User fields to display.")] = None,
        place_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of Place fields to display.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> StreamingTweetResponse:
        """Sample stream

        Streams a deterministic 1% of public Tweets.

        :param backfill_minutes: The number of minutes of backfill requested.
        :type backfill_minutes: int
        :param tweet_fields: A comma separated list of Tweet fields to display.
        :type tweet_fields: List[str]
        :param expansions: A comma separated list of fields to expand.
        :type expansions: List[str]
        :param media_fields: A comma separated list of Media fields to display.
        :type media_fields: List[str]
        :param poll_fields: A comma separated list of Poll fields to display.
        :type poll_fields: List[str]
        :param user_fields: A comma separated list of User fields to display.
        :type user_fields: List[str]
        :param place_fields: A comma separated list of Place fields to display.
        :type place_fields: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._sample_stream_serialize(
            backfill_minutes=backfill_minutes,
            tweet_fields=tweet_fields,
            expansions=expansions,
            media_fields=media_fields,
            poll_fields=poll_fields,
            user_fields=user_fields,
            place_fields=place_fields,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "StreamingTweetResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def sample_stream_with_http_info(
        self,
        backfill_minutes: Annotated[Optional[Annotated[int, Field(le=5, strict=True, ge=0)]], Field(description="The number of minutes of backfill requested.")] = None,
        tweet_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of Tweet fields to display.")] = None,
        expansions: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of fields to expand.")] = None,
        media_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of Media fields to display.")] = None,
        poll_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of Poll fields to display.")] = None,
        user_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of User fields to display.")] = None,
        place_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of Place fields to display.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[StreamingTweetResponse]:
        """Sample stream

        Streams a deterministic 1% of public Tweets.

        :param backfill_minutes: The number of minutes of backfill requested.
        :type backfill_minutes: int
        :param tweet_fields: A comma separated list of Tweet fields to display.
        :type tweet_fields: List[str]
        :param expansions: A comma separated list of fields to expand.
        :type expansions: List[str]
        :param media_fields: A comma separated list of Media fields to display.
        :type media_fields: List[str]
        :param poll_fields: A comma separated list of Poll fields to display.
        :type poll_fields: List[str]
        :param user_fields: A comma separated list of User fields to display.
        :type user_fields: List[str]
        :param place_fields: A comma separated list of Place fields to display.
        :type place_fields: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._sample_stream_serialize(
            backfill_minutes=backfill_minutes,
            tweet_fields=tweet_fields,
            expansions=expansions,
            media_fields=media_fields,
            poll_fields=poll_fields,
            user_fields=user_fields,
            place_fields=place_fields,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "StreamingTweetResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def sample_stream_without_preload_content(
        self,
        backfill_minutes: Annotated[Optional[Annotated[int, Field(le=5, strict=True, ge=0)]], Field(description="The number of minutes of backfill requested.")] = None,
        tweet_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of Tweet fields to display.")] = None,
        expansions: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of fields to expand.")] = None,
        media_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of Media fields to display.")] = None,
        poll_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of Poll fields to display.")] = None,
        user_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of User fields to display.")] = None,
        place_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of Place fields to display.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Sample stream

        Streams a deterministic 1% of public Tweets.

        :param backfill_minutes: The number of minutes of backfill requested.
        :type backfill_minutes: int
        :param tweet_fields: A comma separated list of Tweet fields to display.
        :type tweet_fields: List[str]
        :param expansions: A comma separated list of fields to expand.
        :type expansions: List[str]
        :param media_fields: A comma separated list of Media fields to display.
        :type media_fields: List[str]
        :param poll_fields: A comma separated list of Poll fields to display.
        :type poll_fields: List[str]
        :param user_fields: A comma separated list of User fields to display.
        :type user_fields: List[str]
        :param place_fields: A comma separated list of Place fields to display.
        :type place_fields: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._sample_stream_serialize(
            backfill_minutes=backfill_minutes,
            tweet_fields=tweet_fields,
            expansions=expansions,
            media_fields=media_fields,
            poll_fields=poll_fields,
            user_fields=user_fields,
            place_fields=place_fields,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "StreamingTweetResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _sample_stream_serialize(
        self,
        backfill_minutes,
        tweet_fields,
        expansions,
        media_fields,
        poll_fields,
        user_fields,
        place_fields,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'tweet.fields': 'csv',
            'expansions': 'csv',
            'media.fields': 'csv',
            'poll.fields': 'csv',
            'user.fields': 'csv',
            'place.fields': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if backfill_minutes is not None:
            
            _query_params.append(('backfill_minutes', backfill_minutes))
            
        if tweet_fields is not None:
            
            _query_params.append(('tweet.fields', tweet_fields))
            
        if expansions is not None:
            
            _query_params.append(('expansions', expansions))
            
        if media_fields is not None:
            
            _query_params.append(('media.fields', media_fields))
            
        if poll_fields is not None:
            
            _query_params.append(('poll.fields', poll_fields))
            
        if user_fields is not None:
            
            _query_params.append(('user.fields', user_fields))
            
        if place_fields is not None:
            
            _query_params.append(('place.fields', place_fields))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json', 
                    'application/problem+json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'BearerToken'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/2/tweets/sample/stream',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def search_stream(
        self,
        backfill_minutes: Annotated[Optional[Annotated[int, Field(le=5, strict=True, ge=0)]], Field(description="The number of minutes of backfill requested.")] = None,
        start_time: Annotated[Optional[datetime], Field(description="YYYY-MM-DDTHH:mm:ssZ. The earliest UTC timestamp from which the Tweets will be provided.")] = None,
        end_time: Annotated[Optional[datetime], Field(description="YYYY-MM-DDTHH:mm:ssZ. The latest UTC timestamp to which the Tweets will be provided.")] = None,
        tweet_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of Tweet fields to display.")] = None,
        expansions: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of fields to expand.")] = None,
        media_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of Media fields to display.")] = None,
        poll_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of Poll fields to display.")] = None,
        user_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of User fields to display.")] = None,
        place_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of Place fields to display.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> FilteredStreamingTweetResponse:
        """Filtered stream

        Streams Tweets matching the stream's active rule set.

        :param backfill_minutes: The number of minutes of backfill requested.
        :type backfill_minutes: int
        :param start_time: YYYY-MM-DDTHH:mm:ssZ. The earliest UTC timestamp from which the Tweets will be provided.
        :type start_time: datetime
        :param end_time: YYYY-MM-DDTHH:mm:ssZ. The latest UTC timestamp to which the Tweets will be provided.
        :type end_time: datetime
        :param tweet_fields: A comma separated list of Tweet fields to display.
        :type tweet_fields: List[str]
        :param expansions: A comma separated list of fields to expand.
        :type expansions: List[str]
        :param media_fields: A comma separated list of Media fields to display.
        :type media_fields: List[str]
        :param poll_fields: A comma separated list of Poll fields to display.
        :type poll_fields: List[str]
        :param user_fields: A comma separated list of User fields to display.
        :type user_fields: List[str]
        :param place_fields: A comma separated list of Place fields to display.
        :type place_fields: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._search_stream_serialize(
            backfill_minutes=backfill_minutes,
            start_time=start_time,
            end_time=end_time,
            tweet_fields=tweet_fields,
            expansions=expansions,
            media_fields=media_fields,
            poll_fields=poll_fields,
            user_fields=user_fields,
            place_fields=place_fields,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FilteredStreamingTweetResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def search_stream_with_http_info(
        self,
        backfill_minutes: Annotated[Optional[Annotated[int, Field(le=5, strict=True, ge=0)]], Field(description="The number of minutes of backfill requested.")] = None,
        start_time: Annotated[Optional[datetime], Field(description="YYYY-MM-DDTHH:mm:ssZ. The earliest UTC timestamp from which the Tweets will be provided.")] = None,
        end_time: Annotated[Optional[datetime], Field(description="YYYY-MM-DDTHH:mm:ssZ. The latest UTC timestamp to which the Tweets will be provided.")] = None,
        tweet_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of Tweet fields to display.")] = None,
        expansions: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of fields to expand.")] = None,
        media_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of Media fields to display.")] = None,
        poll_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of Poll fields to display.")] = None,
        user_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of User fields to display.")] = None,
        place_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of Place fields to display.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[FilteredStreamingTweetResponse]:
        """Filtered stream

        Streams Tweets matching the stream's active rule set.

        :param backfill_minutes: The number of minutes of backfill requested.
        :type backfill_minutes: int
        :param start_time: YYYY-MM-DDTHH:mm:ssZ. The earliest UTC timestamp from which the Tweets will be provided.
        :type start_time: datetime
        :param end_time: YYYY-MM-DDTHH:mm:ssZ. The latest UTC timestamp to which the Tweets will be provided.
        :type end_time: datetime
        :param tweet_fields: A comma separated list of Tweet fields to display.
        :type tweet_fields: List[str]
        :param expansions: A comma separated list of fields to expand.
        :type expansions: List[str]
        :param media_fields: A comma separated list of Media fields to display.
        :type media_fields: List[str]
        :param poll_fields: A comma separated list of Poll fields to display.
        :type poll_fields: List[str]
        :param user_fields: A comma separated list of User fields to display.
        :type user_fields: List[str]
        :param place_fields: A comma separated list of Place fields to display.
        :type place_fields: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._search_stream_serialize(
            backfill_minutes=backfill_minutes,
            start_time=start_time,
            end_time=end_time,
            tweet_fields=tweet_fields,
            expansions=expansions,
            media_fields=media_fields,
            poll_fields=poll_fields,
            user_fields=user_fields,
            place_fields=place_fields,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FilteredStreamingTweetResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def search_stream_without_preload_content(
        self,
        backfill_minutes: Annotated[Optional[Annotated[int, Field(le=5, strict=True, ge=0)]], Field(description="The number of minutes of backfill requested.")] = None,
        start_time: Annotated[Optional[datetime], Field(description="YYYY-MM-DDTHH:mm:ssZ. The earliest UTC timestamp from which the Tweets will be provided.")] = None,
        end_time: Annotated[Optional[datetime], Field(description="YYYY-MM-DDTHH:mm:ssZ. The latest UTC timestamp to which the Tweets will be provided.")] = None,
        tweet_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of Tweet fields to display.")] = None,
        expansions: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of fields to expand.")] = None,
        media_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of Media fields to display.")] = None,
        poll_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of Poll fields to display.")] = None,
        user_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of User fields to display.")] = None,
        place_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of Place fields to display.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Filtered stream

        Streams Tweets matching the stream's active rule set.

        :param backfill_minutes: The number of minutes of backfill requested.
        :type backfill_minutes: int
        :param start_time: YYYY-MM-DDTHH:mm:ssZ. The earliest UTC timestamp from which the Tweets will be provided.
        :type start_time: datetime
        :param end_time: YYYY-MM-DDTHH:mm:ssZ. The latest UTC timestamp to which the Tweets will be provided.
        :type end_time: datetime
        :param tweet_fields: A comma separated list of Tweet fields to display.
        :type tweet_fields: List[str]
        :param expansions: A comma separated list of fields to expand.
        :type expansions: List[str]
        :param media_fields: A comma separated list of Media fields to display.
        :type media_fields: List[str]
        :param poll_fields: A comma separated list of Poll fields to display.
        :type poll_fields: List[str]
        :param user_fields: A comma separated list of User fields to display.
        :type user_fields: List[str]
        :param place_fields: A comma separated list of Place fields to display.
        :type place_fields: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._search_stream_serialize(
            backfill_minutes=backfill_minutes,
            start_time=start_time,
            end_time=end_time,
            tweet_fields=tweet_fields,
            expansions=expansions,
            media_fields=media_fields,
            poll_fields=poll_fields,
            user_fields=user_fields,
            place_fields=place_fields,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FilteredStreamingTweetResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _search_stream_serialize(
        self,
        backfill_minutes,
        start_time,
        end_time,
        tweet_fields,
        expansions,
        media_fields,
        poll_fields,
        user_fields,
        place_fields,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'tweet.fields': 'csv',
            'expansions': 'csv',
            'media.fields': 'csv',
            'poll.fields': 'csv',
            'user.fields': 'csv',
            'place.fields': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if backfill_minutes is not None:
            
            _query_params.append(('backfill_minutes', backfill_minutes))
            
        if start_time is not None:
            if isinstance(start_time, datetime):
                _query_params.append(
                    (
                        'start_time',
                        start_time.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('start_time', start_time))
            
        if end_time is not None:
            if isinstance(end_time, datetime):
                _query_params.append(
                    (
                        'end_time',
                        end_time.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('end_time', end_time))
            
        if tweet_fields is not None:
            
            _query_params.append(('tweet.fields', tweet_fields))
            
        if expansions is not None:
            
            _query_params.append(('expansions', expansions))
            
        if media_fields is not None:
            
            _query_params.append(('media.fields', media_fields))
            
        if poll_fields is not None:
            
            _query_params.append(('poll.fields', poll_fields))
            
        if user_fields is not None:
            
            _query_params.append(('user.fields', user_fields))
            
        if place_fields is not None:
            
            _query_params.append(('place.fields', place_fields))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json', 
                    'application/problem+json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'BearerToken'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/2/tweets/search/stream',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def space_buyers_0(
        self,
        id: Annotated[str, Field(strict=True, description="The ID of the Space to be retrieved.")],
        pagination_token: Annotated[Optional[Annotated[str, Field(min_length=16, strict=True)]], Field(description="This parameter is used to get a specified 'page' of results.")] = None,
        max_results: Annotated[Optional[Annotated[int, Field(le=100, strict=True, ge=1)]], Field(description="The maximum number of results.")] = None,
        user_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of User fields to display.")] = None,
        expansions: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of fields to expand.")] = None,
        tweet_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of Tweet fields to display.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> Get2SpacesIdBuyersResponse:
        """Retrieve the list of Users who purchased a ticket to the given space

        Retrieves the list of Users who purchased a ticket to the given space

        :param id: The ID of the Space to be retrieved. (required)
        :type id: str
        :param pagination_token: This parameter is used to get a specified 'page' of results.
        :type pagination_token: str
        :param max_results: The maximum number of results.
        :type max_results: int
        :param user_fields: A comma separated list of User fields to display.
        :type user_fields: List[str]
        :param expansions: A comma separated list of fields to expand.
        :type expansions: List[str]
        :param tweet_fields: A comma separated list of Tweet fields to display.
        :type tweet_fields: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._space_buyers_0_serialize(
            id=id,
            pagination_token=pagination_token,
            max_results=max_results,
            user_fields=user_fields,
            expansions=expansions,
            tweet_fields=tweet_fields,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Get2SpacesIdBuyersResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def space_buyers_0_with_http_info(
        self,
        id: Annotated[str, Field(strict=True, description="The ID of the Space to be retrieved.")],
        pagination_token: Annotated[Optional[Annotated[str, Field(min_length=16, strict=True)]], Field(description="This parameter is used to get a specified 'page' of results.")] = None,
        max_results: Annotated[Optional[Annotated[int, Field(le=100, strict=True, ge=1)]], Field(description="The maximum number of results.")] = None,
        user_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of User fields to display.")] = None,
        expansions: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of fields to expand.")] = None,
        tweet_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of Tweet fields to display.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[Get2SpacesIdBuyersResponse]:
        """Retrieve the list of Users who purchased a ticket to the given space

        Retrieves the list of Users who purchased a ticket to the given space

        :param id: The ID of the Space to be retrieved. (required)
        :type id: str
        :param pagination_token: This parameter is used to get a specified 'page' of results.
        :type pagination_token: str
        :param max_results: The maximum number of results.
        :type max_results: int
        :param user_fields: A comma separated list of User fields to display.
        :type user_fields: List[str]
        :param expansions: A comma separated list of fields to expand.
        :type expansions: List[str]
        :param tweet_fields: A comma separated list of Tweet fields to display.
        :type tweet_fields: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._space_buyers_0_serialize(
            id=id,
            pagination_token=pagination_token,
            max_results=max_results,
            user_fields=user_fields,
            expansions=expansions,
            tweet_fields=tweet_fields,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Get2SpacesIdBuyersResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def space_buyers_0_without_preload_content(
        self,
        id: Annotated[str, Field(strict=True, description="The ID of the Space to be retrieved.")],
        pagination_token: Annotated[Optional[Annotated[str, Field(min_length=16, strict=True)]], Field(description="This parameter is used to get a specified 'page' of results.")] = None,
        max_results: Annotated[Optional[Annotated[int, Field(le=100, strict=True, ge=1)]], Field(description="The maximum number of results.")] = None,
        user_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of User fields to display.")] = None,
        expansions: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of fields to expand.")] = None,
        tweet_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of Tweet fields to display.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Retrieve the list of Users who purchased a ticket to the given space

        Retrieves the list of Users who purchased a ticket to the given space

        :param id: The ID of the Space to be retrieved. (required)
        :type id: str
        :param pagination_token: This parameter is used to get a specified 'page' of results.
        :type pagination_token: str
        :param max_results: The maximum number of results.
        :type max_results: int
        :param user_fields: A comma separated list of User fields to display.
        :type user_fields: List[str]
        :param expansions: A comma separated list of fields to expand.
        :type expansions: List[str]
        :param tweet_fields: A comma separated list of Tweet fields to display.
        :type tweet_fields: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._space_buyers_0_serialize(
            id=id,
            pagination_token=pagination_token,
            max_results=max_results,
            user_fields=user_fields,
            expansions=expansions,
            tweet_fields=tweet_fields,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Get2SpacesIdBuyersResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _space_buyers_0_serialize(
        self,
        id,
        pagination_token,
        max_results,
        user_fields,
        expansions,
        tweet_fields,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'user.fields': 'csv',
            'expansions': 'csv',
            'tweet.fields': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        if pagination_token is not None:
            
            _query_params.append(('pagination_token', pagination_token))
            
        if max_results is not None:
            
            _query_params.append(('max_results', max_results))
            
        if user_fields is not None:
            
            _query_params.append(('user.fields', user_fields))
            
        if expansions is not None:
            
            _query_params.append(('expansions', expansions))
            
        if tweet_fields is not None:
            
            _query_params.append(('tweet.fields', tweet_fields))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json', 
                    'application/problem+json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'OAuth2UserToken'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/2/spaces/{id}/buyers',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def space_tweets_0(
        self,
        id: Annotated[str, Field(strict=True, description="The ID of the Space to be retrieved.")],
        max_results: Annotated[Optional[Annotated[int, Field(le=100, strict=True, ge=1)]], Field(description="The number of Tweets to fetch from the provided space. If not provided, the value will default to the maximum of 100.")] = None,
        tweet_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of Tweet fields to display.")] = None,
        expansions: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of fields to expand.")] = None,
        media_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of Media fields to display.")] = None,
        poll_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of Poll fields to display.")] = None,
        user_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of User fields to display.")] = None,
        place_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of Place fields to display.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> Get2SpacesIdTweetsResponse:
        """Retrieve Tweets from a Space.

        Retrieves Tweets shared in the specified Space.

        :param id: The ID of the Space to be retrieved. (required)
        :type id: str
        :param max_results: The number of Tweets to fetch from the provided space. If not provided, the value will default to the maximum of 100.
        :type max_results: int
        :param tweet_fields: A comma separated list of Tweet fields to display.
        :type tweet_fields: List[str]
        :param expansions: A comma separated list of fields to expand.
        :type expansions: List[str]
        :param media_fields: A comma separated list of Media fields to display.
        :type media_fields: List[str]
        :param poll_fields: A comma separated list of Poll fields to display.
        :type poll_fields: List[str]
        :param user_fields: A comma separated list of User fields to display.
        :type user_fields: List[str]
        :param place_fields: A comma separated list of Place fields to display.
        :type place_fields: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._space_tweets_0_serialize(
            id=id,
            max_results=max_results,
            tweet_fields=tweet_fields,
            expansions=expansions,
            media_fields=media_fields,
            poll_fields=poll_fields,
            user_fields=user_fields,
            place_fields=place_fields,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Get2SpacesIdTweetsResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def space_tweets_0_with_http_info(
        self,
        id: Annotated[str, Field(strict=True, description="The ID of the Space to be retrieved.")],
        max_results: Annotated[Optional[Annotated[int, Field(le=100, strict=True, ge=1)]], Field(description="The number of Tweets to fetch from the provided space. If not provided, the value will default to the maximum of 100.")] = None,
        tweet_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of Tweet fields to display.")] = None,
        expansions: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of fields to expand.")] = None,
        media_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of Media fields to display.")] = None,
        poll_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of Poll fields to display.")] = None,
        user_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of User fields to display.")] = None,
        place_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of Place fields to display.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[Get2SpacesIdTweetsResponse]:
        """Retrieve Tweets from a Space.

        Retrieves Tweets shared in the specified Space.

        :param id: The ID of the Space to be retrieved. (required)
        :type id: str
        :param max_results: The number of Tweets to fetch from the provided space. If not provided, the value will default to the maximum of 100.
        :type max_results: int
        :param tweet_fields: A comma separated list of Tweet fields to display.
        :type tweet_fields: List[str]
        :param expansions: A comma separated list of fields to expand.
        :type expansions: List[str]
        :param media_fields: A comma separated list of Media fields to display.
        :type media_fields: List[str]
        :param poll_fields: A comma separated list of Poll fields to display.
        :type poll_fields: List[str]
        :param user_fields: A comma separated list of User fields to display.
        :type user_fields: List[str]
        :param place_fields: A comma separated list of Place fields to display.
        :type place_fields: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._space_tweets_0_serialize(
            id=id,
            max_results=max_results,
            tweet_fields=tweet_fields,
            expansions=expansions,
            media_fields=media_fields,
            poll_fields=poll_fields,
            user_fields=user_fields,
            place_fields=place_fields,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Get2SpacesIdTweetsResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def space_tweets_0_without_preload_content(
        self,
        id: Annotated[str, Field(strict=True, description="The ID of the Space to be retrieved.")],
        max_results: Annotated[Optional[Annotated[int, Field(le=100, strict=True, ge=1)]], Field(description="The number of Tweets to fetch from the provided space. If not provided, the value will default to the maximum of 100.")] = None,
        tweet_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of Tweet fields to display.")] = None,
        expansions: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of fields to expand.")] = None,
        media_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of Media fields to display.")] = None,
        poll_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of Poll fields to display.")] = None,
        user_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of User fields to display.")] = None,
        place_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of Place fields to display.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Retrieve Tweets from a Space.

        Retrieves Tweets shared in the specified Space.

        :param id: The ID of the Space to be retrieved. (required)
        :type id: str
        :param max_results: The number of Tweets to fetch from the provided space. If not provided, the value will default to the maximum of 100.
        :type max_results: int
        :param tweet_fields: A comma separated list of Tweet fields to display.
        :type tweet_fields: List[str]
        :param expansions: A comma separated list of fields to expand.
        :type expansions: List[str]
        :param media_fields: A comma separated list of Media fields to display.
        :type media_fields: List[str]
        :param poll_fields: A comma separated list of Poll fields to display.
        :type poll_fields: List[str]
        :param user_fields: A comma separated list of User fields to display.
        :type user_fields: List[str]
        :param place_fields: A comma separated list of Place fields to display.
        :type place_fields: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._space_tweets_0_serialize(
            id=id,
            max_results=max_results,
            tweet_fields=tweet_fields,
            expansions=expansions,
            media_fields=media_fields,
            poll_fields=poll_fields,
            user_fields=user_fields,
            place_fields=place_fields,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Get2SpacesIdTweetsResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _space_tweets_0_serialize(
        self,
        id,
        max_results,
        tweet_fields,
        expansions,
        media_fields,
        poll_fields,
        user_fields,
        place_fields,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'tweet.fields': 'csv',
            'expansions': 'csv',
            'media.fields': 'csv',
            'poll.fields': 'csv',
            'user.fields': 'csv',
            'place.fields': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        if max_results is not None:
            
            _query_params.append(('max_results', max_results))
            
        if tweet_fields is not None:
            
            _query_params.append(('tweet.fields', tweet_fields))
            
        if expansions is not None:
            
            _query_params.append(('expansions', expansions))
            
        if media_fields is not None:
            
            _query_params.append(('media.fields', media_fields))
            
        if poll_fields is not None:
            
            _query_params.append(('poll.fields', poll_fields))
            
        if user_fields is not None:
            
            _query_params.append(('user.fields', user_fields))
            
        if place_fields is not None:
            
            _query_params.append(('place.fields', place_fields))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json', 
                    'application/problem+json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'OAuth2UserToken', 
            'BearerToken'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/2/spaces/{id}/tweets',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def tweet_counts_full_archive_search(
        self,
        query: Annotated[str, Field(min_length=1, strict=True, max_length=4096, description="One query/rule/filter for matching Tweets. Refer to https://t.co/rulelength to identify the max query length.")],
        start_time: Annotated[Optional[datetime], Field(description="YYYY-MM-DDTHH:mm:ssZ. The oldest UTC timestamp (from most recent 7 days) from which the Tweets will be provided. Timestamp is in second granularity and is inclusive (i.e. 12:00:01 includes the first second of the minute).")] = None,
        end_time: Annotated[Optional[datetime], Field(description="YYYY-MM-DDTHH:mm:ssZ. The newest, most recent UTC timestamp to which the Tweets will be provided. Timestamp is in second granularity and is exclusive (i.e. 12:00:01 excludes the first second of the minute).")] = None,
        since_id: Annotated[Optional[Annotated[str, Field(strict=True)]], Field(description="Returns results with a Tweet ID greater than (that is, more recent than) the specified ID.")] = None,
        until_id: Annotated[Optional[Annotated[str, Field(strict=True)]], Field(description="Returns results with a Tweet ID less than (that is, older than) the specified ID.")] = None,
        next_token: Annotated[Optional[Annotated[str, Field(min_length=1, strict=True)]], Field(description="This parameter is used to get the next 'page' of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified.")] = None,
        pagination_token: Annotated[Optional[Annotated[str, Field(min_length=1, strict=True)]], Field(description="This parameter is used to get the next 'page' of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified.")] = None,
        granularity: Annotated[Optional[StrictStr], Field(description="The granularity for the search counts results.")] = None,
        search_count_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of SearchCount fields to display.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> Get2TweetsCountsAllResponse:
        """Full archive search counts

        Returns Tweet Counts that match a search query.

        :param query: One query/rule/filter for matching Tweets. Refer to https://t.co/rulelength to identify the max query length. (required)
        :type query: str
        :param start_time: YYYY-MM-DDTHH:mm:ssZ. The oldest UTC timestamp (from most recent 7 days) from which the Tweets will be provided. Timestamp is in second granularity and is inclusive (i.e. 12:00:01 includes the first second of the minute).
        :type start_time: datetime
        :param end_time: YYYY-MM-DDTHH:mm:ssZ. The newest, most recent UTC timestamp to which the Tweets will be provided. Timestamp is in second granularity and is exclusive (i.e. 12:00:01 excludes the first second of the minute).
        :type end_time: datetime
        :param since_id: Returns results with a Tweet ID greater than (that is, more recent than) the specified ID.
        :type since_id: str
        :param until_id: Returns results with a Tweet ID less than (that is, older than) the specified ID.
        :type until_id: str
        :param next_token: This parameter is used to get the next 'page' of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified.
        :type next_token: str
        :param pagination_token: This parameter is used to get the next 'page' of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified.
        :type pagination_token: str
        :param granularity: The granularity for the search counts results.
        :type granularity: str
        :param search_count_fields: A comma separated list of SearchCount fields to display.
        :type search_count_fields: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._tweet_counts_full_archive_search_serialize(
            query=query,
            start_time=start_time,
            end_time=end_time,
            since_id=since_id,
            until_id=until_id,
            next_token=next_token,
            pagination_token=pagination_token,
            granularity=granularity,
            search_count_fields=search_count_fields,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Get2TweetsCountsAllResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def tweet_counts_full_archive_search_with_http_info(
        self,
        query: Annotated[str, Field(min_length=1, strict=True, max_length=4096, description="One query/rule/filter for matching Tweets. Refer to https://t.co/rulelength to identify the max query length.")],
        start_time: Annotated[Optional[datetime], Field(description="YYYY-MM-DDTHH:mm:ssZ. The oldest UTC timestamp (from most recent 7 days) from which the Tweets will be provided. Timestamp is in second granularity and is inclusive (i.e. 12:00:01 includes the first second of the minute).")] = None,
        end_time: Annotated[Optional[datetime], Field(description="YYYY-MM-DDTHH:mm:ssZ. The newest, most recent UTC timestamp to which the Tweets will be provided. Timestamp is in second granularity and is exclusive (i.e. 12:00:01 excludes the first second of the minute).")] = None,
        since_id: Annotated[Optional[Annotated[str, Field(strict=True)]], Field(description="Returns results with a Tweet ID greater than (that is, more recent than) the specified ID.")] = None,
        until_id: Annotated[Optional[Annotated[str, Field(strict=True)]], Field(description="Returns results with a Tweet ID less than (that is, older than) the specified ID.")] = None,
        next_token: Annotated[Optional[Annotated[str, Field(min_length=1, strict=True)]], Field(description="This parameter is used to get the next 'page' of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified.")] = None,
        pagination_token: Annotated[Optional[Annotated[str, Field(min_length=1, strict=True)]], Field(description="This parameter is used to get the next 'page' of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified.")] = None,
        granularity: Annotated[Optional[StrictStr], Field(description="The granularity for the search counts results.")] = None,
        search_count_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of SearchCount fields to display.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[Get2TweetsCountsAllResponse]:
        """Full archive search counts

        Returns Tweet Counts that match a search query.

        :param query: One query/rule/filter for matching Tweets. Refer to https://t.co/rulelength to identify the max query length. (required)
        :type query: str
        :param start_time: YYYY-MM-DDTHH:mm:ssZ. The oldest UTC timestamp (from most recent 7 days) from which the Tweets will be provided. Timestamp is in second granularity and is inclusive (i.e. 12:00:01 includes the first second of the minute).
        :type start_time: datetime
        :param end_time: YYYY-MM-DDTHH:mm:ssZ. The newest, most recent UTC timestamp to which the Tweets will be provided. Timestamp is in second granularity and is exclusive (i.e. 12:00:01 excludes the first second of the minute).
        :type end_time: datetime
        :param since_id: Returns results with a Tweet ID greater than (that is, more recent than) the specified ID.
        :type since_id: str
        :param until_id: Returns results with a Tweet ID less than (that is, older than) the specified ID.
        :type until_id: str
        :param next_token: This parameter is used to get the next 'page' of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified.
        :type next_token: str
        :param pagination_token: This parameter is used to get the next 'page' of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified.
        :type pagination_token: str
        :param granularity: The granularity for the search counts results.
        :type granularity: str
        :param search_count_fields: A comma separated list of SearchCount fields to display.
        :type search_count_fields: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._tweet_counts_full_archive_search_serialize(
            query=query,
            start_time=start_time,
            end_time=end_time,
            since_id=since_id,
            until_id=until_id,
            next_token=next_token,
            pagination_token=pagination_token,
            granularity=granularity,
            search_count_fields=search_count_fields,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Get2TweetsCountsAllResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def tweet_counts_full_archive_search_without_preload_content(
        self,
        query: Annotated[str, Field(min_length=1, strict=True, max_length=4096, description="One query/rule/filter for matching Tweets. Refer to https://t.co/rulelength to identify the max query length.")],
        start_time: Annotated[Optional[datetime], Field(description="YYYY-MM-DDTHH:mm:ssZ. The oldest UTC timestamp (from most recent 7 days) from which the Tweets will be provided. Timestamp is in second granularity and is inclusive (i.e. 12:00:01 includes the first second of the minute).")] = None,
        end_time: Annotated[Optional[datetime], Field(description="YYYY-MM-DDTHH:mm:ssZ. The newest, most recent UTC timestamp to which the Tweets will be provided. Timestamp is in second granularity and is exclusive (i.e. 12:00:01 excludes the first second of the minute).")] = None,
        since_id: Annotated[Optional[Annotated[str, Field(strict=True)]], Field(description="Returns results with a Tweet ID greater than (that is, more recent than) the specified ID.")] = None,
        until_id: Annotated[Optional[Annotated[str, Field(strict=True)]], Field(description="Returns results with a Tweet ID less than (that is, older than) the specified ID.")] = None,
        next_token: Annotated[Optional[Annotated[str, Field(min_length=1, strict=True)]], Field(description="This parameter is used to get the next 'page' of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified.")] = None,
        pagination_token: Annotated[Optional[Annotated[str, Field(min_length=1, strict=True)]], Field(description="This parameter is used to get the next 'page' of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified.")] = None,
        granularity: Annotated[Optional[StrictStr], Field(description="The granularity for the search counts results.")] = None,
        search_count_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of SearchCount fields to display.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Full archive search counts

        Returns Tweet Counts that match a search query.

        :param query: One query/rule/filter for matching Tweets. Refer to https://t.co/rulelength to identify the max query length. (required)
        :type query: str
        :param start_time: YYYY-MM-DDTHH:mm:ssZ. The oldest UTC timestamp (from most recent 7 days) from which the Tweets will be provided. Timestamp is in second granularity and is inclusive (i.e. 12:00:01 includes the first second of the minute).
        :type start_time: datetime
        :param end_time: YYYY-MM-DDTHH:mm:ssZ. The newest, most recent UTC timestamp to which the Tweets will be provided. Timestamp is in second granularity and is exclusive (i.e. 12:00:01 excludes the first second of the minute).
        :type end_time: datetime
        :param since_id: Returns results with a Tweet ID greater than (that is, more recent than) the specified ID.
        :type since_id: str
        :param until_id: Returns results with a Tweet ID less than (that is, older than) the specified ID.
        :type until_id: str
        :param next_token: This parameter is used to get the next 'page' of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified.
        :type next_token: str
        :param pagination_token: This parameter is used to get the next 'page' of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified.
        :type pagination_token: str
        :param granularity: The granularity for the search counts results.
        :type granularity: str
        :param search_count_fields: A comma separated list of SearchCount fields to display.
        :type search_count_fields: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._tweet_counts_full_archive_search_serialize(
            query=query,
            start_time=start_time,
            end_time=end_time,
            since_id=since_id,
            until_id=until_id,
            next_token=next_token,
            pagination_token=pagination_token,
            granularity=granularity,
            search_count_fields=search_count_fields,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Get2TweetsCountsAllResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _tweet_counts_full_archive_search_serialize(
        self,
        query,
        start_time,
        end_time,
        since_id,
        until_id,
        next_token,
        pagination_token,
        granularity,
        search_count_fields,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'search_count.fields': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if query is not None:
            
            _query_params.append(('query', query))
            
        if start_time is not None:
            if isinstance(start_time, datetime):
                _query_params.append(
                    (
                        'start_time',
                        start_time.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('start_time', start_time))
            
        if end_time is not None:
            if isinstance(end_time, datetime):
                _query_params.append(
                    (
                        'end_time',
                        end_time.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('end_time', end_time))
            
        if since_id is not None:
            
            _query_params.append(('since_id', since_id))
            
        if until_id is not None:
            
            _query_params.append(('until_id', until_id))
            
        if next_token is not None:
            
            _query_params.append(('next_token', next_token))
            
        if pagination_token is not None:
            
            _query_params.append(('pagination_token', pagination_token))
            
        if granularity is not None:
            
            _query_params.append(('granularity', granularity))
            
        if search_count_fields is not None:
            
            _query_params.append(('search_count.fields', search_count_fields))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json', 
                    'application/problem+json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'BearerToken'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/2/tweets/counts/all',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def tweet_counts_recent_search(
        self,
        query: Annotated[str, Field(min_length=1, strict=True, max_length=4096, description="One query/rule/filter for matching Tweets. Refer to https://t.co/rulelength to identify the max query length.")],
        start_time: Annotated[Optional[datetime], Field(description="YYYY-MM-DDTHH:mm:ssZ. The oldest UTC timestamp (from most recent 7 days) from which the Tweets will be provided. Timestamp is in second granularity and is inclusive (i.e. 12:00:01 includes the first second of the minute).")] = None,
        end_time: Annotated[Optional[datetime], Field(description="YYYY-MM-DDTHH:mm:ssZ. The newest, most recent UTC timestamp to which the Tweets will be provided. Timestamp is in second granularity and is exclusive (i.e. 12:00:01 excludes the first second of the minute).")] = None,
        since_id: Annotated[Optional[Annotated[str, Field(strict=True)]], Field(description="Returns results with a Tweet ID greater than (that is, more recent than) the specified ID.")] = None,
        until_id: Annotated[Optional[Annotated[str, Field(strict=True)]], Field(description="Returns results with a Tweet ID less than (that is, older than) the specified ID.")] = None,
        next_token: Annotated[Optional[Annotated[str, Field(min_length=1, strict=True)]], Field(description="This parameter is used to get the next 'page' of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified.")] = None,
        pagination_token: Annotated[Optional[Annotated[str, Field(min_length=1, strict=True)]], Field(description="This parameter is used to get the next 'page' of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified.")] = None,
        granularity: Annotated[Optional[StrictStr], Field(description="The granularity for the search counts results.")] = None,
        search_count_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of SearchCount fields to display.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> Get2TweetsCountsRecentResponse:
        """Recent search counts

        Returns Tweet Counts from the last 7 days that match a search query.

        :param query: One query/rule/filter for matching Tweets. Refer to https://t.co/rulelength to identify the max query length. (required)
        :type query: str
        :param start_time: YYYY-MM-DDTHH:mm:ssZ. The oldest UTC timestamp (from most recent 7 days) from which the Tweets will be provided. Timestamp is in second granularity and is inclusive (i.e. 12:00:01 includes the first second of the minute).
        :type start_time: datetime
        :param end_time: YYYY-MM-DDTHH:mm:ssZ. The newest, most recent UTC timestamp to which the Tweets will be provided. Timestamp is in second granularity and is exclusive (i.e. 12:00:01 excludes the first second of the minute).
        :type end_time: datetime
        :param since_id: Returns results with a Tweet ID greater than (that is, more recent than) the specified ID.
        :type since_id: str
        :param until_id: Returns results with a Tweet ID less than (that is, older than) the specified ID.
        :type until_id: str
        :param next_token: This parameter is used to get the next 'page' of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified.
        :type next_token: str
        :param pagination_token: This parameter is used to get the next 'page' of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified.
        :type pagination_token: str
        :param granularity: The granularity for the search counts results.
        :type granularity: str
        :param search_count_fields: A comma separated list of SearchCount fields to display.
        :type search_count_fields: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._tweet_counts_recent_search_serialize(
            query=query,
            start_time=start_time,
            end_time=end_time,
            since_id=since_id,
            until_id=until_id,
            next_token=next_token,
            pagination_token=pagination_token,
            granularity=granularity,
            search_count_fields=search_count_fields,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Get2TweetsCountsRecentResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def tweet_counts_recent_search_with_http_info(
        self,
        query: Annotated[str, Field(min_length=1, strict=True, max_length=4096, description="One query/rule/filter for matching Tweets. Refer to https://t.co/rulelength to identify the max query length.")],
        start_time: Annotated[Optional[datetime], Field(description="YYYY-MM-DDTHH:mm:ssZ. The oldest UTC timestamp (from most recent 7 days) from which the Tweets will be provided. Timestamp is in second granularity and is inclusive (i.e. 12:00:01 includes the first second of the minute).")] = None,
        end_time: Annotated[Optional[datetime], Field(description="YYYY-MM-DDTHH:mm:ssZ. The newest, most recent UTC timestamp to which the Tweets will be provided. Timestamp is in second granularity and is exclusive (i.e. 12:00:01 excludes the first second of the minute).")] = None,
        since_id: Annotated[Optional[Annotated[str, Field(strict=True)]], Field(description="Returns results with a Tweet ID greater than (that is, more recent than) the specified ID.")] = None,
        until_id: Annotated[Optional[Annotated[str, Field(strict=True)]], Field(description="Returns results with a Tweet ID less than (that is, older than) the specified ID.")] = None,
        next_token: Annotated[Optional[Annotated[str, Field(min_length=1, strict=True)]], Field(description="This parameter is used to get the next 'page' of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified.")] = None,
        pagination_token: Annotated[Optional[Annotated[str, Field(min_length=1, strict=True)]], Field(description="This parameter is used to get the next 'page' of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified.")] = None,
        granularity: Annotated[Optional[StrictStr], Field(description="The granularity for the search counts results.")] = None,
        search_count_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of SearchCount fields to display.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[Get2TweetsCountsRecentResponse]:
        """Recent search counts

        Returns Tweet Counts from the last 7 days that match a search query.

        :param query: One query/rule/filter for matching Tweets. Refer to https://t.co/rulelength to identify the max query length. (required)
        :type query: str
        :param start_time: YYYY-MM-DDTHH:mm:ssZ. The oldest UTC timestamp (from most recent 7 days) from which the Tweets will be provided. Timestamp is in second granularity and is inclusive (i.e. 12:00:01 includes the first second of the minute).
        :type start_time: datetime
        :param end_time: YYYY-MM-DDTHH:mm:ssZ. The newest, most recent UTC timestamp to which the Tweets will be provided. Timestamp is in second granularity and is exclusive (i.e. 12:00:01 excludes the first second of the minute).
        :type end_time: datetime
        :param since_id: Returns results with a Tweet ID greater than (that is, more recent than) the specified ID.
        :type since_id: str
        :param until_id: Returns results with a Tweet ID less than (that is, older than) the specified ID.
        :type until_id: str
        :param next_token: This parameter is used to get the next 'page' of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified.
        :type next_token: str
        :param pagination_token: This parameter is used to get the next 'page' of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified.
        :type pagination_token: str
        :param granularity: The granularity for the search counts results.
        :type granularity: str
        :param search_count_fields: A comma separated list of SearchCount fields to display.
        :type search_count_fields: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._tweet_counts_recent_search_serialize(
            query=query,
            start_time=start_time,
            end_time=end_time,
            since_id=since_id,
            until_id=until_id,
            next_token=next_token,
            pagination_token=pagination_token,
            granularity=granularity,
            search_count_fields=search_count_fields,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Get2TweetsCountsRecentResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def tweet_counts_recent_search_without_preload_content(
        self,
        query: Annotated[str, Field(min_length=1, strict=True, max_length=4096, description="One query/rule/filter for matching Tweets. Refer to https://t.co/rulelength to identify the max query length.")],
        start_time: Annotated[Optional[datetime], Field(description="YYYY-MM-DDTHH:mm:ssZ. The oldest UTC timestamp (from most recent 7 days) from which the Tweets will be provided. Timestamp is in second granularity and is inclusive (i.e. 12:00:01 includes the first second of the minute).")] = None,
        end_time: Annotated[Optional[datetime], Field(description="YYYY-MM-DDTHH:mm:ssZ. The newest, most recent UTC timestamp to which the Tweets will be provided. Timestamp is in second granularity and is exclusive (i.e. 12:00:01 excludes the first second of the minute).")] = None,
        since_id: Annotated[Optional[Annotated[str, Field(strict=True)]], Field(description="Returns results with a Tweet ID greater than (that is, more recent than) the specified ID.")] = None,
        until_id: Annotated[Optional[Annotated[str, Field(strict=True)]], Field(description="Returns results with a Tweet ID less than (that is, older than) the specified ID.")] = None,
        next_token: Annotated[Optional[Annotated[str, Field(min_length=1, strict=True)]], Field(description="This parameter is used to get the next 'page' of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified.")] = None,
        pagination_token: Annotated[Optional[Annotated[str, Field(min_length=1, strict=True)]], Field(description="This parameter is used to get the next 'page' of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified.")] = None,
        granularity: Annotated[Optional[StrictStr], Field(description="The granularity for the search counts results.")] = None,
        search_count_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of SearchCount fields to display.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Recent search counts

        Returns Tweet Counts from the last 7 days that match a search query.

        :param query: One query/rule/filter for matching Tweets. Refer to https://t.co/rulelength to identify the max query length. (required)
        :type query: str
        :param start_time: YYYY-MM-DDTHH:mm:ssZ. The oldest UTC timestamp (from most recent 7 days) from which the Tweets will be provided. Timestamp is in second granularity and is inclusive (i.e. 12:00:01 includes the first second of the minute).
        :type start_time: datetime
        :param end_time: YYYY-MM-DDTHH:mm:ssZ. The newest, most recent UTC timestamp to which the Tweets will be provided. Timestamp is in second granularity and is exclusive (i.e. 12:00:01 excludes the first second of the minute).
        :type end_time: datetime
        :param since_id: Returns results with a Tweet ID greater than (that is, more recent than) the specified ID.
        :type since_id: str
        :param until_id: Returns results with a Tweet ID less than (that is, older than) the specified ID.
        :type until_id: str
        :param next_token: This parameter is used to get the next 'page' of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified.
        :type next_token: str
        :param pagination_token: This parameter is used to get the next 'page' of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified.
        :type pagination_token: str
        :param granularity: The granularity for the search counts results.
        :type granularity: str
        :param search_count_fields: A comma separated list of SearchCount fields to display.
        :type search_count_fields: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._tweet_counts_recent_search_serialize(
            query=query,
            start_time=start_time,
            end_time=end_time,
            since_id=since_id,
            until_id=until_id,
            next_token=next_token,
            pagination_token=pagination_token,
            granularity=granularity,
            search_count_fields=search_count_fields,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Get2TweetsCountsRecentResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _tweet_counts_recent_search_serialize(
        self,
        query,
        start_time,
        end_time,
        since_id,
        until_id,
        next_token,
        pagination_token,
        granularity,
        search_count_fields,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'search_count.fields': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if query is not None:
            
            _query_params.append(('query', query))
            
        if start_time is not None:
            if isinstance(start_time, datetime):
                _query_params.append(
                    (
                        'start_time',
                        start_time.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('start_time', start_time))
            
        if end_time is not None:
            if isinstance(end_time, datetime):
                _query_params.append(
                    (
                        'end_time',
                        end_time.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('end_time', end_time))
            
        if since_id is not None:
            
            _query_params.append(('since_id', since_id))
            
        if until_id is not None:
            
            _query_params.append(('until_id', until_id))
            
        if next_token is not None:
            
            _query_params.append(('next_token', next_token))
            
        if pagination_token is not None:
            
            _query_params.append(('pagination_token', pagination_token))
            
        if granularity is not None:
            
            _query_params.append(('granularity', granularity))
            
        if search_count_fields is not None:
            
            _query_params.append(('search_count.fields', search_count_fields))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json', 
                    'application/problem+json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'BearerToken'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/2/tweets/counts/recent',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def tweets_fullarchive_search(
        self,
        query: Annotated[str, Field(min_length=1, strict=True, max_length=4096, description="One query/rule/filter for matching Tweets. Refer to https://t.co/rulelength to identify the max query length.")],
        start_time: Annotated[Optional[datetime], Field(description="YYYY-MM-DDTHH:mm:ssZ. The oldest UTC timestamp from which the Tweets will be provided. Timestamp is in second granularity and is inclusive (i.e. 12:00:01 includes the first second of the minute).")] = None,
        end_time: Annotated[Optional[datetime], Field(description="YYYY-MM-DDTHH:mm:ssZ. The newest, most recent UTC timestamp to which the Tweets will be provided. Timestamp is in second granularity and is exclusive (i.e. 12:00:01 excludes the first second of the minute).")] = None,
        since_id: Annotated[Optional[Annotated[str, Field(strict=True)]], Field(description="Returns results with a Tweet ID greater than (that is, more recent than) the specified ID.")] = None,
        until_id: Annotated[Optional[Annotated[str, Field(strict=True)]], Field(description="Returns results with a Tweet ID less than (that is, older than) the specified ID.")] = None,
        max_results: Annotated[Optional[Annotated[int, Field(le=500, strict=True, ge=10)]], Field(description="The maximum number of search results to be returned by a request.")] = None,
        next_token: Annotated[Optional[Annotated[str, Field(min_length=1, strict=True)]], Field(description="This parameter is used to get the next 'page' of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified.")] = None,
        pagination_token: Annotated[Optional[Annotated[str, Field(min_length=1, strict=True)]], Field(description="This parameter is used to get the next 'page' of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified.")] = None,
        sort_order: Annotated[Optional[StrictStr], Field(description="This order in which to return results.")] = None,
        tweet_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of Tweet fields to display.")] = None,
        expansions: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of fields to expand.")] = None,
        media_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of Media fields to display.")] = None,
        poll_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of Poll fields to display.")] = None,
        user_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of User fields to display.")] = None,
        place_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of Place fields to display.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> Get2TweetsSearchAllResponse:
        """Full-archive search

        Returns Tweets that match a search query.

        :param query: One query/rule/filter for matching Tweets. Refer to https://t.co/rulelength to identify the max query length. (required)
        :type query: str
        :param start_time: YYYY-MM-DDTHH:mm:ssZ. The oldest UTC timestamp from which the Tweets will be provided. Timestamp is in second granularity and is inclusive (i.e. 12:00:01 includes the first second of the minute).
        :type start_time: datetime
        :param end_time: YYYY-MM-DDTHH:mm:ssZ. The newest, most recent UTC timestamp to which the Tweets will be provided. Timestamp is in second granularity and is exclusive (i.e. 12:00:01 excludes the first second of the minute).
        :type end_time: datetime
        :param since_id: Returns results with a Tweet ID greater than (that is, more recent than) the specified ID.
        :type since_id: str
        :param until_id: Returns results with a Tweet ID less than (that is, older than) the specified ID.
        :type until_id: str
        :param max_results: The maximum number of search results to be returned by a request.
        :type max_results: int
        :param next_token: This parameter is used to get the next 'page' of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified.
        :type next_token: str
        :param pagination_token: This parameter is used to get the next 'page' of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified.
        :type pagination_token: str
        :param sort_order: This order in which to return results.
        :type sort_order: str
        :param tweet_fields: A comma separated list of Tweet fields to display.
        :type tweet_fields: List[str]
        :param expansions: A comma separated list of fields to expand.
        :type expansions: List[str]
        :param media_fields: A comma separated list of Media fields to display.
        :type media_fields: List[str]
        :param poll_fields: A comma separated list of Poll fields to display.
        :type poll_fields: List[str]
        :param user_fields: A comma separated list of User fields to display.
        :type user_fields: List[str]
        :param place_fields: A comma separated list of Place fields to display.
        :type place_fields: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._tweets_fullarchive_search_serialize(
            query=query,
            start_time=start_time,
            end_time=end_time,
            since_id=since_id,
            until_id=until_id,
            max_results=max_results,
            next_token=next_token,
            pagination_token=pagination_token,
            sort_order=sort_order,
            tweet_fields=tweet_fields,
            expansions=expansions,
            media_fields=media_fields,
            poll_fields=poll_fields,
            user_fields=user_fields,
            place_fields=place_fields,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Get2TweetsSearchAllResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def tweets_fullarchive_search_with_http_info(
        self,
        query: Annotated[str, Field(min_length=1, strict=True, max_length=4096, description="One query/rule/filter for matching Tweets. Refer to https://t.co/rulelength to identify the max query length.")],
        start_time: Annotated[Optional[datetime], Field(description="YYYY-MM-DDTHH:mm:ssZ. The oldest UTC timestamp from which the Tweets will be provided. Timestamp is in second granularity and is inclusive (i.e. 12:00:01 includes the first second of the minute).")] = None,
        end_time: Annotated[Optional[datetime], Field(description="YYYY-MM-DDTHH:mm:ssZ. The newest, most recent UTC timestamp to which the Tweets will be provided. Timestamp is in second granularity and is exclusive (i.e. 12:00:01 excludes the first second of the minute).")] = None,
        since_id: Annotated[Optional[Annotated[str, Field(strict=True)]], Field(description="Returns results with a Tweet ID greater than (that is, more recent than) the specified ID.")] = None,
        until_id: Annotated[Optional[Annotated[str, Field(strict=True)]], Field(description="Returns results with a Tweet ID less than (that is, older than) the specified ID.")] = None,
        max_results: Annotated[Optional[Annotated[int, Field(le=500, strict=True, ge=10)]], Field(description="The maximum number of search results to be returned by a request.")] = None,
        next_token: Annotated[Optional[Annotated[str, Field(min_length=1, strict=True)]], Field(description="This parameter is used to get the next 'page' of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified.")] = None,
        pagination_token: Annotated[Optional[Annotated[str, Field(min_length=1, strict=True)]], Field(description="This parameter is used to get the next 'page' of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified.")] = None,
        sort_order: Annotated[Optional[StrictStr], Field(description="This order in which to return results.")] = None,
        tweet_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of Tweet fields to display.")] = None,
        expansions: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of fields to expand.")] = None,
        media_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of Media fields to display.")] = None,
        poll_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of Poll fields to display.")] = None,
        user_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of User fields to display.")] = None,
        place_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of Place fields to display.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[Get2TweetsSearchAllResponse]:
        """Full-archive search

        Returns Tweets that match a search query.

        :param query: One query/rule/filter for matching Tweets. Refer to https://t.co/rulelength to identify the max query length. (required)
        :type query: str
        :param start_time: YYYY-MM-DDTHH:mm:ssZ. The oldest UTC timestamp from which the Tweets will be provided. Timestamp is in second granularity and is inclusive (i.e. 12:00:01 includes the first second of the minute).
        :type start_time: datetime
        :param end_time: YYYY-MM-DDTHH:mm:ssZ. The newest, most recent UTC timestamp to which the Tweets will be provided. Timestamp is in second granularity and is exclusive (i.e. 12:00:01 excludes the first second of the minute).
        :type end_time: datetime
        :param since_id: Returns results with a Tweet ID greater than (that is, more recent than) the specified ID.
        :type since_id: str
        :param until_id: Returns results with a Tweet ID less than (that is, older than) the specified ID.
        :type until_id: str
        :param max_results: The maximum number of search results to be returned by a request.
        :type max_results: int
        :param next_token: This parameter is used to get the next 'page' of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified.
        :type next_token: str
        :param pagination_token: This parameter is used to get the next 'page' of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified.
        :type pagination_token: str
        :param sort_order: This order in which to return results.
        :type sort_order: str
        :param tweet_fields: A comma separated list of Tweet fields to display.
        :type tweet_fields: List[str]
        :param expansions: A comma separated list of fields to expand.
        :type expansions: List[str]
        :param media_fields: A comma separated list of Media fields to display.
        :type media_fields: List[str]
        :param poll_fields: A comma separated list of Poll fields to display.
        :type poll_fields: List[str]
        :param user_fields: A comma separated list of User fields to display.
        :type user_fields: List[str]
        :param place_fields: A comma separated list of Place fields to display.
        :type place_fields: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._tweets_fullarchive_search_serialize(
            query=query,
            start_time=start_time,
            end_time=end_time,
            since_id=since_id,
            until_id=until_id,
            max_results=max_results,
            next_token=next_token,
            pagination_token=pagination_token,
            sort_order=sort_order,
            tweet_fields=tweet_fields,
            expansions=expansions,
            media_fields=media_fields,
            poll_fields=poll_fields,
            user_fields=user_fields,
            place_fields=place_fields,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Get2TweetsSearchAllResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def tweets_fullarchive_search_without_preload_content(
        self,
        query: Annotated[str, Field(min_length=1, strict=True, max_length=4096, description="One query/rule/filter for matching Tweets. Refer to https://t.co/rulelength to identify the max query length.")],
        start_time: Annotated[Optional[datetime], Field(description="YYYY-MM-DDTHH:mm:ssZ. The oldest UTC timestamp from which the Tweets will be provided. Timestamp is in second granularity and is inclusive (i.e. 12:00:01 includes the first second of the minute).")] = None,
        end_time: Annotated[Optional[datetime], Field(description="YYYY-MM-DDTHH:mm:ssZ. The newest, most recent UTC timestamp to which the Tweets will be provided. Timestamp is in second granularity and is exclusive (i.e. 12:00:01 excludes the first second of the minute).")] = None,
        since_id: Annotated[Optional[Annotated[str, Field(strict=True)]], Field(description="Returns results with a Tweet ID greater than (that is, more recent than) the specified ID.")] = None,
        until_id: Annotated[Optional[Annotated[str, Field(strict=True)]], Field(description="Returns results with a Tweet ID less than (that is, older than) the specified ID.")] = None,
        max_results: Annotated[Optional[Annotated[int, Field(le=500, strict=True, ge=10)]], Field(description="The maximum number of search results to be returned by a request.")] = None,
        next_token: Annotated[Optional[Annotated[str, Field(min_length=1, strict=True)]], Field(description="This parameter is used to get the next 'page' of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified.")] = None,
        pagination_token: Annotated[Optional[Annotated[str, Field(min_length=1, strict=True)]], Field(description="This parameter is used to get the next 'page' of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified.")] = None,
        sort_order: Annotated[Optional[StrictStr], Field(description="This order in which to return results.")] = None,
        tweet_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of Tweet fields to display.")] = None,
        expansions: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of fields to expand.")] = None,
        media_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of Media fields to display.")] = None,
        poll_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of Poll fields to display.")] = None,
        user_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of User fields to display.")] = None,
        place_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of Place fields to display.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Full-archive search

        Returns Tweets that match a search query.

        :param query: One query/rule/filter for matching Tweets. Refer to https://t.co/rulelength to identify the max query length. (required)
        :type query: str
        :param start_time: YYYY-MM-DDTHH:mm:ssZ. The oldest UTC timestamp from which the Tweets will be provided. Timestamp is in second granularity and is inclusive (i.e. 12:00:01 includes the first second of the minute).
        :type start_time: datetime
        :param end_time: YYYY-MM-DDTHH:mm:ssZ. The newest, most recent UTC timestamp to which the Tweets will be provided. Timestamp is in second granularity and is exclusive (i.e. 12:00:01 excludes the first second of the minute).
        :type end_time: datetime
        :param since_id: Returns results with a Tweet ID greater than (that is, more recent than) the specified ID.
        :type since_id: str
        :param until_id: Returns results with a Tweet ID less than (that is, older than) the specified ID.
        :type until_id: str
        :param max_results: The maximum number of search results to be returned by a request.
        :type max_results: int
        :param next_token: This parameter is used to get the next 'page' of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified.
        :type next_token: str
        :param pagination_token: This parameter is used to get the next 'page' of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified.
        :type pagination_token: str
        :param sort_order: This order in which to return results.
        :type sort_order: str
        :param tweet_fields: A comma separated list of Tweet fields to display.
        :type tweet_fields: List[str]
        :param expansions: A comma separated list of fields to expand.
        :type expansions: List[str]
        :param media_fields: A comma separated list of Media fields to display.
        :type media_fields: List[str]
        :param poll_fields: A comma separated list of Poll fields to display.
        :type poll_fields: List[str]
        :param user_fields: A comma separated list of User fields to display.
        :type user_fields: List[str]
        :param place_fields: A comma separated list of Place fields to display.
        :type place_fields: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._tweets_fullarchive_search_serialize(
            query=query,
            start_time=start_time,
            end_time=end_time,
            since_id=since_id,
            until_id=until_id,
            max_results=max_results,
            next_token=next_token,
            pagination_token=pagination_token,
            sort_order=sort_order,
            tweet_fields=tweet_fields,
            expansions=expansions,
            media_fields=media_fields,
            poll_fields=poll_fields,
            user_fields=user_fields,
            place_fields=place_fields,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Get2TweetsSearchAllResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _tweets_fullarchive_search_serialize(
        self,
        query,
        start_time,
        end_time,
        since_id,
        until_id,
        max_results,
        next_token,
        pagination_token,
        sort_order,
        tweet_fields,
        expansions,
        media_fields,
        poll_fields,
        user_fields,
        place_fields,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'tweet.fields': 'csv',
            'expansions': 'csv',
            'media.fields': 'csv',
            'poll.fields': 'csv',
            'user.fields': 'csv',
            'place.fields': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if query is not None:
            
            _query_params.append(('query', query))
            
        if start_time is not None:
            if isinstance(start_time, datetime):
                _query_params.append(
                    (
                        'start_time',
                        start_time.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('start_time', start_time))
            
        if end_time is not None:
            if isinstance(end_time, datetime):
                _query_params.append(
                    (
                        'end_time',
                        end_time.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('end_time', end_time))
            
        if since_id is not None:
            
            _query_params.append(('since_id', since_id))
            
        if until_id is not None:
            
            _query_params.append(('until_id', until_id))
            
        if max_results is not None:
            
            _query_params.append(('max_results', max_results))
            
        if next_token is not None:
            
            _query_params.append(('next_token', next_token))
            
        if pagination_token is not None:
            
            _query_params.append(('pagination_token', pagination_token))
            
        if sort_order is not None:
            
            _query_params.append(('sort_order', sort_order))
            
        if tweet_fields is not None:
            
            _query_params.append(('tweet.fields', tweet_fields))
            
        if expansions is not None:
            
            _query_params.append(('expansions', expansions))
            
        if media_fields is not None:
            
            _query_params.append(('media.fields', media_fields))
            
        if poll_fields is not None:
            
            _query_params.append(('poll.fields', poll_fields))
            
        if user_fields is not None:
            
            _query_params.append(('user.fields', user_fields))
            
        if place_fields is not None:
            
            _query_params.append(('place.fields', place_fields))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json', 
                    'application/problem+json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'BearerToken'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/2/tweets/search/all',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def tweets_recent_search(
        self,
        query: Annotated[str, Field(min_length=1, strict=True, max_length=4096, description="One query/rule/filter for matching Tweets. Refer to https://t.co/rulelength to identify the max query length.")],
        start_time: Annotated[Optional[datetime], Field(description="YYYY-MM-DDTHH:mm:ssZ. The oldest UTC timestamp from which the Tweets will be provided. Timestamp is in second granularity and is inclusive (i.e. 12:00:01 includes the first second of the minute).")] = None,
        end_time: Annotated[Optional[datetime], Field(description="YYYY-MM-DDTHH:mm:ssZ. The newest, most recent UTC timestamp to which the Tweets will be provided. Timestamp is in second granularity and is exclusive (i.e. 12:00:01 excludes the first second of the minute).")] = None,
        since_id: Annotated[Optional[Annotated[str, Field(strict=True)]], Field(description="Returns results with a Tweet ID greater than (that is, more recent than) the specified ID.")] = None,
        until_id: Annotated[Optional[Annotated[str, Field(strict=True)]], Field(description="Returns results with a Tweet ID less than (that is, older than) the specified ID.")] = None,
        max_results: Annotated[Optional[Annotated[int, Field(le=100, strict=True, ge=10)]], Field(description="The maximum number of search results to be returned by a request.")] = None,
        next_token: Annotated[Optional[Annotated[str, Field(min_length=1, strict=True)]], Field(description="This parameter is used to get the next 'page' of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified.")] = None,
        pagination_token: Annotated[Optional[Annotated[str, Field(min_length=1, strict=True)]], Field(description="This parameter is used to get the next 'page' of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified.")] = None,
        sort_order: Annotated[Optional[StrictStr], Field(description="This order in which to return results.")] = None,
        tweet_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of Tweet fields to display.")] = None,
        expansions: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of fields to expand.")] = None,
        media_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of Media fields to display.")] = None,
        poll_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of Poll fields to display.")] = None,
        user_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of User fields to display.")] = None,
        place_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of Place fields to display.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> Get2TweetsSearchRecentResponse:
        """Recent search

        Returns Tweets from the last 7 days that match a search query.

        :param query: One query/rule/filter for matching Tweets. Refer to https://t.co/rulelength to identify the max query length. (required)
        :type query: str
        :param start_time: YYYY-MM-DDTHH:mm:ssZ. The oldest UTC timestamp from which the Tweets will be provided. Timestamp is in second granularity and is inclusive (i.e. 12:00:01 includes the first second of the minute).
        :type start_time: datetime
        :param end_time: YYYY-MM-DDTHH:mm:ssZ. The newest, most recent UTC timestamp to which the Tweets will be provided. Timestamp is in second granularity and is exclusive (i.e. 12:00:01 excludes the first second of the minute).
        :type end_time: datetime
        :param since_id: Returns results with a Tweet ID greater than (that is, more recent than) the specified ID.
        :type since_id: str
        :param until_id: Returns results with a Tweet ID less than (that is, older than) the specified ID.
        :type until_id: str
        :param max_results: The maximum number of search results to be returned by a request.
        :type max_results: int
        :param next_token: This parameter is used to get the next 'page' of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified.
        :type next_token: str
        :param pagination_token: This parameter is used to get the next 'page' of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified.
        :type pagination_token: str
        :param sort_order: This order in which to return results.
        :type sort_order: str
        :param tweet_fields: A comma separated list of Tweet fields to display.
        :type tweet_fields: List[str]
        :param expansions: A comma separated list of fields to expand.
        :type expansions: List[str]
        :param media_fields: A comma separated list of Media fields to display.
        :type media_fields: List[str]
        :param poll_fields: A comma separated list of Poll fields to display.
        :type poll_fields: List[str]
        :param user_fields: A comma separated list of User fields to display.
        :type user_fields: List[str]
        :param place_fields: A comma separated list of Place fields to display.
        :type place_fields: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._tweets_recent_search_serialize(
            query=query,
            start_time=start_time,
            end_time=end_time,
            since_id=since_id,
            until_id=until_id,
            max_results=max_results,
            next_token=next_token,
            pagination_token=pagination_token,
            sort_order=sort_order,
            tweet_fields=tweet_fields,
            expansions=expansions,
            media_fields=media_fields,
            poll_fields=poll_fields,
            user_fields=user_fields,
            place_fields=place_fields,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Get2TweetsSearchRecentResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def tweets_recent_search_with_http_info(
        self,
        query: Annotated[str, Field(min_length=1, strict=True, max_length=4096, description="One query/rule/filter for matching Tweets. Refer to https://t.co/rulelength to identify the max query length.")],
        start_time: Annotated[Optional[datetime], Field(description="YYYY-MM-DDTHH:mm:ssZ. The oldest UTC timestamp from which the Tweets will be provided. Timestamp is in second granularity and is inclusive (i.e. 12:00:01 includes the first second of the minute).")] = None,
        end_time: Annotated[Optional[datetime], Field(description="YYYY-MM-DDTHH:mm:ssZ. The newest, most recent UTC timestamp to which the Tweets will be provided. Timestamp is in second granularity and is exclusive (i.e. 12:00:01 excludes the first second of the minute).")] = None,
        since_id: Annotated[Optional[Annotated[str, Field(strict=True)]], Field(description="Returns results with a Tweet ID greater than (that is, more recent than) the specified ID.")] = None,
        until_id: Annotated[Optional[Annotated[str, Field(strict=True)]], Field(description="Returns results with a Tweet ID less than (that is, older than) the specified ID.")] = None,
        max_results: Annotated[Optional[Annotated[int, Field(le=100, strict=True, ge=10)]], Field(description="The maximum number of search results to be returned by a request.")] = None,
        next_token: Annotated[Optional[Annotated[str, Field(min_length=1, strict=True)]], Field(description="This parameter is used to get the next 'page' of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified.")] = None,
        pagination_token: Annotated[Optional[Annotated[str, Field(min_length=1, strict=True)]], Field(description="This parameter is used to get the next 'page' of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified.")] = None,
        sort_order: Annotated[Optional[StrictStr], Field(description="This order in which to return results.")] = None,
        tweet_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of Tweet fields to display.")] = None,
        expansions: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of fields to expand.")] = None,
        media_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of Media fields to display.")] = None,
        poll_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of Poll fields to display.")] = None,
        user_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of User fields to display.")] = None,
        place_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of Place fields to display.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[Get2TweetsSearchRecentResponse]:
        """Recent search

        Returns Tweets from the last 7 days that match a search query.

        :param query: One query/rule/filter for matching Tweets. Refer to https://t.co/rulelength to identify the max query length. (required)
        :type query: str
        :param start_time: YYYY-MM-DDTHH:mm:ssZ. The oldest UTC timestamp from which the Tweets will be provided. Timestamp is in second granularity and is inclusive (i.e. 12:00:01 includes the first second of the minute).
        :type start_time: datetime
        :param end_time: YYYY-MM-DDTHH:mm:ssZ. The newest, most recent UTC timestamp to which the Tweets will be provided. Timestamp is in second granularity and is exclusive (i.e. 12:00:01 excludes the first second of the minute).
        :type end_time: datetime
        :param since_id: Returns results with a Tweet ID greater than (that is, more recent than) the specified ID.
        :type since_id: str
        :param until_id: Returns results with a Tweet ID less than (that is, older than) the specified ID.
        :type until_id: str
        :param max_results: The maximum number of search results to be returned by a request.
        :type max_results: int
        :param next_token: This parameter is used to get the next 'page' of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified.
        :type next_token: str
        :param pagination_token: This parameter is used to get the next 'page' of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified.
        :type pagination_token: str
        :param sort_order: This order in which to return results.
        :type sort_order: str
        :param tweet_fields: A comma separated list of Tweet fields to display.
        :type tweet_fields: List[str]
        :param expansions: A comma separated list of fields to expand.
        :type expansions: List[str]
        :param media_fields: A comma separated list of Media fields to display.
        :type media_fields: List[str]
        :param poll_fields: A comma separated list of Poll fields to display.
        :type poll_fields: List[str]
        :param user_fields: A comma separated list of User fields to display.
        :type user_fields: List[str]
        :param place_fields: A comma separated list of Place fields to display.
        :type place_fields: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._tweets_recent_search_serialize(
            query=query,
            start_time=start_time,
            end_time=end_time,
            since_id=since_id,
            until_id=until_id,
            max_results=max_results,
            next_token=next_token,
            pagination_token=pagination_token,
            sort_order=sort_order,
            tweet_fields=tweet_fields,
            expansions=expansions,
            media_fields=media_fields,
            poll_fields=poll_fields,
            user_fields=user_fields,
            place_fields=place_fields,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Get2TweetsSearchRecentResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def tweets_recent_search_without_preload_content(
        self,
        query: Annotated[str, Field(min_length=1, strict=True, max_length=4096, description="One query/rule/filter for matching Tweets. Refer to https://t.co/rulelength to identify the max query length.")],
        start_time: Annotated[Optional[datetime], Field(description="YYYY-MM-DDTHH:mm:ssZ. The oldest UTC timestamp from which the Tweets will be provided. Timestamp is in second granularity and is inclusive (i.e. 12:00:01 includes the first second of the minute).")] = None,
        end_time: Annotated[Optional[datetime], Field(description="YYYY-MM-DDTHH:mm:ssZ. The newest, most recent UTC timestamp to which the Tweets will be provided. Timestamp is in second granularity and is exclusive (i.e. 12:00:01 excludes the first second of the minute).")] = None,
        since_id: Annotated[Optional[Annotated[str, Field(strict=True)]], Field(description="Returns results with a Tweet ID greater than (that is, more recent than) the specified ID.")] = None,
        until_id: Annotated[Optional[Annotated[str, Field(strict=True)]], Field(description="Returns results with a Tweet ID less than (that is, older than) the specified ID.")] = None,
        max_results: Annotated[Optional[Annotated[int, Field(le=100, strict=True, ge=10)]], Field(description="The maximum number of search results to be returned by a request.")] = None,
        next_token: Annotated[Optional[Annotated[str, Field(min_length=1, strict=True)]], Field(description="This parameter is used to get the next 'page' of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified.")] = None,
        pagination_token: Annotated[Optional[Annotated[str, Field(min_length=1, strict=True)]], Field(description="This parameter is used to get the next 'page' of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified.")] = None,
        sort_order: Annotated[Optional[StrictStr], Field(description="This order in which to return results.")] = None,
        tweet_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of Tweet fields to display.")] = None,
        expansions: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of fields to expand.")] = None,
        media_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of Media fields to display.")] = None,
        poll_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of Poll fields to display.")] = None,
        user_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of User fields to display.")] = None,
        place_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of Place fields to display.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Recent search

        Returns Tweets from the last 7 days that match a search query.

        :param query: One query/rule/filter for matching Tweets. Refer to https://t.co/rulelength to identify the max query length. (required)
        :type query: str
        :param start_time: YYYY-MM-DDTHH:mm:ssZ. The oldest UTC timestamp from which the Tweets will be provided. Timestamp is in second granularity and is inclusive (i.e. 12:00:01 includes the first second of the minute).
        :type start_time: datetime
        :param end_time: YYYY-MM-DDTHH:mm:ssZ. The newest, most recent UTC timestamp to which the Tweets will be provided. Timestamp is in second granularity and is exclusive (i.e. 12:00:01 excludes the first second of the minute).
        :type end_time: datetime
        :param since_id: Returns results with a Tweet ID greater than (that is, more recent than) the specified ID.
        :type since_id: str
        :param until_id: Returns results with a Tweet ID less than (that is, older than) the specified ID.
        :type until_id: str
        :param max_results: The maximum number of search results to be returned by a request.
        :type max_results: int
        :param next_token: This parameter is used to get the next 'page' of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified.
        :type next_token: str
        :param pagination_token: This parameter is used to get the next 'page' of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified.
        :type pagination_token: str
        :param sort_order: This order in which to return results.
        :type sort_order: str
        :param tweet_fields: A comma separated list of Tweet fields to display.
        :type tweet_fields: List[str]
        :param expansions: A comma separated list of fields to expand.
        :type expansions: List[str]
        :param media_fields: A comma separated list of Media fields to display.
        :type media_fields: List[str]
        :param poll_fields: A comma separated list of Poll fields to display.
        :type poll_fields: List[str]
        :param user_fields: A comma separated list of User fields to display.
        :type user_fields: List[str]
        :param place_fields: A comma separated list of Place fields to display.
        :type place_fields: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._tweets_recent_search_serialize(
            query=query,
            start_time=start_time,
            end_time=end_time,
            since_id=since_id,
            until_id=until_id,
            max_results=max_results,
            next_token=next_token,
            pagination_token=pagination_token,
            sort_order=sort_order,
            tweet_fields=tweet_fields,
            expansions=expansions,
            media_fields=media_fields,
            poll_fields=poll_fields,
            user_fields=user_fields,
            place_fields=place_fields,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Get2TweetsSearchRecentResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _tweets_recent_search_serialize(
        self,
        query,
        start_time,
        end_time,
        since_id,
        until_id,
        max_results,
        next_token,
        pagination_token,
        sort_order,
        tweet_fields,
        expansions,
        media_fields,
        poll_fields,
        user_fields,
        place_fields,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'tweet.fields': 'csv',
            'expansions': 'csv',
            'media.fields': 'csv',
            'poll.fields': 'csv',
            'user.fields': 'csv',
            'place.fields': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if query is not None:
            
            _query_params.append(('query', query))
            
        if start_time is not None:
            if isinstance(start_time, datetime):
                _query_params.append(
                    (
                        'start_time',
                        start_time.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('start_time', start_time))
            
        if end_time is not None:
            if isinstance(end_time, datetime):
                _query_params.append(
                    (
                        'end_time',
                        end_time.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('end_time', end_time))
            
        if since_id is not None:
            
            _query_params.append(('since_id', since_id))
            
        if until_id is not None:
            
            _query_params.append(('until_id', until_id))
            
        if max_results is not None:
            
            _query_params.append(('max_results', max_results))
            
        if next_token is not None:
            
            _query_params.append(('next_token', next_token))
            
        if pagination_token is not None:
            
            _query_params.append(('pagination_token', pagination_token))
            
        if sort_order is not None:
            
            _query_params.append(('sort_order', sort_order))
            
        if tweet_fields is not None:
            
            _query_params.append(('tweet.fields', tweet_fields))
            
        if expansions is not None:
            
            _query_params.append(('expansions', expansions))
            
        if media_fields is not None:
            
            _query_params.append(('media.fields', media_fields))
            
        if poll_fields is not None:
            
            _query_params.append(('poll.fields', poll_fields))
            
        if user_fields is not None:
            
            _query_params.append(('user.fields', user_fields))
            
        if place_fields is not None:
            
            _query_params.append(('place.fields', place_fields))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json', 
                    'application/problem+json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'OAuth2UserToken', 
            'BearerToken', 
            'UserToken'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/2/tweets/search/recent',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def users_id_like(
        self,
        id: Annotated[StrictStr, Field(description="The ID of the authenticated source User that is requesting to like the Tweet.")],
        users_likes_create_request: Optional[UsersLikesCreateRequest] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> UsersLikesCreateResponse:
        """Causes the User (in the path) to like the specified Tweet

        Causes the User (in the path) to like the specified Tweet. The User in the path must match the User context authorizing the request.

        :param id: The ID of the authenticated source User that is requesting to like the Tweet. (required)
        :type id: str
        :param users_likes_create_request:
        :type users_likes_create_request: UsersLikesCreateRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._users_id_like_serialize(
            id=id,
            users_likes_create_request=users_likes_create_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "UsersLikesCreateResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def users_id_like_with_http_info(
        self,
        id: Annotated[StrictStr, Field(description="The ID of the authenticated source User that is requesting to like the Tweet.")],
        users_likes_create_request: Optional[UsersLikesCreateRequest] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[UsersLikesCreateResponse]:
        """Causes the User (in the path) to like the specified Tweet

        Causes the User (in the path) to like the specified Tweet. The User in the path must match the User context authorizing the request.

        :param id: The ID of the authenticated source User that is requesting to like the Tweet. (required)
        :type id: str
        :param users_likes_create_request:
        :type users_likes_create_request: UsersLikesCreateRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._users_id_like_serialize(
            id=id,
            users_likes_create_request=users_likes_create_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "UsersLikesCreateResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def users_id_like_without_preload_content(
        self,
        id: Annotated[StrictStr, Field(description="The ID of the authenticated source User that is requesting to like the Tweet.")],
        users_likes_create_request: Optional[UsersLikesCreateRequest] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Causes the User (in the path) to like the specified Tweet

        Causes the User (in the path) to like the specified Tweet. The User in the path must match the User context authorizing the request.

        :param id: The ID of the authenticated source User that is requesting to like the Tweet. (required)
        :type id: str
        :param users_likes_create_request:
        :type users_likes_create_request: UsersLikesCreateRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._users_id_like_serialize(
            id=id,
            users_likes_create_request=users_likes_create_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "UsersLikesCreateResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _users_id_like_serialize(
        self,
        id,
        users_likes_create_request,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if users_likes_create_request is not None:
            _body_params = users_likes_create_request


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json', 
                    'application/problem+json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'OAuth2UserToken', 
            'UserToken'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/2/users/{id}/likes',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def users_id_liked_tweets(
        self,
        id: Annotated[str, Field(strict=True, description="The ID of the User to lookup.")],
        max_results: Annotated[Optional[Annotated[int, Field(le=100, strict=True, ge=5)]], Field(description="The maximum number of results.")] = None,
        pagination_token: Annotated[Optional[Annotated[str, Field(min_length=1, strict=True)]], Field(description="This parameter is used to get the next 'page' of results.")] = None,
        tweet_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of Tweet fields to display.")] = None,
        expansions: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of fields to expand.")] = None,
        media_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of Media fields to display.")] = None,
        poll_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of Poll fields to display.")] = None,
        user_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of User fields to display.")] = None,
        place_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of Place fields to display.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> Get2UsersIdLikedTweetsResponse:
        """Returns Tweet objects liked by the provided User ID

        Returns a list of Tweets liked by the provided User ID

        :param id: The ID of the User to lookup. (required)
        :type id: str
        :param max_results: The maximum number of results.
        :type max_results: int
        :param pagination_token: This parameter is used to get the next 'page' of results.
        :type pagination_token: str
        :param tweet_fields: A comma separated list of Tweet fields to display.
        :type tweet_fields: List[str]
        :param expansions: A comma separated list of fields to expand.
        :type expansions: List[str]
        :param media_fields: A comma separated list of Media fields to display.
        :type media_fields: List[str]
        :param poll_fields: A comma separated list of Poll fields to display.
        :type poll_fields: List[str]
        :param user_fields: A comma separated list of User fields to display.
        :type user_fields: List[str]
        :param place_fields: A comma separated list of Place fields to display.
        :type place_fields: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._users_id_liked_tweets_serialize(
            id=id,
            max_results=max_results,
            pagination_token=pagination_token,
            tweet_fields=tweet_fields,
            expansions=expansions,
            media_fields=media_fields,
            poll_fields=poll_fields,
            user_fields=user_fields,
            place_fields=place_fields,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Get2UsersIdLikedTweetsResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def users_id_liked_tweets_with_http_info(
        self,
        id: Annotated[str, Field(strict=True, description="The ID of the User to lookup.")],
        max_results: Annotated[Optional[Annotated[int, Field(le=100, strict=True, ge=5)]], Field(description="The maximum number of results.")] = None,
        pagination_token: Annotated[Optional[Annotated[str, Field(min_length=1, strict=True)]], Field(description="This parameter is used to get the next 'page' of results.")] = None,
        tweet_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of Tweet fields to display.")] = None,
        expansions: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of fields to expand.")] = None,
        media_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of Media fields to display.")] = None,
        poll_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of Poll fields to display.")] = None,
        user_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of User fields to display.")] = None,
        place_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of Place fields to display.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[Get2UsersIdLikedTweetsResponse]:
        """Returns Tweet objects liked by the provided User ID

        Returns a list of Tweets liked by the provided User ID

        :param id: The ID of the User to lookup. (required)
        :type id: str
        :param max_results: The maximum number of results.
        :type max_results: int
        :param pagination_token: This parameter is used to get the next 'page' of results.
        :type pagination_token: str
        :param tweet_fields: A comma separated list of Tweet fields to display.
        :type tweet_fields: List[str]
        :param expansions: A comma separated list of fields to expand.
        :type expansions: List[str]
        :param media_fields: A comma separated list of Media fields to display.
        :type media_fields: List[str]
        :param poll_fields: A comma separated list of Poll fields to display.
        :type poll_fields: List[str]
        :param user_fields: A comma separated list of User fields to display.
        :type user_fields: List[str]
        :param place_fields: A comma separated list of Place fields to display.
        :type place_fields: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._users_id_liked_tweets_serialize(
            id=id,
            max_results=max_results,
            pagination_token=pagination_token,
            tweet_fields=tweet_fields,
            expansions=expansions,
            media_fields=media_fields,
            poll_fields=poll_fields,
            user_fields=user_fields,
            place_fields=place_fields,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Get2UsersIdLikedTweetsResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def users_id_liked_tweets_without_preload_content(
        self,
        id: Annotated[str, Field(strict=True, description="The ID of the User to lookup.")],
        max_results: Annotated[Optional[Annotated[int, Field(le=100, strict=True, ge=5)]], Field(description="The maximum number of results.")] = None,
        pagination_token: Annotated[Optional[Annotated[str, Field(min_length=1, strict=True)]], Field(description="This parameter is used to get the next 'page' of results.")] = None,
        tweet_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of Tweet fields to display.")] = None,
        expansions: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of fields to expand.")] = None,
        media_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of Media fields to display.")] = None,
        poll_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of Poll fields to display.")] = None,
        user_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of User fields to display.")] = None,
        place_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of Place fields to display.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Returns Tweet objects liked by the provided User ID

        Returns a list of Tweets liked by the provided User ID

        :param id: The ID of the User to lookup. (required)
        :type id: str
        :param max_results: The maximum number of results.
        :type max_results: int
        :param pagination_token: This parameter is used to get the next 'page' of results.
        :type pagination_token: str
        :param tweet_fields: A comma separated list of Tweet fields to display.
        :type tweet_fields: List[str]
        :param expansions: A comma separated list of fields to expand.
        :type expansions: List[str]
        :param media_fields: A comma separated list of Media fields to display.
        :type media_fields: List[str]
        :param poll_fields: A comma separated list of Poll fields to display.
        :type poll_fields: List[str]
        :param user_fields: A comma separated list of User fields to display.
        :type user_fields: List[str]
        :param place_fields: A comma separated list of Place fields to display.
        :type place_fields: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._users_id_liked_tweets_serialize(
            id=id,
            max_results=max_results,
            pagination_token=pagination_token,
            tweet_fields=tweet_fields,
            expansions=expansions,
            media_fields=media_fields,
            poll_fields=poll_fields,
            user_fields=user_fields,
            place_fields=place_fields,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Get2UsersIdLikedTweetsResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _users_id_liked_tweets_serialize(
        self,
        id,
        max_results,
        pagination_token,
        tweet_fields,
        expansions,
        media_fields,
        poll_fields,
        user_fields,
        place_fields,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'tweet.fields': 'csv',
            'expansions': 'csv',
            'media.fields': 'csv',
            'poll.fields': 'csv',
            'user.fields': 'csv',
            'place.fields': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        if max_results is not None:
            
            _query_params.append(('max_results', max_results))
            
        if pagination_token is not None:
            
            _query_params.append(('pagination_token', pagination_token))
            
        if tweet_fields is not None:
            
            _query_params.append(('tweet.fields', tweet_fields))
            
        if expansions is not None:
            
            _query_params.append(('expansions', expansions))
            
        if media_fields is not None:
            
            _query_params.append(('media.fields', media_fields))
            
        if poll_fields is not None:
            
            _query_params.append(('poll.fields', poll_fields))
            
        if user_fields is not None:
            
            _query_params.append(('user.fields', user_fields))
            
        if place_fields is not None:
            
            _query_params.append(('place.fields', place_fields))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json', 
                    'application/problem+json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'OAuth2UserToken', 
            'BearerToken', 
            'UserToken'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/2/users/{id}/liked_tweets',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def users_id_mentions(
        self,
        id: Annotated[str, Field(strict=True, description="The ID of the User to lookup.")],
        since_id: Annotated[Optional[Annotated[str, Field(strict=True)]], Field(description="The minimum Tweet ID to be included in the result set. This parameter takes precedence over start_time if both are specified.")] = None,
        until_id: Annotated[Optional[Annotated[str, Field(strict=True)]], Field(description="The maximum Tweet ID to be included in the result set. This parameter takes precedence over end_time if both are specified.")] = None,
        max_results: Annotated[Optional[Annotated[int, Field(le=100, strict=True, ge=5)]], Field(description="The maximum number of results.")] = None,
        pagination_token: Annotated[Optional[Annotated[str, Field(min_length=1, strict=True)]], Field(description="This parameter is used to get the next 'page' of results.")] = None,
        start_time: Annotated[Optional[datetime], Field(description="YYYY-MM-DDTHH:mm:ssZ. The earliest UTC timestamp from which the Tweets will be provided. The since_id parameter takes precedence if it is also specified.")] = None,
        end_time: Annotated[Optional[datetime], Field(description="YYYY-MM-DDTHH:mm:ssZ. The latest UTC timestamp to which the Tweets will be provided. The until_id parameter takes precedence if it is also specified.")] = None,
        tweet_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of Tweet fields to display.")] = None,
        expansions: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of fields to expand.")] = None,
        media_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of Media fields to display.")] = None,
        poll_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of Poll fields to display.")] = None,
        user_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of User fields to display.")] = None,
        place_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of Place fields to display.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> Get2UsersIdMentionsResponse:
        """User mention timeline by User ID

        Returns Tweet objects that mention username associated to the provided User ID

        :param id: The ID of the User to lookup. (required)
        :type id: str
        :param since_id: The minimum Tweet ID to be included in the result set. This parameter takes precedence over start_time if both are specified.
        :type since_id: str
        :param until_id: The maximum Tweet ID to be included in the result set. This parameter takes precedence over end_time if both are specified.
        :type until_id: str
        :param max_results: The maximum number of results.
        :type max_results: int
        :param pagination_token: This parameter is used to get the next 'page' of results.
        :type pagination_token: str
        :param start_time: YYYY-MM-DDTHH:mm:ssZ. The earliest UTC timestamp from which the Tweets will be provided. The since_id parameter takes precedence if it is also specified.
        :type start_time: datetime
        :param end_time: YYYY-MM-DDTHH:mm:ssZ. The latest UTC timestamp to which the Tweets will be provided. The until_id parameter takes precedence if it is also specified.
        :type end_time: datetime
        :param tweet_fields: A comma separated list of Tweet fields to display.
        :type tweet_fields: List[str]
        :param expansions: A comma separated list of fields to expand.
        :type expansions: List[str]
        :param media_fields: A comma separated list of Media fields to display.
        :type media_fields: List[str]
        :param poll_fields: A comma separated list of Poll fields to display.
        :type poll_fields: List[str]
        :param user_fields: A comma separated list of User fields to display.
        :type user_fields: List[str]
        :param place_fields: A comma separated list of Place fields to display.
        :type place_fields: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._users_id_mentions_serialize(
            id=id,
            since_id=since_id,
            until_id=until_id,
            max_results=max_results,
            pagination_token=pagination_token,
            start_time=start_time,
            end_time=end_time,
            tweet_fields=tweet_fields,
            expansions=expansions,
            media_fields=media_fields,
            poll_fields=poll_fields,
            user_fields=user_fields,
            place_fields=place_fields,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Get2UsersIdMentionsResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def users_id_mentions_with_http_info(
        self,
        id: Annotated[str, Field(strict=True, description="The ID of the User to lookup.")],
        since_id: Annotated[Optional[Annotated[str, Field(strict=True)]], Field(description="The minimum Tweet ID to be included in the result set. This parameter takes precedence over start_time if both are specified.")] = None,
        until_id: Annotated[Optional[Annotated[str, Field(strict=True)]], Field(description="The maximum Tweet ID to be included in the result set. This parameter takes precedence over end_time if both are specified.")] = None,
        max_results: Annotated[Optional[Annotated[int, Field(le=100, strict=True, ge=5)]], Field(description="The maximum number of results.")] = None,
        pagination_token: Annotated[Optional[Annotated[str, Field(min_length=1, strict=True)]], Field(description="This parameter is used to get the next 'page' of results.")] = None,
        start_time: Annotated[Optional[datetime], Field(description="YYYY-MM-DDTHH:mm:ssZ. The earliest UTC timestamp from which the Tweets will be provided. The since_id parameter takes precedence if it is also specified.")] = None,
        end_time: Annotated[Optional[datetime], Field(description="YYYY-MM-DDTHH:mm:ssZ. The latest UTC timestamp to which the Tweets will be provided. The until_id parameter takes precedence if it is also specified.")] = None,
        tweet_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of Tweet fields to display.")] = None,
        expansions: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of fields to expand.")] = None,
        media_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of Media fields to display.")] = None,
        poll_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of Poll fields to display.")] = None,
        user_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of User fields to display.")] = None,
        place_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of Place fields to display.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[Get2UsersIdMentionsResponse]:
        """User mention timeline by User ID

        Returns Tweet objects that mention username associated to the provided User ID

        :param id: The ID of the User to lookup. (required)
        :type id: str
        :param since_id: The minimum Tweet ID to be included in the result set. This parameter takes precedence over start_time if both are specified.
        :type since_id: str
        :param until_id: The maximum Tweet ID to be included in the result set. This parameter takes precedence over end_time if both are specified.
        :type until_id: str
        :param max_results: The maximum number of results.
        :type max_results: int
        :param pagination_token: This parameter is used to get the next 'page' of results.
        :type pagination_token: str
        :param start_time: YYYY-MM-DDTHH:mm:ssZ. The earliest UTC timestamp from which the Tweets will be provided. The since_id parameter takes precedence if it is also specified.
        :type start_time: datetime
        :param end_time: YYYY-MM-DDTHH:mm:ssZ. The latest UTC timestamp to which the Tweets will be provided. The until_id parameter takes precedence if it is also specified.
        :type end_time: datetime
        :param tweet_fields: A comma separated list of Tweet fields to display.
        :type tweet_fields: List[str]
        :param expansions: A comma separated list of fields to expand.
        :type expansions: List[str]
        :param media_fields: A comma separated list of Media fields to display.
        :type media_fields: List[str]
        :param poll_fields: A comma separated list of Poll fields to display.
        :type poll_fields: List[str]
        :param user_fields: A comma separated list of User fields to display.
        :type user_fields: List[str]
        :param place_fields: A comma separated list of Place fields to display.
        :type place_fields: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._users_id_mentions_serialize(
            id=id,
            since_id=since_id,
            until_id=until_id,
            max_results=max_results,
            pagination_token=pagination_token,
            start_time=start_time,
            end_time=end_time,
            tweet_fields=tweet_fields,
            expansions=expansions,
            media_fields=media_fields,
            poll_fields=poll_fields,
            user_fields=user_fields,
            place_fields=place_fields,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Get2UsersIdMentionsResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def users_id_mentions_without_preload_content(
        self,
        id: Annotated[str, Field(strict=True, description="The ID of the User to lookup.")],
        since_id: Annotated[Optional[Annotated[str, Field(strict=True)]], Field(description="The minimum Tweet ID to be included in the result set. This parameter takes precedence over start_time if both are specified.")] = None,
        until_id: Annotated[Optional[Annotated[str, Field(strict=True)]], Field(description="The maximum Tweet ID to be included in the result set. This parameter takes precedence over end_time if both are specified.")] = None,
        max_results: Annotated[Optional[Annotated[int, Field(le=100, strict=True, ge=5)]], Field(description="The maximum number of results.")] = None,
        pagination_token: Annotated[Optional[Annotated[str, Field(min_length=1, strict=True)]], Field(description="This parameter is used to get the next 'page' of results.")] = None,
        start_time: Annotated[Optional[datetime], Field(description="YYYY-MM-DDTHH:mm:ssZ. The earliest UTC timestamp from which the Tweets will be provided. The since_id parameter takes precedence if it is also specified.")] = None,
        end_time: Annotated[Optional[datetime], Field(description="YYYY-MM-DDTHH:mm:ssZ. The latest UTC timestamp to which the Tweets will be provided. The until_id parameter takes precedence if it is also specified.")] = None,
        tweet_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of Tweet fields to display.")] = None,
        expansions: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of fields to expand.")] = None,
        media_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of Media fields to display.")] = None,
        poll_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of Poll fields to display.")] = None,
        user_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of User fields to display.")] = None,
        place_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of Place fields to display.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """User mention timeline by User ID

        Returns Tweet objects that mention username associated to the provided User ID

        :param id: The ID of the User to lookup. (required)
        :type id: str
        :param since_id: The minimum Tweet ID to be included in the result set. This parameter takes precedence over start_time if both are specified.
        :type since_id: str
        :param until_id: The maximum Tweet ID to be included in the result set. This parameter takes precedence over end_time if both are specified.
        :type until_id: str
        :param max_results: The maximum number of results.
        :type max_results: int
        :param pagination_token: This parameter is used to get the next 'page' of results.
        :type pagination_token: str
        :param start_time: YYYY-MM-DDTHH:mm:ssZ. The earliest UTC timestamp from which the Tweets will be provided. The since_id parameter takes precedence if it is also specified.
        :type start_time: datetime
        :param end_time: YYYY-MM-DDTHH:mm:ssZ. The latest UTC timestamp to which the Tweets will be provided. The until_id parameter takes precedence if it is also specified.
        :type end_time: datetime
        :param tweet_fields: A comma separated list of Tweet fields to display.
        :type tweet_fields: List[str]
        :param expansions: A comma separated list of fields to expand.
        :type expansions: List[str]
        :param media_fields: A comma separated list of Media fields to display.
        :type media_fields: List[str]
        :param poll_fields: A comma separated list of Poll fields to display.
        :type poll_fields: List[str]
        :param user_fields: A comma separated list of User fields to display.
        :type user_fields: List[str]
        :param place_fields: A comma separated list of Place fields to display.
        :type place_fields: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._users_id_mentions_serialize(
            id=id,
            since_id=since_id,
            until_id=until_id,
            max_results=max_results,
            pagination_token=pagination_token,
            start_time=start_time,
            end_time=end_time,
            tweet_fields=tweet_fields,
            expansions=expansions,
            media_fields=media_fields,
            poll_fields=poll_fields,
            user_fields=user_fields,
            place_fields=place_fields,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Get2UsersIdMentionsResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _users_id_mentions_serialize(
        self,
        id,
        since_id,
        until_id,
        max_results,
        pagination_token,
        start_time,
        end_time,
        tweet_fields,
        expansions,
        media_fields,
        poll_fields,
        user_fields,
        place_fields,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'tweet.fields': 'csv',
            'expansions': 'csv',
            'media.fields': 'csv',
            'poll.fields': 'csv',
            'user.fields': 'csv',
            'place.fields': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        if since_id is not None:
            
            _query_params.append(('since_id', since_id))
            
        if until_id is not None:
            
            _query_params.append(('until_id', until_id))
            
        if max_results is not None:
            
            _query_params.append(('max_results', max_results))
            
        if pagination_token is not None:
            
            _query_params.append(('pagination_token', pagination_token))
            
        if start_time is not None:
            if isinstance(start_time, datetime):
                _query_params.append(
                    (
                        'start_time',
                        start_time.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('start_time', start_time))
            
        if end_time is not None:
            if isinstance(end_time, datetime):
                _query_params.append(
                    (
                        'end_time',
                        end_time.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('end_time', end_time))
            
        if tweet_fields is not None:
            
            _query_params.append(('tweet.fields', tweet_fields))
            
        if expansions is not None:
            
            _query_params.append(('expansions', expansions))
            
        if media_fields is not None:
            
            _query_params.append(('media.fields', media_fields))
            
        if poll_fields is not None:
            
            _query_params.append(('poll.fields', poll_fields))
            
        if user_fields is not None:
            
            _query_params.append(('user.fields', user_fields))
            
        if place_fields is not None:
            
            _query_params.append(('place.fields', place_fields))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json', 
                    'application/problem+json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'OAuth2UserToken', 
            'BearerToken', 
            'UserToken'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/2/users/{id}/mentions',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def users_id_retweets(
        self,
        id: Annotated[StrictStr, Field(description="The ID of the authenticated source User that is requesting to retweet the Tweet.")],
        users_retweets_create_request: Optional[UsersRetweetsCreateRequest] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> UsersRetweetsCreateResponse:
        """Causes the User (in the path) to retweet the specified Tweet.

        Causes the User (in the path) to retweet the specified Tweet. The User in the path must match the User context authorizing the request.

        :param id: The ID of the authenticated source User that is requesting to retweet the Tweet. (required)
        :type id: str
        :param users_retweets_create_request:
        :type users_retweets_create_request: UsersRetweetsCreateRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._users_id_retweets_serialize(
            id=id,
            users_retweets_create_request=users_retweets_create_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "UsersRetweetsCreateResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def users_id_retweets_with_http_info(
        self,
        id: Annotated[StrictStr, Field(description="The ID of the authenticated source User that is requesting to retweet the Tweet.")],
        users_retweets_create_request: Optional[UsersRetweetsCreateRequest] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[UsersRetweetsCreateResponse]:
        """Causes the User (in the path) to retweet the specified Tweet.

        Causes the User (in the path) to retweet the specified Tweet. The User in the path must match the User context authorizing the request.

        :param id: The ID of the authenticated source User that is requesting to retweet the Tweet. (required)
        :type id: str
        :param users_retweets_create_request:
        :type users_retweets_create_request: UsersRetweetsCreateRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._users_id_retweets_serialize(
            id=id,
            users_retweets_create_request=users_retweets_create_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "UsersRetweetsCreateResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def users_id_retweets_without_preload_content(
        self,
        id: Annotated[StrictStr, Field(description="The ID of the authenticated source User that is requesting to retweet the Tweet.")],
        users_retweets_create_request: Optional[UsersRetweetsCreateRequest] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Causes the User (in the path) to retweet the specified Tweet.

        Causes the User (in the path) to retweet the specified Tweet. The User in the path must match the User context authorizing the request.

        :param id: The ID of the authenticated source User that is requesting to retweet the Tweet. (required)
        :type id: str
        :param users_retweets_create_request:
        :type users_retweets_create_request: UsersRetweetsCreateRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._users_id_retweets_serialize(
            id=id,
            users_retweets_create_request=users_retweets_create_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "UsersRetweetsCreateResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _users_id_retweets_serialize(
        self,
        id,
        users_retweets_create_request,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if users_retweets_create_request is not None:
            _body_params = users_retweets_create_request


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json', 
                    'application/problem+json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'OAuth2UserToken', 
            'UserToken'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/2/users/{id}/retweets',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def users_id_timeline(
        self,
        id: Annotated[StrictStr, Field(description="The ID of the authenticated source User to list Reverse Chronological Timeline Tweets of.")],
        since_id: Annotated[Optional[Annotated[str, Field(strict=True)]], Field(description="The minimum Tweet ID to be included in the result set. This parameter takes precedence over start_time if both are specified.")] = None,
        until_id: Annotated[Optional[Annotated[str, Field(strict=True)]], Field(description="The maximum Tweet ID to be included in the result set. This parameter takes precedence over end_time if both are specified.")] = None,
        max_results: Annotated[Optional[Annotated[int, Field(le=100, strict=True, ge=1)]], Field(description="The maximum number of results.")] = None,
        pagination_token: Annotated[Optional[Annotated[str, Field(min_length=1, strict=True)]], Field(description="This parameter is used to get the next 'page' of results.")] = None,
        exclude: Annotated[Optional[List[StrictStr]], Field(description="The set of entities to exclude (e.g. 'replies' or 'retweets').")] = None,
        start_time: Annotated[Optional[datetime], Field(description="YYYY-MM-DDTHH:mm:ssZ. The earliest UTC timestamp from which the Tweets will be provided. The since_id parameter takes precedence if it is also specified.")] = None,
        end_time: Annotated[Optional[datetime], Field(description="YYYY-MM-DDTHH:mm:ssZ. The latest UTC timestamp to which the Tweets will be provided. The until_id parameter takes precedence if it is also specified.")] = None,
        tweet_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of Tweet fields to display.")] = None,
        expansions: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of fields to expand.")] = None,
        media_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of Media fields to display.")] = None,
        poll_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of Poll fields to display.")] = None,
        user_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of User fields to display.")] = None,
        place_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of Place fields to display.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> Get2UsersIdTimelinesReverseChronologicalResponse:
        """User home timeline by User ID

        Returns Tweet objects that appears in the provided User ID's home timeline

        :param id: The ID of the authenticated source User to list Reverse Chronological Timeline Tweets of. (required)
        :type id: str
        :param since_id: The minimum Tweet ID to be included in the result set. This parameter takes precedence over start_time if both are specified.
        :type since_id: str
        :param until_id: The maximum Tweet ID to be included in the result set. This parameter takes precedence over end_time if both are specified.
        :type until_id: str
        :param max_results: The maximum number of results.
        :type max_results: int
        :param pagination_token: This parameter is used to get the next 'page' of results.
        :type pagination_token: str
        :param exclude: The set of entities to exclude (e.g. 'replies' or 'retweets').
        :type exclude: List[str]
        :param start_time: YYYY-MM-DDTHH:mm:ssZ. The earliest UTC timestamp from which the Tweets will be provided. The since_id parameter takes precedence if it is also specified.
        :type start_time: datetime
        :param end_time: YYYY-MM-DDTHH:mm:ssZ. The latest UTC timestamp to which the Tweets will be provided. The until_id parameter takes precedence if it is also specified.
        :type end_time: datetime
        :param tweet_fields: A comma separated list of Tweet fields to display.
        :type tweet_fields: List[str]
        :param expansions: A comma separated list of fields to expand.
        :type expansions: List[str]
        :param media_fields: A comma separated list of Media fields to display.
        :type media_fields: List[str]
        :param poll_fields: A comma separated list of Poll fields to display.
        :type poll_fields: List[str]
        :param user_fields: A comma separated list of User fields to display.
        :type user_fields: List[str]
        :param place_fields: A comma separated list of Place fields to display.
        :type place_fields: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._users_id_timeline_serialize(
            id=id,
            since_id=since_id,
            until_id=until_id,
            max_results=max_results,
            pagination_token=pagination_token,
            exclude=exclude,
            start_time=start_time,
            end_time=end_time,
            tweet_fields=tweet_fields,
            expansions=expansions,
            media_fields=media_fields,
            poll_fields=poll_fields,
            user_fields=user_fields,
            place_fields=place_fields,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Get2UsersIdTimelinesReverseChronologicalResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def users_id_timeline_with_http_info(
        self,
        id: Annotated[StrictStr, Field(description="The ID of the authenticated source User to list Reverse Chronological Timeline Tweets of.")],
        since_id: Annotated[Optional[Annotated[str, Field(strict=True)]], Field(description="The minimum Tweet ID to be included in the result set. This parameter takes precedence over start_time if both are specified.")] = None,
        until_id: Annotated[Optional[Annotated[str, Field(strict=True)]], Field(description="The maximum Tweet ID to be included in the result set. This parameter takes precedence over end_time if both are specified.")] = None,
        max_results: Annotated[Optional[Annotated[int, Field(le=100, strict=True, ge=1)]], Field(description="The maximum number of results.")] = None,
        pagination_token: Annotated[Optional[Annotated[str, Field(min_length=1, strict=True)]], Field(description="This parameter is used to get the next 'page' of results.")] = None,
        exclude: Annotated[Optional[List[StrictStr]], Field(description="The set of entities to exclude (e.g. 'replies' or 'retweets').")] = None,
        start_time: Annotated[Optional[datetime], Field(description="YYYY-MM-DDTHH:mm:ssZ. The earliest UTC timestamp from which the Tweets will be provided. The since_id parameter takes precedence if it is also specified.")] = None,
        end_time: Annotated[Optional[datetime], Field(description="YYYY-MM-DDTHH:mm:ssZ. The latest UTC timestamp to which the Tweets will be provided. The until_id parameter takes precedence if it is also specified.")] = None,
        tweet_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of Tweet fields to display.")] = None,
        expansions: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of fields to expand.")] = None,
        media_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of Media fields to display.")] = None,
        poll_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of Poll fields to display.")] = None,
        user_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of User fields to display.")] = None,
        place_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of Place fields to display.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[Get2UsersIdTimelinesReverseChronologicalResponse]:
        """User home timeline by User ID

        Returns Tweet objects that appears in the provided User ID's home timeline

        :param id: The ID of the authenticated source User to list Reverse Chronological Timeline Tweets of. (required)
        :type id: str
        :param since_id: The minimum Tweet ID to be included in the result set. This parameter takes precedence over start_time if both are specified.
        :type since_id: str
        :param until_id: The maximum Tweet ID to be included in the result set. This parameter takes precedence over end_time if both are specified.
        :type until_id: str
        :param max_results: The maximum number of results.
        :type max_results: int
        :param pagination_token: This parameter is used to get the next 'page' of results.
        :type pagination_token: str
        :param exclude: The set of entities to exclude (e.g. 'replies' or 'retweets').
        :type exclude: List[str]
        :param start_time: YYYY-MM-DDTHH:mm:ssZ. The earliest UTC timestamp from which the Tweets will be provided. The since_id parameter takes precedence if it is also specified.
        :type start_time: datetime
        :param end_time: YYYY-MM-DDTHH:mm:ssZ. The latest UTC timestamp to which the Tweets will be provided. The until_id parameter takes precedence if it is also specified.
        :type end_time: datetime
        :param tweet_fields: A comma separated list of Tweet fields to display.
        :type tweet_fields: List[str]
        :param expansions: A comma separated list of fields to expand.
        :type expansions: List[str]
        :param media_fields: A comma separated list of Media fields to display.
        :type media_fields: List[str]
        :param poll_fields: A comma separated list of Poll fields to display.
        :type poll_fields: List[str]
        :param user_fields: A comma separated list of User fields to display.
        :type user_fields: List[str]
        :param place_fields: A comma separated list of Place fields to display.
        :type place_fields: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._users_id_timeline_serialize(
            id=id,
            since_id=since_id,
            until_id=until_id,
            max_results=max_results,
            pagination_token=pagination_token,
            exclude=exclude,
            start_time=start_time,
            end_time=end_time,
            tweet_fields=tweet_fields,
            expansions=expansions,
            media_fields=media_fields,
            poll_fields=poll_fields,
            user_fields=user_fields,
            place_fields=place_fields,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Get2UsersIdTimelinesReverseChronologicalResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def users_id_timeline_without_preload_content(
        self,
        id: Annotated[StrictStr, Field(description="The ID of the authenticated source User to list Reverse Chronological Timeline Tweets of.")],
        since_id: Annotated[Optional[Annotated[str, Field(strict=True)]], Field(description="The minimum Tweet ID to be included in the result set. This parameter takes precedence over start_time if both are specified.")] = None,
        until_id: Annotated[Optional[Annotated[str, Field(strict=True)]], Field(description="The maximum Tweet ID to be included in the result set. This parameter takes precedence over end_time if both are specified.")] = None,
        max_results: Annotated[Optional[Annotated[int, Field(le=100, strict=True, ge=1)]], Field(description="The maximum number of results.")] = None,
        pagination_token: Annotated[Optional[Annotated[str, Field(min_length=1, strict=True)]], Field(description="This parameter is used to get the next 'page' of results.")] = None,
        exclude: Annotated[Optional[List[StrictStr]], Field(description="The set of entities to exclude (e.g. 'replies' or 'retweets').")] = None,
        start_time: Annotated[Optional[datetime], Field(description="YYYY-MM-DDTHH:mm:ssZ. The earliest UTC timestamp from which the Tweets will be provided. The since_id parameter takes precedence if it is also specified.")] = None,
        end_time: Annotated[Optional[datetime], Field(description="YYYY-MM-DDTHH:mm:ssZ. The latest UTC timestamp to which the Tweets will be provided. The until_id parameter takes precedence if it is also specified.")] = None,
        tweet_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of Tweet fields to display.")] = None,
        expansions: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of fields to expand.")] = None,
        media_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of Media fields to display.")] = None,
        poll_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of Poll fields to display.")] = None,
        user_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of User fields to display.")] = None,
        place_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of Place fields to display.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """User home timeline by User ID

        Returns Tweet objects that appears in the provided User ID's home timeline

        :param id: The ID of the authenticated source User to list Reverse Chronological Timeline Tweets of. (required)
        :type id: str
        :param since_id: The minimum Tweet ID to be included in the result set. This parameter takes precedence over start_time if both are specified.
        :type since_id: str
        :param until_id: The maximum Tweet ID to be included in the result set. This parameter takes precedence over end_time if both are specified.
        :type until_id: str
        :param max_results: The maximum number of results.
        :type max_results: int
        :param pagination_token: This parameter is used to get the next 'page' of results.
        :type pagination_token: str
        :param exclude: The set of entities to exclude (e.g. 'replies' or 'retweets').
        :type exclude: List[str]
        :param start_time: YYYY-MM-DDTHH:mm:ssZ. The earliest UTC timestamp from which the Tweets will be provided. The since_id parameter takes precedence if it is also specified.
        :type start_time: datetime
        :param end_time: YYYY-MM-DDTHH:mm:ssZ. The latest UTC timestamp to which the Tweets will be provided. The until_id parameter takes precedence if it is also specified.
        :type end_time: datetime
        :param tweet_fields: A comma separated list of Tweet fields to display.
        :type tweet_fields: List[str]
        :param expansions: A comma separated list of fields to expand.
        :type expansions: List[str]
        :param media_fields: A comma separated list of Media fields to display.
        :type media_fields: List[str]
        :param poll_fields: A comma separated list of Poll fields to display.
        :type poll_fields: List[str]
        :param user_fields: A comma separated list of User fields to display.
        :type user_fields: List[str]
        :param place_fields: A comma separated list of Place fields to display.
        :type place_fields: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._users_id_timeline_serialize(
            id=id,
            since_id=since_id,
            until_id=until_id,
            max_results=max_results,
            pagination_token=pagination_token,
            exclude=exclude,
            start_time=start_time,
            end_time=end_time,
            tweet_fields=tweet_fields,
            expansions=expansions,
            media_fields=media_fields,
            poll_fields=poll_fields,
            user_fields=user_fields,
            place_fields=place_fields,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Get2UsersIdTimelinesReverseChronologicalResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _users_id_timeline_serialize(
        self,
        id,
        since_id,
        until_id,
        max_results,
        pagination_token,
        exclude,
        start_time,
        end_time,
        tweet_fields,
        expansions,
        media_fields,
        poll_fields,
        user_fields,
        place_fields,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'exclude': 'csv',
            'tweet.fields': 'csv',
            'expansions': 'csv',
            'media.fields': 'csv',
            'poll.fields': 'csv',
            'user.fields': 'csv',
            'place.fields': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        if since_id is not None:
            
            _query_params.append(('since_id', since_id))
            
        if until_id is not None:
            
            _query_params.append(('until_id', until_id))
            
        if max_results is not None:
            
            _query_params.append(('max_results', max_results))
            
        if pagination_token is not None:
            
            _query_params.append(('pagination_token', pagination_token))
            
        if exclude is not None:
            
            _query_params.append(('exclude', exclude))
            
        if start_time is not None:
            if isinstance(start_time, datetime):
                _query_params.append(
                    (
                        'start_time',
                        start_time.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('start_time', start_time))
            
        if end_time is not None:
            if isinstance(end_time, datetime):
                _query_params.append(
                    (
                        'end_time',
                        end_time.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('end_time', end_time))
            
        if tweet_fields is not None:
            
            _query_params.append(('tweet.fields', tweet_fields))
            
        if expansions is not None:
            
            _query_params.append(('expansions', expansions))
            
        if media_fields is not None:
            
            _query_params.append(('media.fields', media_fields))
            
        if poll_fields is not None:
            
            _query_params.append(('poll.fields', poll_fields))
            
        if user_fields is not None:
            
            _query_params.append(('user.fields', user_fields))
            
        if place_fields is not None:
            
            _query_params.append(('place.fields', place_fields))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json', 
                    'application/problem+json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'OAuth2UserToken', 
            'UserToken'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/2/users/{id}/timelines/reverse_chronological',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def users_id_tweets(
        self,
        id: Annotated[str, Field(strict=True, description="The ID of the User to lookup.")],
        since_id: Annotated[Optional[Annotated[str, Field(strict=True)]], Field(description="The minimum Tweet ID to be included in the result set. This parameter takes precedence over start_time if both are specified.")] = None,
        until_id: Annotated[Optional[Annotated[str, Field(strict=True)]], Field(description="The maximum Tweet ID to be included in the result set. This parameter takes precedence over end_time if both are specified.")] = None,
        max_results: Annotated[Optional[Annotated[int, Field(le=100, strict=True, ge=5)]], Field(description="The maximum number of results.")] = None,
        pagination_token: Annotated[Optional[Annotated[str, Field(min_length=1, strict=True)]], Field(description="This parameter is used to get the next 'page' of results.")] = None,
        exclude: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="The set of entities to exclude (e.g. 'replies' or 'retweets').")] = None,
        start_time: Annotated[Optional[datetime], Field(description="YYYY-MM-DDTHH:mm:ssZ. The earliest UTC timestamp from which the Tweets will be provided. The since_id parameter takes precedence if it is also specified.")] = None,
        end_time: Annotated[Optional[datetime], Field(description="YYYY-MM-DDTHH:mm:ssZ. The latest UTC timestamp to which the Tweets will be provided. The until_id parameter takes precedence if it is also specified.")] = None,
        tweet_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of Tweet fields to display.")] = None,
        expansions: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of fields to expand.")] = None,
        media_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of Media fields to display.")] = None,
        poll_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of Poll fields to display.")] = None,
        user_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of User fields to display.")] = None,
        place_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of Place fields to display.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> Get2UsersIdTweetsResponse:
        """User Tweets timeline by User ID

        Returns a list of Tweets authored by the provided User ID

        :param id: The ID of the User to lookup. (required)
        :type id: str
        :param since_id: The minimum Tweet ID to be included in the result set. This parameter takes precedence over start_time if both are specified.
        :type since_id: str
        :param until_id: The maximum Tweet ID to be included in the result set. This parameter takes precedence over end_time if both are specified.
        :type until_id: str
        :param max_results: The maximum number of results.
        :type max_results: int
        :param pagination_token: This parameter is used to get the next 'page' of results.
        :type pagination_token: str
        :param exclude: The set of entities to exclude (e.g. 'replies' or 'retweets').
        :type exclude: List[str]
        :param start_time: YYYY-MM-DDTHH:mm:ssZ. The earliest UTC timestamp from which the Tweets will be provided. The since_id parameter takes precedence if it is also specified.
        :type start_time: datetime
        :param end_time: YYYY-MM-DDTHH:mm:ssZ. The latest UTC timestamp to which the Tweets will be provided. The until_id parameter takes precedence if it is also specified.
        :type end_time: datetime
        :param tweet_fields: A comma separated list of Tweet fields to display.
        :type tweet_fields: List[str]
        :param expansions: A comma separated list of fields to expand.
        :type expansions: List[str]
        :param media_fields: A comma separated list of Media fields to display.
        :type media_fields: List[str]
        :param poll_fields: A comma separated list of Poll fields to display.
        :type poll_fields: List[str]
        :param user_fields: A comma separated list of User fields to display.
        :type user_fields: List[str]
        :param place_fields: A comma separated list of Place fields to display.
        :type place_fields: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._users_id_tweets_serialize(
            id=id,
            since_id=since_id,
            until_id=until_id,
            max_results=max_results,
            pagination_token=pagination_token,
            exclude=exclude,
            start_time=start_time,
            end_time=end_time,
            tweet_fields=tweet_fields,
            expansions=expansions,
            media_fields=media_fields,
            poll_fields=poll_fields,
            user_fields=user_fields,
            place_fields=place_fields,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Get2UsersIdTweetsResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def users_id_tweets_with_http_info(
        self,
        id: Annotated[str, Field(strict=True, description="The ID of the User to lookup.")],
        since_id: Annotated[Optional[Annotated[str, Field(strict=True)]], Field(description="The minimum Tweet ID to be included in the result set. This parameter takes precedence over start_time if both are specified.")] = None,
        until_id: Annotated[Optional[Annotated[str, Field(strict=True)]], Field(description="The maximum Tweet ID to be included in the result set. This parameter takes precedence over end_time if both are specified.")] = None,
        max_results: Annotated[Optional[Annotated[int, Field(le=100, strict=True, ge=5)]], Field(description="The maximum number of results.")] = None,
        pagination_token: Annotated[Optional[Annotated[str, Field(min_length=1, strict=True)]], Field(description="This parameter is used to get the next 'page' of results.")] = None,
        exclude: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="The set of entities to exclude (e.g. 'replies' or 'retweets').")] = None,
        start_time: Annotated[Optional[datetime], Field(description="YYYY-MM-DDTHH:mm:ssZ. The earliest UTC timestamp from which the Tweets will be provided. The since_id parameter takes precedence if it is also specified.")] = None,
        end_time: Annotated[Optional[datetime], Field(description="YYYY-MM-DDTHH:mm:ssZ. The latest UTC timestamp to which the Tweets will be provided. The until_id parameter takes precedence if it is also specified.")] = None,
        tweet_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of Tweet fields to display.")] = None,
        expansions: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of fields to expand.")] = None,
        media_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of Media fields to display.")] = None,
        poll_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of Poll fields to display.")] = None,
        user_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of User fields to display.")] = None,
        place_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of Place fields to display.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[Get2UsersIdTweetsResponse]:
        """User Tweets timeline by User ID

        Returns a list of Tweets authored by the provided User ID

        :param id: The ID of the User to lookup. (required)
        :type id: str
        :param since_id: The minimum Tweet ID to be included in the result set. This parameter takes precedence over start_time if both are specified.
        :type since_id: str
        :param until_id: The maximum Tweet ID to be included in the result set. This parameter takes precedence over end_time if both are specified.
        :type until_id: str
        :param max_results: The maximum number of results.
        :type max_results: int
        :param pagination_token: This parameter is used to get the next 'page' of results.
        :type pagination_token: str
        :param exclude: The set of entities to exclude (e.g. 'replies' or 'retweets').
        :type exclude: List[str]
        :param start_time: YYYY-MM-DDTHH:mm:ssZ. The earliest UTC timestamp from which the Tweets will be provided. The since_id parameter takes precedence if it is also specified.
        :type start_time: datetime
        :param end_time: YYYY-MM-DDTHH:mm:ssZ. The latest UTC timestamp to which the Tweets will be provided. The until_id parameter takes precedence if it is also specified.
        :type end_time: datetime
        :param tweet_fields: A comma separated list of Tweet fields to display.
        :type tweet_fields: List[str]
        :param expansions: A comma separated list of fields to expand.
        :type expansions: List[str]
        :param media_fields: A comma separated list of Media fields to display.
        :type media_fields: List[str]
        :param poll_fields: A comma separated list of Poll fields to display.
        :type poll_fields: List[str]
        :param user_fields: A comma separated list of User fields to display.
        :type user_fields: List[str]
        :param place_fields: A comma separated list of Place fields to display.
        :type place_fields: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._users_id_tweets_serialize(
            id=id,
            since_id=since_id,
            until_id=until_id,
            max_results=max_results,
            pagination_token=pagination_token,
            exclude=exclude,
            start_time=start_time,
            end_time=end_time,
            tweet_fields=tweet_fields,
            expansions=expansions,
            media_fields=media_fields,
            poll_fields=poll_fields,
            user_fields=user_fields,
            place_fields=place_fields,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Get2UsersIdTweetsResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def users_id_tweets_without_preload_content(
        self,
        id: Annotated[str, Field(strict=True, description="The ID of the User to lookup.")],
        since_id: Annotated[Optional[Annotated[str, Field(strict=True)]], Field(description="The minimum Tweet ID to be included in the result set. This parameter takes precedence over start_time if both are specified.")] = None,
        until_id: Annotated[Optional[Annotated[str, Field(strict=True)]], Field(description="The maximum Tweet ID to be included in the result set. This parameter takes precedence over end_time if both are specified.")] = None,
        max_results: Annotated[Optional[Annotated[int, Field(le=100, strict=True, ge=5)]], Field(description="The maximum number of results.")] = None,
        pagination_token: Annotated[Optional[Annotated[str, Field(min_length=1, strict=True)]], Field(description="This parameter is used to get the next 'page' of results.")] = None,
        exclude: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="The set of entities to exclude (e.g. 'replies' or 'retweets').")] = None,
        start_time: Annotated[Optional[datetime], Field(description="YYYY-MM-DDTHH:mm:ssZ. The earliest UTC timestamp from which the Tweets will be provided. The since_id parameter takes precedence if it is also specified.")] = None,
        end_time: Annotated[Optional[datetime], Field(description="YYYY-MM-DDTHH:mm:ssZ. The latest UTC timestamp to which the Tweets will be provided. The until_id parameter takes precedence if it is also specified.")] = None,
        tweet_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of Tweet fields to display.")] = None,
        expansions: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of fields to expand.")] = None,
        media_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of Media fields to display.")] = None,
        poll_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of Poll fields to display.")] = None,
        user_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of User fields to display.")] = None,
        place_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of Place fields to display.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """User Tweets timeline by User ID

        Returns a list of Tweets authored by the provided User ID

        :param id: The ID of the User to lookup. (required)
        :type id: str
        :param since_id: The minimum Tweet ID to be included in the result set. This parameter takes precedence over start_time if both are specified.
        :type since_id: str
        :param until_id: The maximum Tweet ID to be included in the result set. This parameter takes precedence over end_time if both are specified.
        :type until_id: str
        :param max_results: The maximum number of results.
        :type max_results: int
        :param pagination_token: This parameter is used to get the next 'page' of results.
        :type pagination_token: str
        :param exclude: The set of entities to exclude (e.g. 'replies' or 'retweets').
        :type exclude: List[str]
        :param start_time: YYYY-MM-DDTHH:mm:ssZ. The earliest UTC timestamp from which the Tweets will be provided. The since_id parameter takes precedence if it is also specified.
        :type start_time: datetime
        :param end_time: YYYY-MM-DDTHH:mm:ssZ. The latest UTC timestamp to which the Tweets will be provided. The until_id parameter takes precedence if it is also specified.
        :type end_time: datetime
        :param tweet_fields: A comma separated list of Tweet fields to display.
        :type tweet_fields: List[str]
        :param expansions: A comma separated list of fields to expand.
        :type expansions: List[str]
        :param media_fields: A comma separated list of Media fields to display.
        :type media_fields: List[str]
        :param poll_fields: A comma separated list of Poll fields to display.
        :type poll_fields: List[str]
        :param user_fields: A comma separated list of User fields to display.
        :type user_fields: List[str]
        :param place_fields: A comma separated list of Place fields to display.
        :type place_fields: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._users_id_tweets_serialize(
            id=id,
            since_id=since_id,
            until_id=until_id,
            max_results=max_results,
            pagination_token=pagination_token,
            exclude=exclude,
            start_time=start_time,
            end_time=end_time,
            tweet_fields=tweet_fields,
            expansions=expansions,
            media_fields=media_fields,
            poll_fields=poll_fields,
            user_fields=user_fields,
            place_fields=place_fields,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Get2UsersIdTweetsResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _users_id_tweets_serialize(
        self,
        id,
        since_id,
        until_id,
        max_results,
        pagination_token,
        exclude,
        start_time,
        end_time,
        tweet_fields,
        expansions,
        media_fields,
        poll_fields,
        user_fields,
        place_fields,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'exclude': 'csv',
            'tweet.fields': 'csv',
            'expansions': 'csv',
            'media.fields': 'csv',
            'poll.fields': 'csv',
            'user.fields': 'csv',
            'place.fields': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        if since_id is not None:
            
            _query_params.append(('since_id', since_id))
            
        if until_id is not None:
            
            _query_params.append(('until_id', until_id))
            
        if max_results is not None:
            
            _query_params.append(('max_results', max_results))
            
        if pagination_token is not None:
            
            _query_params.append(('pagination_token', pagination_token))
            
        if exclude is not None:
            
            _query_params.append(('exclude', exclude))
            
        if start_time is not None:
            if isinstance(start_time, datetime):
                _query_params.append(
                    (
                        'start_time',
                        start_time.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('start_time', start_time))
            
        if end_time is not None:
            if isinstance(end_time, datetime):
                _query_params.append(
                    (
                        'end_time',
                        end_time.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('end_time', end_time))
            
        if tweet_fields is not None:
            
            _query_params.append(('tweet.fields', tweet_fields))
            
        if expansions is not None:
            
            _query_params.append(('expansions', expansions))
            
        if media_fields is not None:
            
            _query_params.append(('media.fields', media_fields))
            
        if poll_fields is not None:
            
            _query_params.append(('poll.fields', poll_fields))
            
        if user_fields is not None:
            
            _query_params.append(('user.fields', user_fields))
            
        if place_fields is not None:
            
            _query_params.append(('place.fields', place_fields))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json', 
                    'application/problem+json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'OAuth2UserToken', 
            'BearerToken', 
            'UserToken'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/2/users/{id}/tweets',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def users_id_unlike(
        self,
        id: Annotated[StrictStr, Field(description="The ID of the authenticated source User that is requesting to unlike the Tweet.")],
        tweet_id: Annotated[str, Field(strict=True, description="The ID of the Tweet that the User is requesting to unlike.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> UsersLikesDeleteResponse:
        """Causes the User (in the path) to unlike the specified Tweet

        Causes the User (in the path) to unlike the specified Tweet. The User must match the User context authorizing the request

        :param id: The ID of the authenticated source User that is requesting to unlike the Tweet. (required)
        :type id: str
        :param tweet_id: The ID of the Tweet that the User is requesting to unlike. (required)
        :type tweet_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._users_id_unlike_serialize(
            id=id,
            tweet_id=tweet_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "UsersLikesDeleteResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def users_id_unlike_with_http_info(
        self,
        id: Annotated[StrictStr, Field(description="The ID of the authenticated source User that is requesting to unlike the Tweet.")],
        tweet_id: Annotated[str, Field(strict=True, description="The ID of the Tweet that the User is requesting to unlike.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[UsersLikesDeleteResponse]:
        """Causes the User (in the path) to unlike the specified Tweet

        Causes the User (in the path) to unlike the specified Tweet. The User must match the User context authorizing the request

        :param id: The ID of the authenticated source User that is requesting to unlike the Tweet. (required)
        :type id: str
        :param tweet_id: The ID of the Tweet that the User is requesting to unlike. (required)
        :type tweet_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._users_id_unlike_serialize(
            id=id,
            tweet_id=tweet_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "UsersLikesDeleteResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def users_id_unlike_without_preload_content(
        self,
        id: Annotated[StrictStr, Field(description="The ID of the authenticated source User that is requesting to unlike the Tweet.")],
        tweet_id: Annotated[str, Field(strict=True, description="The ID of the Tweet that the User is requesting to unlike.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Causes the User (in the path) to unlike the specified Tweet

        Causes the User (in the path) to unlike the specified Tweet. The User must match the User context authorizing the request

        :param id: The ID of the authenticated source User that is requesting to unlike the Tweet. (required)
        :type id: str
        :param tweet_id: The ID of the Tweet that the User is requesting to unlike. (required)
        :type tweet_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._users_id_unlike_serialize(
            id=id,
            tweet_id=tweet_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "UsersLikesDeleteResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _users_id_unlike_serialize(
        self,
        id,
        tweet_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        if tweet_id is not None:
            _path_params['tweet_id'] = tweet_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json', 
                    'application/problem+json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'OAuth2UserToken', 
            'UserToken'
        ]

        return self.api_client.param_serialize(
            method='DELETE',
            resource_path='/2/users/{id}/likes/{tweet_id}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def users_id_unretweets(
        self,
        id: Annotated[StrictStr, Field(description="The ID of the authenticated source User that is requesting to retweet the Tweet.")],
        source_tweet_id: Annotated[str, Field(strict=True, description="The ID of the Tweet that the User is requesting to unretweet.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> UsersRetweetsDeleteResponse:
        """Causes the User (in the path) to unretweet the specified Tweet

        Causes the User (in the path) to unretweet the specified Tweet. The User must match the User context authorizing the request

        :param id: The ID of the authenticated source User that is requesting to retweet the Tweet. (required)
        :type id: str
        :param source_tweet_id: The ID of the Tweet that the User is requesting to unretweet. (required)
        :type source_tweet_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._users_id_unretweets_serialize(
            id=id,
            source_tweet_id=source_tweet_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "UsersRetweetsDeleteResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def users_id_unretweets_with_http_info(
        self,
        id: Annotated[StrictStr, Field(description="The ID of the authenticated source User that is requesting to retweet the Tweet.")],
        source_tweet_id: Annotated[str, Field(strict=True, description="The ID of the Tweet that the User is requesting to unretweet.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[UsersRetweetsDeleteResponse]:
        """Causes the User (in the path) to unretweet the specified Tweet

        Causes the User (in the path) to unretweet the specified Tweet. The User must match the User context authorizing the request

        :param id: The ID of the authenticated source User that is requesting to retweet the Tweet. (required)
        :type id: str
        :param source_tweet_id: The ID of the Tweet that the User is requesting to unretweet. (required)
        :type source_tweet_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._users_id_unretweets_serialize(
            id=id,
            source_tweet_id=source_tweet_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "UsersRetweetsDeleteResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def users_id_unretweets_without_preload_content(
        self,
        id: Annotated[StrictStr, Field(description="The ID of the authenticated source User that is requesting to retweet the Tweet.")],
        source_tweet_id: Annotated[str, Field(strict=True, description="The ID of the Tweet that the User is requesting to unretweet.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Causes the User (in the path) to unretweet the specified Tweet

        Causes the User (in the path) to unretweet the specified Tweet. The User must match the User context authorizing the request

        :param id: The ID of the authenticated source User that is requesting to retweet the Tweet. (required)
        :type id: str
        :param source_tweet_id: The ID of the Tweet that the User is requesting to unretweet. (required)
        :type source_tweet_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._users_id_unretweets_serialize(
            id=id,
            source_tweet_id=source_tweet_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "UsersRetweetsDeleteResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _users_id_unretweets_serialize(
        self,
        id,
        source_tweet_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        if source_tweet_id is not None:
            _path_params['source_tweet_id'] = source_tweet_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json', 
                    'application/problem+json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'OAuth2UserToken', 
            'UserToken'
        ]

        return self.api_client.param_serialize(
            method='DELETE',
            resource_path='/2/users/{id}/retweets/{source_tweet_id}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )


