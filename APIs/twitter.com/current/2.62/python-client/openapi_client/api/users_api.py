# coding: utf-8

"""
    Twitter API v2

    Twitter API v2 available endpoints

    The version of the OpenAPI document: 2.62
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501

import warnings
from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
from typing import Any, Dict, List, Optional, Tuple, Union
from typing_extensions import Annotated

from pydantic import Field, StrictStr, field_validator
from typing import List, Optional
from typing_extensions import Annotated
from openapi_client.models.block_user_mutation_response import BlockUserMutationResponse
from openapi_client.models.block_user_request import BlockUserRequest
from openapi_client.models.get2_lists_id_followers_response import Get2ListsIdFollowersResponse
from openapi_client.models.get2_lists_id_members_response import Get2ListsIdMembersResponse
from openapi_client.models.get2_tweets_id_liking_users_response import Get2TweetsIdLikingUsersResponse
from openapi_client.models.get2_tweets_id_retweeted_by_response import Get2TweetsIdRetweetedByResponse
from openapi_client.models.get2_users_by_response import Get2UsersByResponse
from openapi_client.models.get2_users_by_username_username_response import Get2UsersByUsernameUsernameResponse
from openapi_client.models.get2_users_id_blocking_response import Get2UsersIdBlockingResponse
from openapi_client.models.get2_users_id_followers_response import Get2UsersIdFollowersResponse
from openapi_client.models.get2_users_id_following_response import Get2UsersIdFollowingResponse
from openapi_client.models.get2_users_id_muting_response import Get2UsersIdMutingResponse
from openapi_client.models.get2_users_id_response import Get2UsersIdResponse
from openapi_client.models.get2_users_me_response import Get2UsersMeResponse
from openapi_client.models.get2_users_response import Get2UsersResponse
from openapi_client.models.mute_user_mutation_response import MuteUserMutationResponse
from openapi_client.models.mute_user_request import MuteUserRequest
from openapi_client.models.users_following_create_request import UsersFollowingCreateRequest
from openapi_client.models.users_following_create_response import UsersFollowingCreateResponse
from openapi_client.models.users_following_delete_response import UsersFollowingDeleteResponse

from openapi_client.api_client import ApiClient, RequestSerialized
from openapi_client.api_response import ApiResponse
from openapi_client.rest import RESTResponseType


class UsersApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client


    @validate_call
    def find_my_user(
        self,
        user_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of User fields to display.")] = None,
        expansions: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of fields to expand.")] = None,
        tweet_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of Tweet fields to display.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> Get2UsersMeResponse:
        """User lookup me

        This endpoint returns information about the requesting User.

        :param user_fields: A comma separated list of User fields to display.
        :type user_fields: List[str]
        :param expansions: A comma separated list of fields to expand.
        :type expansions: List[str]
        :param tweet_fields: A comma separated list of Tweet fields to display.
        :type tweet_fields: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._find_my_user_serialize(
            user_fields=user_fields,
            expansions=expansions,
            tweet_fields=tweet_fields,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Get2UsersMeResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def find_my_user_with_http_info(
        self,
        user_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of User fields to display.")] = None,
        expansions: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of fields to expand.")] = None,
        tweet_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of Tweet fields to display.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[Get2UsersMeResponse]:
        """User lookup me

        This endpoint returns information about the requesting User.

        :param user_fields: A comma separated list of User fields to display.
        :type user_fields: List[str]
        :param expansions: A comma separated list of fields to expand.
        :type expansions: List[str]
        :param tweet_fields: A comma separated list of Tweet fields to display.
        :type tweet_fields: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._find_my_user_serialize(
            user_fields=user_fields,
            expansions=expansions,
            tweet_fields=tweet_fields,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Get2UsersMeResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def find_my_user_without_preload_content(
        self,
        user_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of User fields to display.")] = None,
        expansions: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of fields to expand.")] = None,
        tweet_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of Tweet fields to display.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """User lookup me

        This endpoint returns information about the requesting User.

        :param user_fields: A comma separated list of User fields to display.
        :type user_fields: List[str]
        :param expansions: A comma separated list of fields to expand.
        :type expansions: List[str]
        :param tweet_fields: A comma separated list of Tweet fields to display.
        :type tweet_fields: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._find_my_user_serialize(
            user_fields=user_fields,
            expansions=expansions,
            tweet_fields=tweet_fields,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Get2UsersMeResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _find_my_user_serialize(
        self,
        user_fields,
        expansions,
        tweet_fields,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'user.fields': 'csv',
            'expansions': 'csv',
            'tweet.fields': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if user_fields is not None:
            
            _query_params.append(('user.fields', user_fields))
            
        if expansions is not None:
            
            _query_params.append(('expansions', expansions))
            
        if tweet_fields is not None:
            
            _query_params.append(('tweet.fields', tweet_fields))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json', 
                    'application/problem+json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'OAuth2UserToken', 
            'UserToken'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/2/users/me',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def find_user_by_id(
        self,
        id: Annotated[str, Field(strict=True, description="The ID of the User to lookup.")],
        user_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of User fields to display.")] = None,
        expansions: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of fields to expand.")] = None,
        tweet_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of Tweet fields to display.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> Get2UsersIdResponse:
        """User lookup by ID

        This endpoint returns information about a User. Specify User by ID.

        :param id: The ID of the User to lookup. (required)
        :type id: str
        :param user_fields: A comma separated list of User fields to display.
        :type user_fields: List[str]
        :param expansions: A comma separated list of fields to expand.
        :type expansions: List[str]
        :param tweet_fields: A comma separated list of Tweet fields to display.
        :type tweet_fields: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._find_user_by_id_serialize(
            id=id,
            user_fields=user_fields,
            expansions=expansions,
            tweet_fields=tweet_fields,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Get2UsersIdResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def find_user_by_id_with_http_info(
        self,
        id: Annotated[str, Field(strict=True, description="The ID of the User to lookup.")],
        user_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of User fields to display.")] = None,
        expansions: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of fields to expand.")] = None,
        tweet_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of Tweet fields to display.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[Get2UsersIdResponse]:
        """User lookup by ID

        This endpoint returns information about a User. Specify User by ID.

        :param id: The ID of the User to lookup. (required)
        :type id: str
        :param user_fields: A comma separated list of User fields to display.
        :type user_fields: List[str]
        :param expansions: A comma separated list of fields to expand.
        :type expansions: List[str]
        :param tweet_fields: A comma separated list of Tweet fields to display.
        :type tweet_fields: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._find_user_by_id_serialize(
            id=id,
            user_fields=user_fields,
            expansions=expansions,
            tweet_fields=tweet_fields,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Get2UsersIdResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def find_user_by_id_without_preload_content(
        self,
        id: Annotated[str, Field(strict=True, description="The ID of the User to lookup.")],
        user_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of User fields to display.")] = None,
        expansions: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of fields to expand.")] = None,
        tweet_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of Tweet fields to display.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """User lookup by ID

        This endpoint returns information about a User. Specify User by ID.

        :param id: The ID of the User to lookup. (required)
        :type id: str
        :param user_fields: A comma separated list of User fields to display.
        :type user_fields: List[str]
        :param expansions: A comma separated list of fields to expand.
        :type expansions: List[str]
        :param tweet_fields: A comma separated list of Tweet fields to display.
        :type tweet_fields: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._find_user_by_id_serialize(
            id=id,
            user_fields=user_fields,
            expansions=expansions,
            tweet_fields=tweet_fields,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Get2UsersIdResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _find_user_by_id_serialize(
        self,
        id,
        user_fields,
        expansions,
        tweet_fields,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'user.fields': 'csv',
            'expansions': 'csv',
            'tweet.fields': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        if user_fields is not None:
            
            _query_params.append(('user.fields', user_fields))
            
        if expansions is not None:
            
            _query_params.append(('expansions', expansions))
            
        if tweet_fields is not None:
            
            _query_params.append(('tweet.fields', tweet_fields))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json', 
                    'application/problem+json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'OAuth2UserToken', 
            'BearerToken', 
            'UserToken'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/2/users/{id}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def find_user_by_username(
        self,
        username: Annotated[str, Field(strict=True, description="A username.")],
        user_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of User fields to display.")] = None,
        expansions: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of fields to expand.")] = None,
        tweet_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of Tweet fields to display.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> Get2UsersByUsernameUsernameResponse:
        """User lookup by username

        This endpoint returns information about a User. Specify User by username.

        :param username: A username. (required)
        :type username: str
        :param user_fields: A comma separated list of User fields to display.
        :type user_fields: List[str]
        :param expansions: A comma separated list of fields to expand.
        :type expansions: List[str]
        :param tweet_fields: A comma separated list of Tweet fields to display.
        :type tweet_fields: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._find_user_by_username_serialize(
            username=username,
            user_fields=user_fields,
            expansions=expansions,
            tweet_fields=tweet_fields,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Get2UsersByUsernameUsernameResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def find_user_by_username_with_http_info(
        self,
        username: Annotated[str, Field(strict=True, description="A username.")],
        user_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of User fields to display.")] = None,
        expansions: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of fields to expand.")] = None,
        tweet_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of Tweet fields to display.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[Get2UsersByUsernameUsernameResponse]:
        """User lookup by username

        This endpoint returns information about a User. Specify User by username.

        :param username: A username. (required)
        :type username: str
        :param user_fields: A comma separated list of User fields to display.
        :type user_fields: List[str]
        :param expansions: A comma separated list of fields to expand.
        :type expansions: List[str]
        :param tweet_fields: A comma separated list of Tweet fields to display.
        :type tweet_fields: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._find_user_by_username_serialize(
            username=username,
            user_fields=user_fields,
            expansions=expansions,
            tweet_fields=tweet_fields,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Get2UsersByUsernameUsernameResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def find_user_by_username_without_preload_content(
        self,
        username: Annotated[str, Field(strict=True, description="A username.")],
        user_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of User fields to display.")] = None,
        expansions: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of fields to expand.")] = None,
        tweet_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of Tweet fields to display.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """User lookup by username

        This endpoint returns information about a User. Specify User by username.

        :param username: A username. (required)
        :type username: str
        :param user_fields: A comma separated list of User fields to display.
        :type user_fields: List[str]
        :param expansions: A comma separated list of fields to expand.
        :type expansions: List[str]
        :param tweet_fields: A comma separated list of Tweet fields to display.
        :type tweet_fields: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._find_user_by_username_serialize(
            username=username,
            user_fields=user_fields,
            expansions=expansions,
            tweet_fields=tweet_fields,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Get2UsersByUsernameUsernameResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _find_user_by_username_serialize(
        self,
        username,
        user_fields,
        expansions,
        tweet_fields,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'user.fields': 'csv',
            'expansions': 'csv',
            'tweet.fields': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if username is not None:
            _path_params['username'] = username
        # process the query parameters
        if user_fields is not None:
            
            _query_params.append(('user.fields', user_fields))
            
        if expansions is not None:
            
            _query_params.append(('expansions', expansions))
            
        if tweet_fields is not None:
            
            _query_params.append(('tweet.fields', tweet_fields))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json', 
                    'application/problem+json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'OAuth2UserToken', 
            'BearerToken', 
            'UserToken'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/2/users/by/username/{username}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def find_users_by_id(
        self,
        ids: Annotated[List[Annotated[str, Field(strict=True)]], Field(min_length=1, max_length=100, description="A list of User IDs, comma-separated. You can specify up to 100 IDs.")],
        user_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of User fields to display.")] = None,
        expansions: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of fields to expand.")] = None,
        tweet_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of Tweet fields to display.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> Get2UsersResponse:
        """User lookup by IDs

        This endpoint returns information about Users. Specify Users by their ID.

        :param ids: A list of User IDs, comma-separated. You can specify up to 100 IDs. (required)
        :type ids: List[str]
        :param user_fields: A comma separated list of User fields to display.
        :type user_fields: List[str]
        :param expansions: A comma separated list of fields to expand.
        :type expansions: List[str]
        :param tweet_fields: A comma separated list of Tweet fields to display.
        :type tweet_fields: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._find_users_by_id_serialize(
            ids=ids,
            user_fields=user_fields,
            expansions=expansions,
            tweet_fields=tweet_fields,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Get2UsersResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def find_users_by_id_with_http_info(
        self,
        ids: Annotated[List[Annotated[str, Field(strict=True)]], Field(min_length=1, max_length=100, description="A list of User IDs, comma-separated. You can specify up to 100 IDs.")],
        user_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of User fields to display.")] = None,
        expansions: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of fields to expand.")] = None,
        tweet_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of Tweet fields to display.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[Get2UsersResponse]:
        """User lookup by IDs

        This endpoint returns information about Users. Specify Users by their ID.

        :param ids: A list of User IDs, comma-separated. You can specify up to 100 IDs. (required)
        :type ids: List[str]
        :param user_fields: A comma separated list of User fields to display.
        :type user_fields: List[str]
        :param expansions: A comma separated list of fields to expand.
        :type expansions: List[str]
        :param tweet_fields: A comma separated list of Tweet fields to display.
        :type tweet_fields: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._find_users_by_id_serialize(
            ids=ids,
            user_fields=user_fields,
            expansions=expansions,
            tweet_fields=tweet_fields,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Get2UsersResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def find_users_by_id_without_preload_content(
        self,
        ids: Annotated[List[Annotated[str, Field(strict=True)]], Field(min_length=1, max_length=100, description="A list of User IDs, comma-separated. You can specify up to 100 IDs.")],
        user_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of User fields to display.")] = None,
        expansions: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of fields to expand.")] = None,
        tweet_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of Tweet fields to display.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """User lookup by IDs

        This endpoint returns information about Users. Specify Users by their ID.

        :param ids: A list of User IDs, comma-separated. You can specify up to 100 IDs. (required)
        :type ids: List[str]
        :param user_fields: A comma separated list of User fields to display.
        :type user_fields: List[str]
        :param expansions: A comma separated list of fields to expand.
        :type expansions: List[str]
        :param tweet_fields: A comma separated list of Tweet fields to display.
        :type tweet_fields: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._find_users_by_id_serialize(
            ids=ids,
            user_fields=user_fields,
            expansions=expansions,
            tweet_fields=tweet_fields,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Get2UsersResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _find_users_by_id_serialize(
        self,
        ids,
        user_fields,
        expansions,
        tweet_fields,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'ids': 'csv',
            'user.fields': 'csv',
            'expansions': 'csv',
            'tweet.fields': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if ids is not None:
            
            _query_params.append(('ids', ids))
            
        if user_fields is not None:
            
            _query_params.append(('user.fields', user_fields))
            
        if expansions is not None:
            
            _query_params.append(('expansions', expansions))
            
        if tweet_fields is not None:
            
            _query_params.append(('tweet.fields', tweet_fields))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json', 
                    'application/problem+json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'OAuth2UserToken', 
            'BearerToken', 
            'UserToken'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/2/users',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def find_users_by_username(
        self,
        usernames: Annotated[List[Annotated[str, Field(strict=True)]], Field(min_length=1, max_length=100, description="A list of usernames, comma-separated.")],
        user_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of User fields to display.")] = None,
        expansions: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of fields to expand.")] = None,
        tweet_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of Tweet fields to display.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> Get2UsersByResponse:
        """User lookup by usernames

        This endpoint returns information about Users. Specify Users by their username.

        :param usernames: A list of usernames, comma-separated. (required)
        :type usernames: List[str]
        :param user_fields: A comma separated list of User fields to display.
        :type user_fields: List[str]
        :param expansions: A comma separated list of fields to expand.
        :type expansions: List[str]
        :param tweet_fields: A comma separated list of Tweet fields to display.
        :type tweet_fields: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._find_users_by_username_serialize(
            usernames=usernames,
            user_fields=user_fields,
            expansions=expansions,
            tweet_fields=tweet_fields,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Get2UsersByResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def find_users_by_username_with_http_info(
        self,
        usernames: Annotated[List[Annotated[str, Field(strict=True)]], Field(min_length=1, max_length=100, description="A list of usernames, comma-separated.")],
        user_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of User fields to display.")] = None,
        expansions: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of fields to expand.")] = None,
        tweet_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of Tweet fields to display.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[Get2UsersByResponse]:
        """User lookup by usernames

        This endpoint returns information about Users. Specify Users by their username.

        :param usernames: A list of usernames, comma-separated. (required)
        :type usernames: List[str]
        :param user_fields: A comma separated list of User fields to display.
        :type user_fields: List[str]
        :param expansions: A comma separated list of fields to expand.
        :type expansions: List[str]
        :param tweet_fields: A comma separated list of Tweet fields to display.
        :type tweet_fields: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._find_users_by_username_serialize(
            usernames=usernames,
            user_fields=user_fields,
            expansions=expansions,
            tweet_fields=tweet_fields,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Get2UsersByResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def find_users_by_username_without_preload_content(
        self,
        usernames: Annotated[List[Annotated[str, Field(strict=True)]], Field(min_length=1, max_length=100, description="A list of usernames, comma-separated.")],
        user_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of User fields to display.")] = None,
        expansions: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of fields to expand.")] = None,
        tweet_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of Tweet fields to display.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """User lookup by usernames

        This endpoint returns information about Users. Specify Users by their username.

        :param usernames: A list of usernames, comma-separated. (required)
        :type usernames: List[str]
        :param user_fields: A comma separated list of User fields to display.
        :type user_fields: List[str]
        :param expansions: A comma separated list of fields to expand.
        :type expansions: List[str]
        :param tweet_fields: A comma separated list of Tweet fields to display.
        :type tweet_fields: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._find_users_by_username_serialize(
            usernames=usernames,
            user_fields=user_fields,
            expansions=expansions,
            tweet_fields=tweet_fields,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Get2UsersByResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _find_users_by_username_serialize(
        self,
        usernames,
        user_fields,
        expansions,
        tweet_fields,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'usernames': 'csv',
            'user.fields': 'csv',
            'expansions': 'csv',
            'tweet.fields': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if usernames is not None:
            
            _query_params.append(('usernames', usernames))
            
        if user_fields is not None:
            
            _query_params.append(('user.fields', user_fields))
            
        if expansions is not None:
            
            _query_params.append(('expansions', expansions))
            
        if tweet_fields is not None:
            
            _query_params.append(('tweet.fields', tweet_fields))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json', 
                    'application/problem+json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'OAuth2UserToken', 
            'BearerToken', 
            'UserToken'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/2/users/by',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def list_get_followers(
        self,
        id: Annotated[str, Field(strict=True, description="The ID of the List.")],
        max_results: Annotated[Optional[Annotated[int, Field(le=100, strict=True, ge=1)]], Field(description="The maximum number of results.")] = None,
        pagination_token: Annotated[Optional[Annotated[str, Field(min_length=1, strict=True, max_length=19)]], Field(description="This parameter is used to get a specified 'page' of results.")] = None,
        user_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of User fields to display.")] = None,
        expansions: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of fields to expand.")] = None,
        tweet_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of Tweet fields to display.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> Get2ListsIdFollowersResponse:
        """Returns User objects that follow a List by the provided List ID

        Returns a list of Users that follow a List by the provided List ID

        :param id: The ID of the List. (required)
        :type id: str
        :param max_results: The maximum number of results.
        :type max_results: int
        :param pagination_token: This parameter is used to get a specified 'page' of results.
        :type pagination_token: str
        :param user_fields: A comma separated list of User fields to display.
        :type user_fields: List[str]
        :param expansions: A comma separated list of fields to expand.
        :type expansions: List[str]
        :param tweet_fields: A comma separated list of Tweet fields to display.
        :type tweet_fields: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._list_get_followers_serialize(
            id=id,
            max_results=max_results,
            pagination_token=pagination_token,
            user_fields=user_fields,
            expansions=expansions,
            tweet_fields=tweet_fields,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Get2ListsIdFollowersResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def list_get_followers_with_http_info(
        self,
        id: Annotated[str, Field(strict=True, description="The ID of the List.")],
        max_results: Annotated[Optional[Annotated[int, Field(le=100, strict=True, ge=1)]], Field(description="The maximum number of results.")] = None,
        pagination_token: Annotated[Optional[Annotated[str, Field(min_length=1, strict=True, max_length=19)]], Field(description="This parameter is used to get a specified 'page' of results.")] = None,
        user_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of User fields to display.")] = None,
        expansions: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of fields to expand.")] = None,
        tweet_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of Tweet fields to display.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[Get2ListsIdFollowersResponse]:
        """Returns User objects that follow a List by the provided List ID

        Returns a list of Users that follow a List by the provided List ID

        :param id: The ID of the List. (required)
        :type id: str
        :param max_results: The maximum number of results.
        :type max_results: int
        :param pagination_token: This parameter is used to get a specified 'page' of results.
        :type pagination_token: str
        :param user_fields: A comma separated list of User fields to display.
        :type user_fields: List[str]
        :param expansions: A comma separated list of fields to expand.
        :type expansions: List[str]
        :param tweet_fields: A comma separated list of Tweet fields to display.
        :type tweet_fields: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._list_get_followers_serialize(
            id=id,
            max_results=max_results,
            pagination_token=pagination_token,
            user_fields=user_fields,
            expansions=expansions,
            tweet_fields=tweet_fields,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Get2ListsIdFollowersResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def list_get_followers_without_preload_content(
        self,
        id: Annotated[str, Field(strict=True, description="The ID of the List.")],
        max_results: Annotated[Optional[Annotated[int, Field(le=100, strict=True, ge=1)]], Field(description="The maximum number of results.")] = None,
        pagination_token: Annotated[Optional[Annotated[str, Field(min_length=1, strict=True, max_length=19)]], Field(description="This parameter is used to get a specified 'page' of results.")] = None,
        user_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of User fields to display.")] = None,
        expansions: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of fields to expand.")] = None,
        tweet_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of Tweet fields to display.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Returns User objects that follow a List by the provided List ID

        Returns a list of Users that follow a List by the provided List ID

        :param id: The ID of the List. (required)
        :type id: str
        :param max_results: The maximum number of results.
        :type max_results: int
        :param pagination_token: This parameter is used to get a specified 'page' of results.
        :type pagination_token: str
        :param user_fields: A comma separated list of User fields to display.
        :type user_fields: List[str]
        :param expansions: A comma separated list of fields to expand.
        :type expansions: List[str]
        :param tweet_fields: A comma separated list of Tweet fields to display.
        :type tweet_fields: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._list_get_followers_serialize(
            id=id,
            max_results=max_results,
            pagination_token=pagination_token,
            user_fields=user_fields,
            expansions=expansions,
            tweet_fields=tweet_fields,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Get2ListsIdFollowersResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _list_get_followers_serialize(
        self,
        id,
        max_results,
        pagination_token,
        user_fields,
        expansions,
        tweet_fields,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'user.fields': 'csv',
            'expansions': 'csv',
            'tweet.fields': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        if max_results is not None:
            
            _query_params.append(('max_results', max_results))
            
        if pagination_token is not None:
            
            _query_params.append(('pagination_token', pagination_token))
            
        if user_fields is not None:
            
            _query_params.append(('user.fields', user_fields))
            
        if expansions is not None:
            
            _query_params.append(('expansions', expansions))
            
        if tweet_fields is not None:
            
            _query_params.append(('tweet.fields', tweet_fields))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json', 
                    'application/problem+json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'OAuth2UserToken', 
            'BearerToken', 
            'UserToken'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/2/lists/{id}/followers',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def list_get_members(
        self,
        id: Annotated[str, Field(strict=True, description="The ID of the List.")],
        max_results: Annotated[Optional[Annotated[int, Field(le=100, strict=True, ge=1)]], Field(description="The maximum number of results.")] = None,
        pagination_token: Annotated[Optional[Annotated[str, Field(min_length=1, strict=True, max_length=19)]], Field(description="This parameter is used to get a specified 'page' of results.")] = None,
        user_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of User fields to display.")] = None,
        expansions: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of fields to expand.")] = None,
        tweet_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of Tweet fields to display.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> Get2ListsIdMembersResponse:
        """Returns User objects that are members of a List by the provided List ID.

        Returns a list of Users that are members of a List by the provided List ID.

        :param id: The ID of the List. (required)
        :type id: str
        :param max_results: The maximum number of results.
        :type max_results: int
        :param pagination_token: This parameter is used to get a specified 'page' of results.
        :type pagination_token: str
        :param user_fields: A comma separated list of User fields to display.
        :type user_fields: List[str]
        :param expansions: A comma separated list of fields to expand.
        :type expansions: List[str]
        :param tweet_fields: A comma separated list of Tweet fields to display.
        :type tweet_fields: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._list_get_members_serialize(
            id=id,
            max_results=max_results,
            pagination_token=pagination_token,
            user_fields=user_fields,
            expansions=expansions,
            tweet_fields=tweet_fields,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Get2ListsIdMembersResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def list_get_members_with_http_info(
        self,
        id: Annotated[str, Field(strict=True, description="The ID of the List.")],
        max_results: Annotated[Optional[Annotated[int, Field(le=100, strict=True, ge=1)]], Field(description="The maximum number of results.")] = None,
        pagination_token: Annotated[Optional[Annotated[str, Field(min_length=1, strict=True, max_length=19)]], Field(description="This parameter is used to get a specified 'page' of results.")] = None,
        user_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of User fields to display.")] = None,
        expansions: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of fields to expand.")] = None,
        tweet_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of Tweet fields to display.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[Get2ListsIdMembersResponse]:
        """Returns User objects that are members of a List by the provided List ID.

        Returns a list of Users that are members of a List by the provided List ID.

        :param id: The ID of the List. (required)
        :type id: str
        :param max_results: The maximum number of results.
        :type max_results: int
        :param pagination_token: This parameter is used to get a specified 'page' of results.
        :type pagination_token: str
        :param user_fields: A comma separated list of User fields to display.
        :type user_fields: List[str]
        :param expansions: A comma separated list of fields to expand.
        :type expansions: List[str]
        :param tweet_fields: A comma separated list of Tweet fields to display.
        :type tweet_fields: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._list_get_members_serialize(
            id=id,
            max_results=max_results,
            pagination_token=pagination_token,
            user_fields=user_fields,
            expansions=expansions,
            tweet_fields=tweet_fields,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Get2ListsIdMembersResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def list_get_members_without_preload_content(
        self,
        id: Annotated[str, Field(strict=True, description="The ID of the List.")],
        max_results: Annotated[Optional[Annotated[int, Field(le=100, strict=True, ge=1)]], Field(description="The maximum number of results.")] = None,
        pagination_token: Annotated[Optional[Annotated[str, Field(min_length=1, strict=True, max_length=19)]], Field(description="This parameter is used to get a specified 'page' of results.")] = None,
        user_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of User fields to display.")] = None,
        expansions: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of fields to expand.")] = None,
        tweet_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of Tweet fields to display.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Returns User objects that are members of a List by the provided List ID.

        Returns a list of Users that are members of a List by the provided List ID.

        :param id: The ID of the List. (required)
        :type id: str
        :param max_results: The maximum number of results.
        :type max_results: int
        :param pagination_token: This parameter is used to get a specified 'page' of results.
        :type pagination_token: str
        :param user_fields: A comma separated list of User fields to display.
        :type user_fields: List[str]
        :param expansions: A comma separated list of fields to expand.
        :type expansions: List[str]
        :param tweet_fields: A comma separated list of Tweet fields to display.
        :type tweet_fields: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._list_get_members_serialize(
            id=id,
            max_results=max_results,
            pagination_token=pagination_token,
            user_fields=user_fields,
            expansions=expansions,
            tweet_fields=tweet_fields,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Get2ListsIdMembersResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _list_get_members_serialize(
        self,
        id,
        max_results,
        pagination_token,
        user_fields,
        expansions,
        tweet_fields,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'user.fields': 'csv',
            'expansions': 'csv',
            'tweet.fields': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        if max_results is not None:
            
            _query_params.append(('max_results', max_results))
            
        if pagination_token is not None:
            
            _query_params.append(('pagination_token', pagination_token))
            
        if user_fields is not None:
            
            _query_params.append(('user.fields', user_fields))
            
        if expansions is not None:
            
            _query_params.append(('expansions', expansions))
            
        if tweet_fields is not None:
            
            _query_params.append(('tweet.fields', tweet_fields))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json', 
                    'application/problem+json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'OAuth2UserToken', 
            'BearerToken', 
            'UserToken'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/2/lists/{id}/members',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def tweets_id_liking_users(
        self,
        id: Annotated[str, Field(strict=True, description="A single Tweet ID.")],
        max_results: Annotated[Optional[Annotated[int, Field(le=100, strict=True, ge=1)]], Field(description="The maximum number of results.")] = None,
        pagination_token: Annotated[Optional[Annotated[str, Field(min_length=1, strict=True)]], Field(description="This parameter is used to get the next 'page' of results.")] = None,
        user_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of User fields to display.")] = None,
        expansions: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of fields to expand.")] = None,
        tweet_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of Tweet fields to display.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> Get2TweetsIdLikingUsersResponse:
        """Returns User objects that have liked the provided Tweet ID

        Returns a list of Users that have liked the provided Tweet ID

        :param id: A single Tweet ID. (required)
        :type id: str
        :param max_results: The maximum number of results.
        :type max_results: int
        :param pagination_token: This parameter is used to get the next 'page' of results.
        :type pagination_token: str
        :param user_fields: A comma separated list of User fields to display.
        :type user_fields: List[str]
        :param expansions: A comma separated list of fields to expand.
        :type expansions: List[str]
        :param tweet_fields: A comma separated list of Tweet fields to display.
        :type tweet_fields: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._tweets_id_liking_users_serialize(
            id=id,
            max_results=max_results,
            pagination_token=pagination_token,
            user_fields=user_fields,
            expansions=expansions,
            tweet_fields=tweet_fields,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Get2TweetsIdLikingUsersResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def tweets_id_liking_users_with_http_info(
        self,
        id: Annotated[str, Field(strict=True, description="A single Tweet ID.")],
        max_results: Annotated[Optional[Annotated[int, Field(le=100, strict=True, ge=1)]], Field(description="The maximum number of results.")] = None,
        pagination_token: Annotated[Optional[Annotated[str, Field(min_length=1, strict=True)]], Field(description="This parameter is used to get the next 'page' of results.")] = None,
        user_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of User fields to display.")] = None,
        expansions: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of fields to expand.")] = None,
        tweet_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of Tweet fields to display.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[Get2TweetsIdLikingUsersResponse]:
        """Returns User objects that have liked the provided Tweet ID

        Returns a list of Users that have liked the provided Tweet ID

        :param id: A single Tweet ID. (required)
        :type id: str
        :param max_results: The maximum number of results.
        :type max_results: int
        :param pagination_token: This parameter is used to get the next 'page' of results.
        :type pagination_token: str
        :param user_fields: A comma separated list of User fields to display.
        :type user_fields: List[str]
        :param expansions: A comma separated list of fields to expand.
        :type expansions: List[str]
        :param tweet_fields: A comma separated list of Tweet fields to display.
        :type tweet_fields: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._tweets_id_liking_users_serialize(
            id=id,
            max_results=max_results,
            pagination_token=pagination_token,
            user_fields=user_fields,
            expansions=expansions,
            tweet_fields=tweet_fields,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Get2TweetsIdLikingUsersResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def tweets_id_liking_users_without_preload_content(
        self,
        id: Annotated[str, Field(strict=True, description="A single Tweet ID.")],
        max_results: Annotated[Optional[Annotated[int, Field(le=100, strict=True, ge=1)]], Field(description="The maximum number of results.")] = None,
        pagination_token: Annotated[Optional[Annotated[str, Field(min_length=1, strict=True)]], Field(description="This parameter is used to get the next 'page' of results.")] = None,
        user_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of User fields to display.")] = None,
        expansions: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of fields to expand.")] = None,
        tweet_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of Tweet fields to display.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Returns User objects that have liked the provided Tweet ID

        Returns a list of Users that have liked the provided Tweet ID

        :param id: A single Tweet ID. (required)
        :type id: str
        :param max_results: The maximum number of results.
        :type max_results: int
        :param pagination_token: This parameter is used to get the next 'page' of results.
        :type pagination_token: str
        :param user_fields: A comma separated list of User fields to display.
        :type user_fields: List[str]
        :param expansions: A comma separated list of fields to expand.
        :type expansions: List[str]
        :param tweet_fields: A comma separated list of Tweet fields to display.
        :type tweet_fields: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._tweets_id_liking_users_serialize(
            id=id,
            max_results=max_results,
            pagination_token=pagination_token,
            user_fields=user_fields,
            expansions=expansions,
            tweet_fields=tweet_fields,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Get2TweetsIdLikingUsersResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _tweets_id_liking_users_serialize(
        self,
        id,
        max_results,
        pagination_token,
        user_fields,
        expansions,
        tweet_fields,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'user.fields': 'csv',
            'expansions': 'csv',
            'tweet.fields': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        if max_results is not None:
            
            _query_params.append(('max_results', max_results))
            
        if pagination_token is not None:
            
            _query_params.append(('pagination_token', pagination_token))
            
        if user_fields is not None:
            
            _query_params.append(('user.fields', user_fields))
            
        if expansions is not None:
            
            _query_params.append(('expansions', expansions))
            
        if tweet_fields is not None:
            
            _query_params.append(('tweet.fields', tweet_fields))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json', 
                    'application/problem+json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'OAuth2UserToken', 
            'BearerToken', 
            'UserToken'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/2/tweets/{id}/liking_users',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def tweets_id_retweeting_users(
        self,
        id: Annotated[str, Field(strict=True, description="A single Tweet ID.")],
        max_results: Annotated[Optional[Annotated[int, Field(le=100, strict=True, ge=1)]], Field(description="The maximum number of results.")] = None,
        pagination_token: Annotated[Optional[Annotated[str, Field(min_length=1, strict=True)]], Field(description="This parameter is used to get the next 'page' of results.")] = None,
        user_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of User fields to display.")] = None,
        expansions: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of fields to expand.")] = None,
        tweet_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of Tweet fields to display.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> Get2TweetsIdRetweetedByResponse:
        """Returns User objects that have retweeted the provided Tweet ID

        Returns a list of Users that have retweeted the provided Tweet ID

        :param id: A single Tweet ID. (required)
        :type id: str
        :param max_results: The maximum number of results.
        :type max_results: int
        :param pagination_token: This parameter is used to get the next 'page' of results.
        :type pagination_token: str
        :param user_fields: A comma separated list of User fields to display.
        :type user_fields: List[str]
        :param expansions: A comma separated list of fields to expand.
        :type expansions: List[str]
        :param tweet_fields: A comma separated list of Tweet fields to display.
        :type tweet_fields: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._tweets_id_retweeting_users_serialize(
            id=id,
            max_results=max_results,
            pagination_token=pagination_token,
            user_fields=user_fields,
            expansions=expansions,
            tweet_fields=tweet_fields,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Get2TweetsIdRetweetedByResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def tweets_id_retweeting_users_with_http_info(
        self,
        id: Annotated[str, Field(strict=True, description="A single Tweet ID.")],
        max_results: Annotated[Optional[Annotated[int, Field(le=100, strict=True, ge=1)]], Field(description="The maximum number of results.")] = None,
        pagination_token: Annotated[Optional[Annotated[str, Field(min_length=1, strict=True)]], Field(description="This parameter is used to get the next 'page' of results.")] = None,
        user_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of User fields to display.")] = None,
        expansions: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of fields to expand.")] = None,
        tweet_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of Tweet fields to display.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[Get2TweetsIdRetweetedByResponse]:
        """Returns User objects that have retweeted the provided Tweet ID

        Returns a list of Users that have retweeted the provided Tweet ID

        :param id: A single Tweet ID. (required)
        :type id: str
        :param max_results: The maximum number of results.
        :type max_results: int
        :param pagination_token: This parameter is used to get the next 'page' of results.
        :type pagination_token: str
        :param user_fields: A comma separated list of User fields to display.
        :type user_fields: List[str]
        :param expansions: A comma separated list of fields to expand.
        :type expansions: List[str]
        :param tweet_fields: A comma separated list of Tweet fields to display.
        :type tweet_fields: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._tweets_id_retweeting_users_serialize(
            id=id,
            max_results=max_results,
            pagination_token=pagination_token,
            user_fields=user_fields,
            expansions=expansions,
            tweet_fields=tweet_fields,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Get2TweetsIdRetweetedByResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def tweets_id_retweeting_users_without_preload_content(
        self,
        id: Annotated[str, Field(strict=True, description="A single Tweet ID.")],
        max_results: Annotated[Optional[Annotated[int, Field(le=100, strict=True, ge=1)]], Field(description="The maximum number of results.")] = None,
        pagination_token: Annotated[Optional[Annotated[str, Field(min_length=1, strict=True)]], Field(description="This parameter is used to get the next 'page' of results.")] = None,
        user_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of User fields to display.")] = None,
        expansions: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of fields to expand.")] = None,
        tweet_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of Tweet fields to display.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Returns User objects that have retweeted the provided Tweet ID

        Returns a list of Users that have retweeted the provided Tweet ID

        :param id: A single Tweet ID. (required)
        :type id: str
        :param max_results: The maximum number of results.
        :type max_results: int
        :param pagination_token: This parameter is used to get the next 'page' of results.
        :type pagination_token: str
        :param user_fields: A comma separated list of User fields to display.
        :type user_fields: List[str]
        :param expansions: A comma separated list of fields to expand.
        :type expansions: List[str]
        :param tweet_fields: A comma separated list of Tweet fields to display.
        :type tweet_fields: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._tweets_id_retweeting_users_serialize(
            id=id,
            max_results=max_results,
            pagination_token=pagination_token,
            user_fields=user_fields,
            expansions=expansions,
            tweet_fields=tweet_fields,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Get2TweetsIdRetweetedByResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _tweets_id_retweeting_users_serialize(
        self,
        id,
        max_results,
        pagination_token,
        user_fields,
        expansions,
        tweet_fields,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'user.fields': 'csv',
            'expansions': 'csv',
            'tweet.fields': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        if max_results is not None:
            
            _query_params.append(('max_results', max_results))
            
        if pagination_token is not None:
            
            _query_params.append(('pagination_token', pagination_token))
            
        if user_fields is not None:
            
            _query_params.append(('user.fields', user_fields))
            
        if expansions is not None:
            
            _query_params.append(('expansions', expansions))
            
        if tweet_fields is not None:
            
            _query_params.append(('tweet.fields', tweet_fields))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json', 
                    'application/problem+json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'OAuth2UserToken', 
            'BearerToken', 
            'UserToken'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/2/tweets/{id}/retweeted_by',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def users_id_block(
        self,
        id: Annotated[StrictStr, Field(description="The ID of the authenticated source User that is requesting to block the target User.")],
        block_user_request: BlockUserRequest,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> BlockUserMutationResponse:
        """Block User by User ID

        Causes the User (in the path) to block the target User. The User (in the path) must match the User context authorizing the request

        :param id: The ID of the authenticated source User that is requesting to block the target User. (required)
        :type id: str
        :param block_user_request: (required)
        :type block_user_request: BlockUserRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._users_id_block_serialize(
            id=id,
            block_user_request=block_user_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "BlockUserMutationResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def users_id_block_with_http_info(
        self,
        id: Annotated[StrictStr, Field(description="The ID of the authenticated source User that is requesting to block the target User.")],
        block_user_request: BlockUserRequest,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[BlockUserMutationResponse]:
        """Block User by User ID

        Causes the User (in the path) to block the target User. The User (in the path) must match the User context authorizing the request

        :param id: The ID of the authenticated source User that is requesting to block the target User. (required)
        :type id: str
        :param block_user_request: (required)
        :type block_user_request: BlockUserRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._users_id_block_serialize(
            id=id,
            block_user_request=block_user_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "BlockUserMutationResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def users_id_block_without_preload_content(
        self,
        id: Annotated[StrictStr, Field(description="The ID of the authenticated source User that is requesting to block the target User.")],
        block_user_request: BlockUserRequest,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Block User by User ID

        Causes the User (in the path) to block the target User. The User (in the path) must match the User context authorizing the request

        :param id: The ID of the authenticated source User that is requesting to block the target User. (required)
        :type id: str
        :param block_user_request: (required)
        :type block_user_request: BlockUserRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._users_id_block_serialize(
            id=id,
            block_user_request=block_user_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "BlockUserMutationResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _users_id_block_serialize(
        self,
        id,
        block_user_request,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if block_user_request is not None:
            _body_params = block_user_request


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json', 
                    'application/problem+json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'OAuth2UserToken', 
            'UserToken'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/2/users/{id}/blocking',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def users_id_blocking(
        self,
        id: Annotated[StrictStr, Field(description="The ID of the authenticated source User for whom to return results.")],
        max_results: Annotated[Optional[Annotated[int, Field(le=1000, strict=True, ge=1)]], Field(description="The maximum number of results.")] = None,
        pagination_token: Annotated[Optional[Annotated[str, Field(min_length=16, strict=True)]], Field(description="This parameter is used to get a specified 'page' of results.")] = None,
        user_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of User fields to display.")] = None,
        expansions: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of fields to expand.")] = None,
        tweet_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of Tweet fields to display.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> Get2UsersIdBlockingResponse:
        """Returns User objects that are blocked by provided User ID

        Returns a list of Users that are blocked by the provided User ID

        :param id: The ID of the authenticated source User for whom to return results. (required)
        :type id: str
        :param max_results: The maximum number of results.
        :type max_results: int
        :param pagination_token: This parameter is used to get a specified 'page' of results.
        :type pagination_token: str
        :param user_fields: A comma separated list of User fields to display.
        :type user_fields: List[str]
        :param expansions: A comma separated list of fields to expand.
        :type expansions: List[str]
        :param tweet_fields: A comma separated list of Tweet fields to display.
        :type tweet_fields: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._users_id_blocking_serialize(
            id=id,
            max_results=max_results,
            pagination_token=pagination_token,
            user_fields=user_fields,
            expansions=expansions,
            tweet_fields=tweet_fields,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Get2UsersIdBlockingResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def users_id_blocking_with_http_info(
        self,
        id: Annotated[StrictStr, Field(description="The ID of the authenticated source User for whom to return results.")],
        max_results: Annotated[Optional[Annotated[int, Field(le=1000, strict=True, ge=1)]], Field(description="The maximum number of results.")] = None,
        pagination_token: Annotated[Optional[Annotated[str, Field(min_length=16, strict=True)]], Field(description="This parameter is used to get a specified 'page' of results.")] = None,
        user_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of User fields to display.")] = None,
        expansions: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of fields to expand.")] = None,
        tweet_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of Tweet fields to display.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[Get2UsersIdBlockingResponse]:
        """Returns User objects that are blocked by provided User ID

        Returns a list of Users that are blocked by the provided User ID

        :param id: The ID of the authenticated source User for whom to return results. (required)
        :type id: str
        :param max_results: The maximum number of results.
        :type max_results: int
        :param pagination_token: This parameter is used to get a specified 'page' of results.
        :type pagination_token: str
        :param user_fields: A comma separated list of User fields to display.
        :type user_fields: List[str]
        :param expansions: A comma separated list of fields to expand.
        :type expansions: List[str]
        :param tweet_fields: A comma separated list of Tweet fields to display.
        :type tweet_fields: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._users_id_blocking_serialize(
            id=id,
            max_results=max_results,
            pagination_token=pagination_token,
            user_fields=user_fields,
            expansions=expansions,
            tweet_fields=tweet_fields,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Get2UsersIdBlockingResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def users_id_blocking_without_preload_content(
        self,
        id: Annotated[StrictStr, Field(description="The ID of the authenticated source User for whom to return results.")],
        max_results: Annotated[Optional[Annotated[int, Field(le=1000, strict=True, ge=1)]], Field(description="The maximum number of results.")] = None,
        pagination_token: Annotated[Optional[Annotated[str, Field(min_length=16, strict=True)]], Field(description="This parameter is used to get a specified 'page' of results.")] = None,
        user_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of User fields to display.")] = None,
        expansions: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of fields to expand.")] = None,
        tweet_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of Tweet fields to display.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Returns User objects that are blocked by provided User ID

        Returns a list of Users that are blocked by the provided User ID

        :param id: The ID of the authenticated source User for whom to return results. (required)
        :type id: str
        :param max_results: The maximum number of results.
        :type max_results: int
        :param pagination_token: This parameter is used to get a specified 'page' of results.
        :type pagination_token: str
        :param user_fields: A comma separated list of User fields to display.
        :type user_fields: List[str]
        :param expansions: A comma separated list of fields to expand.
        :type expansions: List[str]
        :param tweet_fields: A comma separated list of Tweet fields to display.
        :type tweet_fields: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._users_id_blocking_serialize(
            id=id,
            max_results=max_results,
            pagination_token=pagination_token,
            user_fields=user_fields,
            expansions=expansions,
            tweet_fields=tweet_fields,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Get2UsersIdBlockingResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _users_id_blocking_serialize(
        self,
        id,
        max_results,
        pagination_token,
        user_fields,
        expansions,
        tweet_fields,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'user.fields': 'csv',
            'expansions': 'csv',
            'tweet.fields': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        if max_results is not None:
            
            _query_params.append(('max_results', max_results))
            
        if pagination_token is not None:
            
            _query_params.append(('pagination_token', pagination_token))
            
        if user_fields is not None:
            
            _query_params.append(('user.fields', user_fields))
            
        if expansions is not None:
            
            _query_params.append(('expansions', expansions))
            
        if tweet_fields is not None:
            
            _query_params.append(('tweet.fields', tweet_fields))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json', 
                    'application/problem+json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'OAuth2UserToken', 
            'UserToken'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/2/users/{id}/blocking',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def users_id_follow(
        self,
        id: Annotated[StrictStr, Field(description="The ID of the authenticated source User that is requesting to follow the target User.")],
        users_following_create_request: Optional[UsersFollowingCreateRequest] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> UsersFollowingCreateResponse:
        """Follow User

        Causes the User(in the path) to follow, or “request to follow” for protected Users, the target User. The User(in the path) must match the User context authorizing the request

        :param id: The ID of the authenticated source User that is requesting to follow the target User. (required)
        :type id: str
        :param users_following_create_request:
        :type users_following_create_request: UsersFollowingCreateRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._users_id_follow_serialize(
            id=id,
            users_following_create_request=users_following_create_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "UsersFollowingCreateResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def users_id_follow_with_http_info(
        self,
        id: Annotated[StrictStr, Field(description="The ID of the authenticated source User that is requesting to follow the target User.")],
        users_following_create_request: Optional[UsersFollowingCreateRequest] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[UsersFollowingCreateResponse]:
        """Follow User

        Causes the User(in the path) to follow, or “request to follow” for protected Users, the target User. The User(in the path) must match the User context authorizing the request

        :param id: The ID of the authenticated source User that is requesting to follow the target User. (required)
        :type id: str
        :param users_following_create_request:
        :type users_following_create_request: UsersFollowingCreateRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._users_id_follow_serialize(
            id=id,
            users_following_create_request=users_following_create_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "UsersFollowingCreateResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def users_id_follow_without_preload_content(
        self,
        id: Annotated[StrictStr, Field(description="The ID of the authenticated source User that is requesting to follow the target User.")],
        users_following_create_request: Optional[UsersFollowingCreateRequest] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Follow User

        Causes the User(in the path) to follow, or “request to follow” for protected Users, the target User. The User(in the path) must match the User context authorizing the request

        :param id: The ID of the authenticated source User that is requesting to follow the target User. (required)
        :type id: str
        :param users_following_create_request:
        :type users_following_create_request: UsersFollowingCreateRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._users_id_follow_serialize(
            id=id,
            users_following_create_request=users_following_create_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "UsersFollowingCreateResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _users_id_follow_serialize(
        self,
        id,
        users_following_create_request,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if users_following_create_request is not None:
            _body_params = users_following_create_request


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json', 
                    'application/problem+json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'OAuth2UserToken', 
            'UserToken'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/2/users/{id}/following',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def users_id_followers(
        self,
        id: Annotated[str, Field(strict=True, description="The ID of the User to lookup.")],
        max_results: Annotated[Optional[Annotated[int, Field(le=1000, strict=True, ge=1)]], Field(description="The maximum number of results.")] = None,
        pagination_token: Annotated[Optional[Annotated[str, Field(min_length=16, strict=True)]], Field(description="This parameter is used to get a specified 'page' of results.")] = None,
        user_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of User fields to display.")] = None,
        expansions: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of fields to expand.")] = None,
        tweet_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of Tweet fields to display.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> Get2UsersIdFollowersResponse:
        """Followers by User ID

        Returns a list of Users who are followers of the specified User ID.

        :param id: The ID of the User to lookup. (required)
        :type id: str
        :param max_results: The maximum number of results.
        :type max_results: int
        :param pagination_token: This parameter is used to get a specified 'page' of results.
        :type pagination_token: str
        :param user_fields: A comma separated list of User fields to display.
        :type user_fields: List[str]
        :param expansions: A comma separated list of fields to expand.
        :type expansions: List[str]
        :param tweet_fields: A comma separated list of Tweet fields to display.
        :type tweet_fields: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._users_id_followers_serialize(
            id=id,
            max_results=max_results,
            pagination_token=pagination_token,
            user_fields=user_fields,
            expansions=expansions,
            tweet_fields=tweet_fields,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Get2UsersIdFollowersResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def users_id_followers_with_http_info(
        self,
        id: Annotated[str, Field(strict=True, description="The ID of the User to lookup.")],
        max_results: Annotated[Optional[Annotated[int, Field(le=1000, strict=True, ge=1)]], Field(description="The maximum number of results.")] = None,
        pagination_token: Annotated[Optional[Annotated[str, Field(min_length=16, strict=True)]], Field(description="This parameter is used to get a specified 'page' of results.")] = None,
        user_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of User fields to display.")] = None,
        expansions: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of fields to expand.")] = None,
        tweet_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of Tweet fields to display.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[Get2UsersIdFollowersResponse]:
        """Followers by User ID

        Returns a list of Users who are followers of the specified User ID.

        :param id: The ID of the User to lookup. (required)
        :type id: str
        :param max_results: The maximum number of results.
        :type max_results: int
        :param pagination_token: This parameter is used to get a specified 'page' of results.
        :type pagination_token: str
        :param user_fields: A comma separated list of User fields to display.
        :type user_fields: List[str]
        :param expansions: A comma separated list of fields to expand.
        :type expansions: List[str]
        :param tweet_fields: A comma separated list of Tweet fields to display.
        :type tweet_fields: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._users_id_followers_serialize(
            id=id,
            max_results=max_results,
            pagination_token=pagination_token,
            user_fields=user_fields,
            expansions=expansions,
            tweet_fields=tweet_fields,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Get2UsersIdFollowersResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def users_id_followers_without_preload_content(
        self,
        id: Annotated[str, Field(strict=True, description="The ID of the User to lookup.")],
        max_results: Annotated[Optional[Annotated[int, Field(le=1000, strict=True, ge=1)]], Field(description="The maximum number of results.")] = None,
        pagination_token: Annotated[Optional[Annotated[str, Field(min_length=16, strict=True)]], Field(description="This parameter is used to get a specified 'page' of results.")] = None,
        user_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of User fields to display.")] = None,
        expansions: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of fields to expand.")] = None,
        tweet_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of Tweet fields to display.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Followers by User ID

        Returns a list of Users who are followers of the specified User ID.

        :param id: The ID of the User to lookup. (required)
        :type id: str
        :param max_results: The maximum number of results.
        :type max_results: int
        :param pagination_token: This parameter is used to get a specified 'page' of results.
        :type pagination_token: str
        :param user_fields: A comma separated list of User fields to display.
        :type user_fields: List[str]
        :param expansions: A comma separated list of fields to expand.
        :type expansions: List[str]
        :param tweet_fields: A comma separated list of Tweet fields to display.
        :type tweet_fields: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._users_id_followers_serialize(
            id=id,
            max_results=max_results,
            pagination_token=pagination_token,
            user_fields=user_fields,
            expansions=expansions,
            tweet_fields=tweet_fields,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Get2UsersIdFollowersResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _users_id_followers_serialize(
        self,
        id,
        max_results,
        pagination_token,
        user_fields,
        expansions,
        tweet_fields,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'user.fields': 'csv',
            'expansions': 'csv',
            'tweet.fields': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        if max_results is not None:
            
            _query_params.append(('max_results', max_results))
            
        if pagination_token is not None:
            
            _query_params.append(('pagination_token', pagination_token))
            
        if user_fields is not None:
            
            _query_params.append(('user.fields', user_fields))
            
        if expansions is not None:
            
            _query_params.append(('expansions', expansions))
            
        if tweet_fields is not None:
            
            _query_params.append(('tweet.fields', tweet_fields))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json', 
                    'application/problem+json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'OAuth2UserToken', 
            'BearerToken', 
            'UserToken'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/2/users/{id}/followers',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def users_id_following(
        self,
        id: Annotated[str, Field(strict=True, description="The ID of the User to lookup.")],
        max_results: Annotated[Optional[Annotated[int, Field(le=1000, strict=True, ge=1)]], Field(description="The maximum number of results.")] = None,
        pagination_token: Annotated[Optional[Annotated[str, Field(min_length=16, strict=True)]], Field(description="This parameter is used to get a specified 'page' of results.")] = None,
        user_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of User fields to display.")] = None,
        expansions: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of fields to expand.")] = None,
        tweet_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of Tweet fields to display.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> Get2UsersIdFollowingResponse:
        """Following by User ID

        Returns a list of Users that are being followed by the provided User ID

        :param id: The ID of the User to lookup. (required)
        :type id: str
        :param max_results: The maximum number of results.
        :type max_results: int
        :param pagination_token: This parameter is used to get a specified 'page' of results.
        :type pagination_token: str
        :param user_fields: A comma separated list of User fields to display.
        :type user_fields: List[str]
        :param expansions: A comma separated list of fields to expand.
        :type expansions: List[str]
        :param tweet_fields: A comma separated list of Tweet fields to display.
        :type tweet_fields: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._users_id_following_serialize(
            id=id,
            max_results=max_results,
            pagination_token=pagination_token,
            user_fields=user_fields,
            expansions=expansions,
            tweet_fields=tweet_fields,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Get2UsersIdFollowingResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def users_id_following_with_http_info(
        self,
        id: Annotated[str, Field(strict=True, description="The ID of the User to lookup.")],
        max_results: Annotated[Optional[Annotated[int, Field(le=1000, strict=True, ge=1)]], Field(description="The maximum number of results.")] = None,
        pagination_token: Annotated[Optional[Annotated[str, Field(min_length=16, strict=True)]], Field(description="This parameter is used to get a specified 'page' of results.")] = None,
        user_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of User fields to display.")] = None,
        expansions: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of fields to expand.")] = None,
        tweet_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of Tweet fields to display.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[Get2UsersIdFollowingResponse]:
        """Following by User ID

        Returns a list of Users that are being followed by the provided User ID

        :param id: The ID of the User to lookup. (required)
        :type id: str
        :param max_results: The maximum number of results.
        :type max_results: int
        :param pagination_token: This parameter is used to get a specified 'page' of results.
        :type pagination_token: str
        :param user_fields: A comma separated list of User fields to display.
        :type user_fields: List[str]
        :param expansions: A comma separated list of fields to expand.
        :type expansions: List[str]
        :param tweet_fields: A comma separated list of Tweet fields to display.
        :type tweet_fields: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._users_id_following_serialize(
            id=id,
            max_results=max_results,
            pagination_token=pagination_token,
            user_fields=user_fields,
            expansions=expansions,
            tweet_fields=tweet_fields,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Get2UsersIdFollowingResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def users_id_following_without_preload_content(
        self,
        id: Annotated[str, Field(strict=True, description="The ID of the User to lookup.")],
        max_results: Annotated[Optional[Annotated[int, Field(le=1000, strict=True, ge=1)]], Field(description="The maximum number of results.")] = None,
        pagination_token: Annotated[Optional[Annotated[str, Field(min_length=16, strict=True)]], Field(description="This parameter is used to get a specified 'page' of results.")] = None,
        user_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of User fields to display.")] = None,
        expansions: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of fields to expand.")] = None,
        tweet_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of Tweet fields to display.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Following by User ID

        Returns a list of Users that are being followed by the provided User ID

        :param id: The ID of the User to lookup. (required)
        :type id: str
        :param max_results: The maximum number of results.
        :type max_results: int
        :param pagination_token: This parameter is used to get a specified 'page' of results.
        :type pagination_token: str
        :param user_fields: A comma separated list of User fields to display.
        :type user_fields: List[str]
        :param expansions: A comma separated list of fields to expand.
        :type expansions: List[str]
        :param tweet_fields: A comma separated list of Tweet fields to display.
        :type tweet_fields: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._users_id_following_serialize(
            id=id,
            max_results=max_results,
            pagination_token=pagination_token,
            user_fields=user_fields,
            expansions=expansions,
            tweet_fields=tweet_fields,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Get2UsersIdFollowingResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _users_id_following_serialize(
        self,
        id,
        max_results,
        pagination_token,
        user_fields,
        expansions,
        tweet_fields,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'user.fields': 'csv',
            'expansions': 'csv',
            'tweet.fields': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        if max_results is not None:
            
            _query_params.append(('max_results', max_results))
            
        if pagination_token is not None:
            
            _query_params.append(('pagination_token', pagination_token))
            
        if user_fields is not None:
            
            _query_params.append(('user.fields', user_fields))
            
        if expansions is not None:
            
            _query_params.append(('expansions', expansions))
            
        if tweet_fields is not None:
            
            _query_params.append(('tweet.fields', tweet_fields))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json', 
                    'application/problem+json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'OAuth2UserToken', 
            'BearerToken', 
            'UserToken'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/2/users/{id}/following',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def users_id_mute(
        self,
        id: Annotated[StrictStr, Field(description="The ID of the authenticated source User that is requesting to mute the target User.")],
        mute_user_request: Optional[MuteUserRequest] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> MuteUserMutationResponse:
        """Mute User by User ID.

        Causes the User (in the path) to mute the target User. The User (in the path) must match the User context authorizing the request.

        :param id: The ID of the authenticated source User that is requesting to mute the target User. (required)
        :type id: str
        :param mute_user_request:
        :type mute_user_request: MuteUserRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._users_id_mute_serialize(
            id=id,
            mute_user_request=mute_user_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "MuteUserMutationResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def users_id_mute_with_http_info(
        self,
        id: Annotated[StrictStr, Field(description="The ID of the authenticated source User that is requesting to mute the target User.")],
        mute_user_request: Optional[MuteUserRequest] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[MuteUserMutationResponse]:
        """Mute User by User ID.

        Causes the User (in the path) to mute the target User. The User (in the path) must match the User context authorizing the request.

        :param id: The ID of the authenticated source User that is requesting to mute the target User. (required)
        :type id: str
        :param mute_user_request:
        :type mute_user_request: MuteUserRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._users_id_mute_serialize(
            id=id,
            mute_user_request=mute_user_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "MuteUserMutationResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def users_id_mute_without_preload_content(
        self,
        id: Annotated[StrictStr, Field(description="The ID of the authenticated source User that is requesting to mute the target User.")],
        mute_user_request: Optional[MuteUserRequest] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Mute User by User ID.

        Causes the User (in the path) to mute the target User. The User (in the path) must match the User context authorizing the request.

        :param id: The ID of the authenticated source User that is requesting to mute the target User. (required)
        :type id: str
        :param mute_user_request:
        :type mute_user_request: MuteUserRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._users_id_mute_serialize(
            id=id,
            mute_user_request=mute_user_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "MuteUserMutationResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _users_id_mute_serialize(
        self,
        id,
        mute_user_request,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if mute_user_request is not None:
            _body_params = mute_user_request


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json', 
                    'application/problem+json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'OAuth2UserToken', 
            'UserToken'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/2/users/{id}/muting',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def users_id_muting(
        self,
        id: Annotated[StrictStr, Field(description="The ID of the authenticated source User for whom to return results.")],
        max_results: Annotated[Optional[Annotated[int, Field(le=1000, strict=True, ge=1)]], Field(description="The maximum number of results.")] = None,
        pagination_token: Annotated[Optional[Annotated[str, Field(min_length=1, strict=True, max_length=19)]], Field(description="This parameter is used to get the next 'page' of results.")] = None,
        user_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of User fields to display.")] = None,
        expansions: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of fields to expand.")] = None,
        tweet_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of Tweet fields to display.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> Get2UsersIdMutingResponse:
        """Returns User objects that are muted by the provided User ID

        Returns a list of Users that are muted by the provided User ID

        :param id: The ID of the authenticated source User for whom to return results. (required)
        :type id: str
        :param max_results: The maximum number of results.
        :type max_results: int
        :param pagination_token: This parameter is used to get the next 'page' of results.
        :type pagination_token: str
        :param user_fields: A comma separated list of User fields to display.
        :type user_fields: List[str]
        :param expansions: A comma separated list of fields to expand.
        :type expansions: List[str]
        :param tweet_fields: A comma separated list of Tweet fields to display.
        :type tweet_fields: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._users_id_muting_serialize(
            id=id,
            max_results=max_results,
            pagination_token=pagination_token,
            user_fields=user_fields,
            expansions=expansions,
            tweet_fields=tweet_fields,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Get2UsersIdMutingResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def users_id_muting_with_http_info(
        self,
        id: Annotated[StrictStr, Field(description="The ID of the authenticated source User for whom to return results.")],
        max_results: Annotated[Optional[Annotated[int, Field(le=1000, strict=True, ge=1)]], Field(description="The maximum number of results.")] = None,
        pagination_token: Annotated[Optional[Annotated[str, Field(min_length=1, strict=True, max_length=19)]], Field(description="This parameter is used to get the next 'page' of results.")] = None,
        user_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of User fields to display.")] = None,
        expansions: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of fields to expand.")] = None,
        tweet_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of Tweet fields to display.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[Get2UsersIdMutingResponse]:
        """Returns User objects that are muted by the provided User ID

        Returns a list of Users that are muted by the provided User ID

        :param id: The ID of the authenticated source User for whom to return results. (required)
        :type id: str
        :param max_results: The maximum number of results.
        :type max_results: int
        :param pagination_token: This parameter is used to get the next 'page' of results.
        :type pagination_token: str
        :param user_fields: A comma separated list of User fields to display.
        :type user_fields: List[str]
        :param expansions: A comma separated list of fields to expand.
        :type expansions: List[str]
        :param tweet_fields: A comma separated list of Tweet fields to display.
        :type tweet_fields: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._users_id_muting_serialize(
            id=id,
            max_results=max_results,
            pagination_token=pagination_token,
            user_fields=user_fields,
            expansions=expansions,
            tweet_fields=tweet_fields,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Get2UsersIdMutingResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def users_id_muting_without_preload_content(
        self,
        id: Annotated[StrictStr, Field(description="The ID of the authenticated source User for whom to return results.")],
        max_results: Annotated[Optional[Annotated[int, Field(le=1000, strict=True, ge=1)]], Field(description="The maximum number of results.")] = None,
        pagination_token: Annotated[Optional[Annotated[str, Field(min_length=1, strict=True, max_length=19)]], Field(description="This parameter is used to get the next 'page' of results.")] = None,
        user_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of User fields to display.")] = None,
        expansions: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of fields to expand.")] = None,
        tweet_fields: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1)]], Field(description="A comma separated list of Tweet fields to display.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Returns User objects that are muted by the provided User ID

        Returns a list of Users that are muted by the provided User ID

        :param id: The ID of the authenticated source User for whom to return results. (required)
        :type id: str
        :param max_results: The maximum number of results.
        :type max_results: int
        :param pagination_token: This parameter is used to get the next 'page' of results.
        :type pagination_token: str
        :param user_fields: A comma separated list of User fields to display.
        :type user_fields: List[str]
        :param expansions: A comma separated list of fields to expand.
        :type expansions: List[str]
        :param tweet_fields: A comma separated list of Tweet fields to display.
        :type tweet_fields: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._users_id_muting_serialize(
            id=id,
            max_results=max_results,
            pagination_token=pagination_token,
            user_fields=user_fields,
            expansions=expansions,
            tweet_fields=tweet_fields,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Get2UsersIdMutingResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _users_id_muting_serialize(
        self,
        id,
        max_results,
        pagination_token,
        user_fields,
        expansions,
        tweet_fields,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'user.fields': 'csv',
            'expansions': 'csv',
            'tweet.fields': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        if max_results is not None:
            
            _query_params.append(('max_results', max_results))
            
        if pagination_token is not None:
            
            _query_params.append(('pagination_token', pagination_token))
            
        if user_fields is not None:
            
            _query_params.append(('user.fields', user_fields))
            
        if expansions is not None:
            
            _query_params.append(('expansions', expansions))
            
        if tweet_fields is not None:
            
            _query_params.append(('tweet.fields', tweet_fields))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json', 
                    'application/problem+json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'OAuth2UserToken', 
            'UserToken'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/2/users/{id}/muting',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def users_id_unblock(
        self,
        source_user_id: Annotated[StrictStr, Field(description="The ID of the authenticated source User that is requesting to unblock the target User.")],
        target_user_id: Annotated[str, Field(strict=True, description="The ID of the User that the source User is requesting to unblock.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> BlockUserMutationResponse:
        """Unblock User by User ID

        Causes the source User to unblock the target User. The source User must match the User context authorizing the request

        :param source_user_id: The ID of the authenticated source User that is requesting to unblock the target User. (required)
        :type source_user_id: str
        :param target_user_id: The ID of the User that the source User is requesting to unblock. (required)
        :type target_user_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._users_id_unblock_serialize(
            source_user_id=source_user_id,
            target_user_id=target_user_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "BlockUserMutationResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def users_id_unblock_with_http_info(
        self,
        source_user_id: Annotated[StrictStr, Field(description="The ID of the authenticated source User that is requesting to unblock the target User.")],
        target_user_id: Annotated[str, Field(strict=True, description="The ID of the User that the source User is requesting to unblock.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[BlockUserMutationResponse]:
        """Unblock User by User ID

        Causes the source User to unblock the target User. The source User must match the User context authorizing the request

        :param source_user_id: The ID of the authenticated source User that is requesting to unblock the target User. (required)
        :type source_user_id: str
        :param target_user_id: The ID of the User that the source User is requesting to unblock. (required)
        :type target_user_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._users_id_unblock_serialize(
            source_user_id=source_user_id,
            target_user_id=target_user_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "BlockUserMutationResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def users_id_unblock_without_preload_content(
        self,
        source_user_id: Annotated[StrictStr, Field(description="The ID of the authenticated source User that is requesting to unblock the target User.")],
        target_user_id: Annotated[str, Field(strict=True, description="The ID of the User that the source User is requesting to unblock.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Unblock User by User ID

        Causes the source User to unblock the target User. The source User must match the User context authorizing the request

        :param source_user_id: The ID of the authenticated source User that is requesting to unblock the target User. (required)
        :type source_user_id: str
        :param target_user_id: The ID of the User that the source User is requesting to unblock. (required)
        :type target_user_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._users_id_unblock_serialize(
            source_user_id=source_user_id,
            target_user_id=target_user_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "BlockUserMutationResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _users_id_unblock_serialize(
        self,
        source_user_id,
        target_user_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if source_user_id is not None:
            _path_params['source_user_id'] = source_user_id
        if target_user_id is not None:
            _path_params['target_user_id'] = target_user_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json', 
                    'application/problem+json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'OAuth2UserToken', 
            'UserToken'
        ]

        return self.api_client.param_serialize(
            method='DELETE',
            resource_path='/2/users/{source_user_id}/blocking/{target_user_id}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def users_id_unfollow(
        self,
        source_user_id: Annotated[StrictStr, Field(description="The ID of the authenticated source User that is requesting to unfollow the target User.")],
        target_user_id: Annotated[str, Field(strict=True, description="The ID of the User that the source User is requesting to unfollow.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> UsersFollowingDeleteResponse:
        """Unfollow User

        Causes the source User to unfollow the target User. The source User must match the User context authorizing the request

        :param source_user_id: The ID of the authenticated source User that is requesting to unfollow the target User. (required)
        :type source_user_id: str
        :param target_user_id: The ID of the User that the source User is requesting to unfollow. (required)
        :type target_user_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._users_id_unfollow_serialize(
            source_user_id=source_user_id,
            target_user_id=target_user_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "UsersFollowingDeleteResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def users_id_unfollow_with_http_info(
        self,
        source_user_id: Annotated[StrictStr, Field(description="The ID of the authenticated source User that is requesting to unfollow the target User.")],
        target_user_id: Annotated[str, Field(strict=True, description="The ID of the User that the source User is requesting to unfollow.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[UsersFollowingDeleteResponse]:
        """Unfollow User

        Causes the source User to unfollow the target User. The source User must match the User context authorizing the request

        :param source_user_id: The ID of the authenticated source User that is requesting to unfollow the target User. (required)
        :type source_user_id: str
        :param target_user_id: The ID of the User that the source User is requesting to unfollow. (required)
        :type target_user_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._users_id_unfollow_serialize(
            source_user_id=source_user_id,
            target_user_id=target_user_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "UsersFollowingDeleteResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def users_id_unfollow_without_preload_content(
        self,
        source_user_id: Annotated[StrictStr, Field(description="The ID of the authenticated source User that is requesting to unfollow the target User.")],
        target_user_id: Annotated[str, Field(strict=True, description="The ID of the User that the source User is requesting to unfollow.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Unfollow User

        Causes the source User to unfollow the target User. The source User must match the User context authorizing the request

        :param source_user_id: The ID of the authenticated source User that is requesting to unfollow the target User. (required)
        :type source_user_id: str
        :param target_user_id: The ID of the User that the source User is requesting to unfollow. (required)
        :type target_user_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._users_id_unfollow_serialize(
            source_user_id=source_user_id,
            target_user_id=target_user_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "UsersFollowingDeleteResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _users_id_unfollow_serialize(
        self,
        source_user_id,
        target_user_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if source_user_id is not None:
            _path_params['source_user_id'] = source_user_id
        if target_user_id is not None:
            _path_params['target_user_id'] = target_user_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json', 
                    'application/problem+json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'OAuth2UserToken', 
            'UserToken'
        ]

        return self.api_client.param_serialize(
            method='DELETE',
            resource_path='/2/users/{source_user_id}/following/{target_user_id}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def users_id_unmute(
        self,
        source_user_id: Annotated[StrictStr, Field(description="The ID of the authenticated source User that is requesting to unmute the target User.")],
        target_user_id: Annotated[str, Field(strict=True, description="The ID of the User that the source User is requesting to unmute.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> MuteUserMutationResponse:
        """Unmute User by User ID

        Causes the source User to unmute the target User. The source User must match the User context authorizing the request

        :param source_user_id: The ID of the authenticated source User that is requesting to unmute the target User. (required)
        :type source_user_id: str
        :param target_user_id: The ID of the User that the source User is requesting to unmute. (required)
        :type target_user_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._users_id_unmute_serialize(
            source_user_id=source_user_id,
            target_user_id=target_user_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "MuteUserMutationResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def users_id_unmute_with_http_info(
        self,
        source_user_id: Annotated[StrictStr, Field(description="The ID of the authenticated source User that is requesting to unmute the target User.")],
        target_user_id: Annotated[str, Field(strict=True, description="The ID of the User that the source User is requesting to unmute.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[MuteUserMutationResponse]:
        """Unmute User by User ID

        Causes the source User to unmute the target User. The source User must match the User context authorizing the request

        :param source_user_id: The ID of the authenticated source User that is requesting to unmute the target User. (required)
        :type source_user_id: str
        :param target_user_id: The ID of the User that the source User is requesting to unmute. (required)
        :type target_user_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._users_id_unmute_serialize(
            source_user_id=source_user_id,
            target_user_id=target_user_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "MuteUserMutationResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def users_id_unmute_without_preload_content(
        self,
        source_user_id: Annotated[StrictStr, Field(description="The ID of the authenticated source User that is requesting to unmute the target User.")],
        target_user_id: Annotated[str, Field(strict=True, description="The ID of the User that the source User is requesting to unmute.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Unmute User by User ID

        Causes the source User to unmute the target User. The source User must match the User context authorizing the request

        :param source_user_id: The ID of the authenticated source User that is requesting to unmute the target User. (required)
        :type source_user_id: str
        :param target_user_id: The ID of the User that the source User is requesting to unmute. (required)
        :type target_user_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._users_id_unmute_serialize(
            source_user_id=source_user_id,
            target_user_id=target_user_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "MuteUserMutationResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _users_id_unmute_serialize(
        self,
        source_user_id,
        target_user_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if source_user_id is not None:
            _path_params['source_user_id'] = source_user_id
        if target_user_id is not None:
            _path_params['target_user_id'] = target_user_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json', 
                    'application/problem+json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'OAuth2UserToken', 
            'UserToken'
        ]

        return self.api_client.param_serialize(
            method='DELETE',
            resource_path='/2/users/{source_user_id}/muting/{target_user_id}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )


