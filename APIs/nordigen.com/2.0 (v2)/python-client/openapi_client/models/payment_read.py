# coding: utf-8

"""
    Nordigen Account Information Services API

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

    The version of the OpenAPI document: 2.0 (v2)
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictStr
from typing import Any, ClassVar, Dict, List, Optional
from typing_extensions import Annotated
from openapi_client.models.creditor_account_write import CreditorAccountWrite
from openapi_client.models.debtor_account_write import DebtorAccountWrite
from openapi_client.models.instructed_amount import InstructedAmount
from openapi_client.models.payment_product_enum import PaymentProductEnum
from openapi_client.models.payment_status_enum import PaymentStatusEnum
from openapi_client.models.payment_type_enum import PaymentTypeEnum
from typing import Optional, Set
from typing_extensions import Self

class PaymentRead(BaseModel):
    """
    PaymentReadSerializer.
    """ # noqa: E501
    creditor_account: Optional[StrictStr] = Field(default=None, description="Registered creditor account")
    creditor_object: Optional[CreditorAccountWrite] = Field(default=None, description="Creditor account")
    custom_payment_id: Optional[Annotated[str, Field(strict=True, max_length=35)]] = Field(default=None, description="Payment Custom Payment ID")
    debtor_account: DebtorAccountWrite
    description: Optional[StrictStr] = Field(default='GOCARDLESS', description="Payment description")
    instructed_amount: InstructedAmount = Field(description="Instructed amount")
    payment_id: Optional[StrictStr] = Field(default=None, description="Payment ID")
    payment_product: Optional[PaymentProductEnum] = Field(default=None, description="Payment product  * `T2P` - target-2-payments * `SCT` - sepa-credit-transfers * `ISCT` - instant-sepa-credit-transfer * `CBCT` - cross-border-credit-transfers * `BACS` - Back Payment Scheme * `CHAPS` - CHAPS Payment Scheme * `FPS` - Faster Payment Scheme * `SWIFT` - Swift Payment Service * `BT` - Balance Transfer * `MT` - Money Transfer")
    payment_status: Optional[PaymentStatusEnum] = Field(default=None, description="Payment end to end identification  * `INIT` - Initiated. Payment has been initiated. * `ERRE` - ExecutionError. We experienced error on payment execution. * `ERRS` - StatusError. We experienced error retrieving payment status. Try again. * `ACCC` - AcceptedSettlementCompleted. Settlement on the creditor's account has been completed * `ACCP` - AcceptedCustomerProfile. Preceding check of technical validation was successful. Customer profile check was successful * `ACSC` - AcceptedSettlementCompleted. Settlement on the debtor’s account has been completed * `ACSP` - AcceptedSettlementInProcess. All preceding checks such as technical validation and customer profile were successful and therefore the payment initiation has been accepted for execution * `ACTC` - AcceptedTechnicalValidation. Authentication and syntactical and semantical validation are successful * `ACWC` - AcceptedWithChange. Instruction is accepted but a change will be made, such as date or remittance not sent * `ACWP` - AcceptedWithoutPosting. Payment instruction included in the credit transfer is accepted without being posted to the creditor customer’s account * `RCVD` - Received. Payment initiation has been received by the receiving agent * `PDNG` - Pending. Payment initiation or individual transaction included in the payment initiation is pending. Further checks and status update will be performed * `RJCT` - Rejected. Payment initiation or individual transaction included in the payment initiation has been rejected. * `CANC` - Cancelled. Payment initiation has been cancelled before execution * `ACFC` - AcceptedFundsChecked. Pre-ceeding check of technical validation and customer profile was successful and an automatic funds check was positive * `PATC` - PartiallyAcceptedTechnicalCorrect. The payment initiation needs multiple authentications, where some but not yet all have been performed * `PART` - PartiallyAccepted. A number of transactions have been accepted, whereas another number of transactions have not yet achieved 'accepted' status")
    payment_type: Optional[PaymentTypeEnum] = Field(default=None, description="Payment Type  * `single-payment` - payment * `bulk-payment` - bulk-payments * `periodic-payment` - periodic-payments")
    redirect: Optional[Annotated[str, Field(strict=True, max_length=1024)]] = Field(description="Redirect URL to your application after payment is done")
    __properties: ClassVar[List[str]] = ["creditor_account", "creditor_object", "custom_payment_id", "debtor_account", "description", "instructed_amount", "payment_id", "payment_product", "payment_status", "payment_type", "redirect"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of PaymentRead from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        """
        excluded_fields: Set[str] = set([
            "payment_id",
            "payment_status",
            "payment_type",
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of creditor_object
        if self.creditor_object:
            _dict['creditor_object'] = self.creditor_object.to_dict()
        # override the default output from pydantic by calling `to_dict()` of debtor_account
        if self.debtor_account:
            _dict['debtor_account'] = self.debtor_account.to_dict()
        # override the default output from pydantic by calling `to_dict()` of instructed_amount
        if self.instructed_amount:
            _dict['instructed_amount'] = self.instructed_amount.to_dict()
        # set to None if redirect (nullable) is None
        # and model_fields_set contains the field
        if self.redirect is None and "redirect" in self.model_fields_set:
            _dict['redirect'] = None

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of PaymentRead from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "creditor_account": obj.get("creditor_account"),
            "creditor_object": CreditorAccountWrite.from_dict(obj["creditor_object"]) if obj.get("creditor_object") is not None else None,
            "custom_payment_id": obj.get("custom_payment_id"),
            "debtor_account": DebtorAccountWrite.from_dict(obj["debtor_account"]) if obj.get("debtor_account") is not None else None,
            "description": obj.get("description") if obj.get("description") is not None else 'GOCARDLESS',
            "instructed_amount": InstructedAmount.from_dict(obj["instructed_amount"]) if obj.get("instructed_amount") is not None else None,
            "payment_id": obj.get("payment_id"),
            "payment_product": obj.get("payment_product"),
            "payment_status": obj.get("payment_status"),
            "payment_type": obj.get("payment_type"),
            "redirect": obj.get("redirect")
        })
        return _obj


