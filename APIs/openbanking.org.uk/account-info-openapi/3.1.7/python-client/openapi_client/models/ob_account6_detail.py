# coding: utf-8

"""
    Account and Transaction API Specification

    Swagger for Account and Transaction API Specification

    The version of the OpenAPI document: 3.1.7
    Contact: ServiceDesk@openbanking.org.uk
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from datetime import datetime
from pydantic import BaseModel, ConfigDict, Field, StrictStr, field_validator
from typing import Any, ClassVar, Dict, List, Optional
from typing_extensions import Annotated
from openapi_client.models.ob_account4_account_inner import OBAccount4AccountInner
from openapi_client.models.ob_account_status1_code import OBAccountStatus1Code
from openapi_client.models.ob_branch_and_financial_institution_identification50 import OBBranchAndFinancialInstitutionIdentification50
from openapi_client.models.ob_external_account_sub_type1_code import OBExternalAccountSubType1Code
from openapi_client.models.ob_external_account_type1_code import OBExternalAccountType1Code
from typing import Optional, Set
from typing_extensions import Self

class OBAccount6Detail(BaseModel):
    """
    Unambiguous identification of the account to which credit and debit entries are made.
    """ # noqa: E501
    account: List[OBAccount4AccountInner] = Field(alias="Account")
    account_id: Annotated[str, Field(min_length=1, strict=True, max_length=40)] = Field(description="A unique and immutable identifier used to identify the account resource. This identifier has no meaning to the account owner.", alias="AccountId")
    account_sub_type: OBExternalAccountSubType1Code = Field(alias="AccountSubType")
    account_type: OBExternalAccountType1Code = Field(alias="AccountType")
    currency: Annotated[str, Field(strict=True)] = Field(description="Identification of the currency in which the account is held.  Usage: Currency should only be used in case one and the same account number covers several currencies and the initiating party needs to identify which currency needs to be used for settlement on the account.", alias="Currency")
    description: Optional[Annotated[str, Field(min_length=1, strict=True, max_length=35)]] = Field(default=None, description="Specifies the description of the account type.", alias="Description")
    maturity_date: Optional[datetime] = Field(default=None, description="Maturity date of the account.All dates in the JSON payloads are represented in ISO 8601 date-time format.  All date-time fields in responses must include the timezone. An example is below: 2017-04-05T10:43:07+00:00", alias="MaturityDate")
    nickname: Optional[Annotated[str, Field(min_length=1, strict=True, max_length=70)]] = Field(default=None, description="The nickname of the account, assigned by the account owner in order to provide an additional means of identification of the account.", alias="Nickname")
    opening_date: Optional[datetime] = Field(default=None, description="Date on which the account and related basic services are effectively operational for the account owner.All dates in the JSON payloads are represented in ISO 8601 date-time format.  All date-time fields in responses must include the timezone. An example is below: 2017-04-05T10:43:07+00:00", alias="OpeningDate")
    servicer: Optional[OBBranchAndFinancialInstitutionIdentification50] = Field(default=None, alias="Servicer")
    status: Optional[OBAccountStatus1Code] = Field(default=None, alias="Status")
    status_update_date_time: Optional[datetime] = Field(default=None, description="Date and time at which the resource status was updated.All dates in the JSON payloads are represented in ISO 8601 date-time format.  All date-time fields in responses must include the timezone. An example is below: 2017-04-05T10:43:07+00:00", alias="StatusUpdateDateTime")
    switch_status: Optional[StrictStr] = Field(default=None, description="Specifies the switch status for the account, in a coded form.", alias="SwitchStatus")
    __properties: ClassVar[List[str]] = ["Account", "AccountId", "AccountSubType", "AccountType", "Currency", "Description", "MaturityDate", "Nickname", "OpeningDate", "Servicer", "Status", "StatusUpdateDateTime", "SwitchStatus"]

    @field_validator('currency')
    def currency_validate_regular_expression(cls, value):
        """Validates the regular expression"""
        if not re.match(r"^[A-Z]{3,3}$", value):
            raise ValueError(r"must validate the regular expression /^[A-Z]{3,3}$/")
        return value

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of OBAccount6Detail from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of each item in account (list)
        _items = []
        if self.account:
            for _item_account in self.account:
                if _item_account:
                    _items.append(_item_account.to_dict())
            _dict['Account'] = _items
        # override the default output from pydantic by calling `to_dict()` of servicer
        if self.servicer:
            _dict['Servicer'] = self.servicer.to_dict()
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of OBAccount6Detail from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "Account": [OBAccount4AccountInner.from_dict(_item) for _item in obj["Account"]] if obj.get("Account") is not None else None,
            "AccountId": obj.get("AccountId"),
            "AccountSubType": obj.get("AccountSubType"),
            "AccountType": obj.get("AccountType"),
            "Currency": obj.get("Currency"),
            "Description": obj.get("Description"),
            "MaturityDate": obj.get("MaturityDate"),
            "Nickname": obj.get("Nickname"),
            "OpeningDate": obj.get("OpeningDate"),
            "Servicer": OBBranchAndFinancialInstitutionIdentification50.from_dict(obj["Servicer"]) if obj.get("Servicer") is not None else None,
            "Status": obj.get("Status"),
            "StatusUpdateDateTime": obj.get("StatusUpdateDateTime"),
            "SwitchStatus": obj.get("SwitchStatus")
        })
        return _obj


