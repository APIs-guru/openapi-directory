# coding: utf-8

"""
    Open Data API

    Latest Swagger specification for OpenData

    The version of the OpenAPI document: v1.3
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictStr, field_validator
from typing import Any, ClassVar, Dict, List, Optional
from typing_extensions import Annotated
from openapi_client.models.atm_geographic_location import ATMGeographicLocation
from openapi_client.models.atm_organisation import ATMOrganisation
from openapi_client.models.branch_address import BranchAddress
from openapi_client.models.branch_alternate_phone_inner import BranchAlternatePhoneInner
from openapi_client.models.branch_planned_branch_closure_inner import BranchPlannedBranchClosureInner
from typing import Optional, Set
from typing_extensions import Self

class Branch(BaseModel):
    """
    Branch
    """ # noqa: E501
    atmat_branch: StrictBool = Field(description="Indicated whether an ATM is at the branch", alias="ATMAtBranch")
    accessibility_types: Optional[StrictStr] = Field(default=None, description="Information about the accessibility", alias="AccessibilityTypes")
    address: BranchAddress = Field(alias="Address")
    alternate_phone: Optional[List[BranchAlternatePhoneInner]] = Field(default=None, alias="AlternatePhone")
    arrival_time: Optional[Annotated[str, Field(strict=True)]] = Field(default=None, description="Time that the mobile branch is scheduled to arrive", alias="ArrivalTime")
    branch_description: Optional[Annotated[str, Field(min_length=1, strict=True, max_length=140)]] = Field(default=None, description="Description of the branch", alias="BranchDescription")
    branch_facilities_name: Optional[List[StrictStr]] = Field(default=None, description="Information about branch facilities", alias="BranchFacilitiesName")
    branch_identification: Annotated[str, Field(min_length=1, strict=True, max_length=35)] = Field(description="Unique and unambiguous identification of a retail branch of a financial institution", alias="BranchIdentification")
    branch_mediated_service_name: Optional[List[StrictStr]] = Field(default=None, description="Information about mediated branch facilities", alias="BranchMediatedServiceName")
    branch_name: Optional[Annotated[str, Field(min_length=1, strict=True, max_length=35)]] = Field(default=None, description="Name by which a party is known and which is usually used to identify that party", alias="BranchName")
    branch_other_facilities: Optional[List[Annotated[str, Field(min_length=1, strict=True, max_length=350)]]] = Field(default=None, description="Any other facilities not mentioned in BranchFacilitiesName", alias="BranchOtherFacilities")
    branch_other_mediated_services: Optional[List[Annotated[str, Field(min_length=1, strict=True, max_length=350)]]] = Field(default=None, description="Mediated Services not described in BranchMediatedServiceName", alias="BranchOtherMediatedServices")
    branch_other_self_services: Optional[List[Annotated[str, Field(min_length=1, strict=True, max_length=350)]]] = Field(default=None, description="Self Services not described in BranchSelfServeServiceName", alias="BranchOtherSelfServices")
    branch_photo: Optional[StrictStr] = Field(default=None, description="Image related to the branch", alias="BranchPhoto")
    branch_self_serve_service_name: Optional[List[StrictStr]] = Field(default=None, alias="BranchSelfServeServiceName")
    branch_type: StrictStr = Field(description="Information on the type of branch", alias="BranchType")
    customer_segment: List[StrictStr] = Field(description="Customer segment which the branch is able to service", alias="CustomerSegment")
    days_of_the_week: Optional[Annotated[str, Field(min_length=1, strict=True, max_length=35)]] = Field(default=None, description="Description on when the mobile branch is available. e.g. The weekend of Glastonbury festival; or Mondays and during the shrimp season also Wednesdays", alias="DaysOfTheWeek")
    departure_time: Optional[Annotated[str, Field(strict=True)]] = Field(default=None, description="Time that the mobile branch is scheduled to depart", alias="DepartureTime")
    fax_number: Optional[List[Annotated[str, Field(strict=True)]]] = Field(default=None, description="Collection of information that identifies a FAX number, as defined by telecom services.", alias="FaxNumber")
    geographic_location: Optional[ATMGeographicLocation] = Field(default=None, alias="GeographicLocation")
    opening_times: Annotated[List[object], Field(min_length=1)] = Field(description="Branch Opening Times", alias="OpeningTimes")
    organisation: ATMOrganisation = Field(alias="Organisation")
    parking_location: Optional[Annotated[str, Field(min_length=1, strict=True, max_length=50)]] = Field(default=None, description="Place where the mobile branch is located, such as between the news agent and the church.", alias="ParkingLocation")
    planned_branch_closure: Optional[List[BranchPlannedBranchClosureInner]] = Field(default=None, alias="PlannedBranchClosure")
    stop_name: Optional[Annotated[str, Field(min_length=1, strict=True, max_length=15)]] = Field(default=None, description="Name of the stop of the mobile branch", alias="StopName")
    telephone_number: Annotated[str, Field(strict=True)] = Field(description="Collection of information that identifies a phone number, as defined by telecom services.", alias="TelephoneNumber")
    __properties: ClassVar[List[str]] = ["ATMAtBranch", "AccessibilityTypes", "Address", "AlternatePhone", "ArrivalTime", "BranchDescription", "BranchFacilitiesName", "BranchIdentification", "BranchMediatedServiceName", "BranchName", "BranchOtherFacilities", "BranchOtherMediatedServices", "BranchOtherSelfServices", "BranchPhoto", "BranchSelfServeServiceName", "BranchType", "CustomerSegment", "DaysOfTheWeek", "DepartureTime", "FaxNumber", "GeographicLocation", "OpeningTimes", "Organisation", "ParkingLocation", "PlannedBranchClosure", "StopName", "TelephoneNumber"]

    @field_validator('accessibility_types')
    def accessibility_types_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['AudioCashMachine', 'AutomaticDoors', 'ChairAccess', 'DriveThru', 'ExternalRamp', 'InductionLoop', 'InternalRamp', 'LevelAccess', 'LowerLevelCounter', 'WheelchairAccess']):
            raise ValueError("must be one of enum values ('AudioCashMachine', 'AutomaticDoors', 'ChairAccess', 'DriveThru', 'ExternalRamp', 'InductionLoop', 'InternalRamp', 'LevelAccess', 'LowerLevelCounter', 'WheelchairAccess')")
        return value

    @field_validator('arrival_time')
    def arrival_time_validate_regular_expression(cls, value):
        """Validates the regular expression"""
        if value is None:
            return value

        if not re.match(r"^(([0-9]|0[0-9]|1[0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9].\d{3})|(^24:00:00\.000)(?:Z|[+-](?:2[0-3]|[01][0-9]):[0-5][0-9])?$", value):
            raise ValueError(r"must validate the regular expression /^(([0-9]|0[0-9]|1[0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9].\d{3})|(^24:00:00\.000)(?:Z|[+-](?:2[0-3]|[01][0-9]):[0-5][0-9])?$/")
        return value

    @field_validator('branch_facilities_name')
    def branch_facilities_name_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        for i in value:
            if i not in set(['BusinessITSupport', 'CollectionLockers', 'MeetingRooms', 'Parking', 'Wifi']):
                raise ValueError("each list item must be one of ('BusinessITSupport', 'CollectionLockers', 'MeetingRooms', 'Parking', 'Wifi')")
        return value

    @field_validator('branch_mediated_service_name')
    def branch_mediated_service_name_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        for i in value:
            if i not in set(['BureauDeChange', 'BusinessCounter', 'CardIssuanceFacility', 'CounterServices', 'DriveThru', 'MortgageAdvisor', 'NightSafe', 'OnDemandCurrency', 'PremierCounter', 'VideoBanking', 'WheelChairAccess']):
                raise ValueError("each list item must be one of ('BureauDeChange', 'BusinessCounter', 'CardIssuanceFacility', 'CounterServices', 'DriveThru', 'MortgageAdvisor', 'NightSafe', 'OnDemandCurrency', 'PremierCounter', 'VideoBanking', 'WheelChairAccess')")
        return value

    @field_validator('branch_self_serve_service_name')
    def branch_self_serve_service_name_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        for i in value:
            if i not in set(['AccountVerificationService', 'AssistedServiceCounter', 'BusinessDepositTerminal', 'CashChequeDepositMachineCoin', 'CashChequeDepositMachineNoCoin', 'ExternalAtmAudio', 'ExternalAtmNoAudio', 'ExternalQuickServicePoint', 'InternalAtmAudio', 'InternalAtmNoAudio', 'InternalQuickServicePoint', 'LodgementDevice', 'OnlineBankingPoint', 'QuickDeposit', 'SaturdayCounterService', 'SelfServiceAccountOpening', 'StatementPrinter']):
                raise ValueError("each list item must be one of ('AccountVerificationService', 'AssistedServiceCounter', 'BusinessDepositTerminal', 'CashChequeDepositMachineCoin', 'CashChequeDepositMachineNoCoin', 'ExternalAtmAudio', 'ExternalAtmNoAudio', 'ExternalQuickServicePoint', 'InternalAtmAudio', 'InternalAtmNoAudio', 'InternalQuickServicePoint', 'LodgementDevice', 'OnlineBankingPoint', 'QuickDeposit', 'SaturdayCounterService', 'SelfServiceAccountOpening', 'StatementPrinter')")
        return value

    @field_validator('branch_type')
    def branch_type_validate_enum(cls, value):
        """Validates the enum"""
        if value not in set(['Physical', 'Mobile']):
            raise ValueError("must be one of enum values ('Physical', 'Mobile')")
        return value

    @field_validator('customer_segment')
    def customer_segment_validate_enum(cls, value):
        """Validates the enum"""
        for i in value:
            if i not in set(['Business', 'Corporate', 'Personal', 'Premier', 'Private', 'Select', 'SME', 'Wealth']):
                raise ValueError("each list item must be one of ('Business', 'Corporate', 'Personal', 'Premier', 'Private', 'Select', 'SME', 'Wealth')")
        return value

    @field_validator('departure_time')
    def departure_time_validate_regular_expression(cls, value):
        """Validates the regular expression"""
        if value is None:
            return value

        if not re.match(r"^(([0-9]|0[0-9]|1[0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9].\d{3})|(^24:00:00\.000)(?:Z|[+-](?:2[0-3]|[01][0-9]):[0-5][0-9])?$", value):
            raise ValueError(r"must validate the regular expression /^(([0-9]|0[0-9]|1[0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9].\d{3})|(^24:00:00\.000)(?:Z|[+-](?:2[0-3]|[01][0-9]):[0-5][0-9])?$/")
        return value

    @field_validator('telephone_number')
    def telephone_number_validate_regular_expression(cls, value):
        """Validates the regular expression"""
        if not re.match(r"^[+][0-9]{1,3}-[0-9()+-]{1,30}$", value):
            raise ValueError(r"must validate the regular expression /^[+][0-9]{1,3}-[0-9()+-]{1,30}$/")
        return value

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of Branch from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of address
        if self.address:
            _dict['Address'] = self.address.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in alternate_phone (list)
        _items = []
        if self.alternate_phone:
            for _item_alternate_phone in self.alternate_phone:
                if _item_alternate_phone:
                    _items.append(_item_alternate_phone.to_dict())
            _dict['AlternatePhone'] = _items
        # override the default output from pydantic by calling `to_dict()` of geographic_location
        if self.geographic_location:
            _dict['GeographicLocation'] = self.geographic_location.to_dict()
        # override the default output from pydantic by calling `to_dict()` of organisation
        if self.organisation:
            _dict['Organisation'] = self.organisation.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in planned_branch_closure (list)
        _items = []
        if self.planned_branch_closure:
            for _item_planned_branch_closure in self.planned_branch_closure:
                if _item_planned_branch_closure:
                    _items.append(_item_planned_branch_closure.to_dict())
            _dict['PlannedBranchClosure'] = _items
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of Branch from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "ATMAtBranch": obj.get("ATMAtBranch"),
            "AccessibilityTypes": obj.get("AccessibilityTypes"),
            "Address": BranchAddress.from_dict(obj["Address"]) if obj.get("Address") is not None else None,
            "AlternatePhone": [BranchAlternatePhoneInner.from_dict(_item) for _item in obj["AlternatePhone"]] if obj.get("AlternatePhone") is not None else None,
            "ArrivalTime": obj.get("ArrivalTime"),
            "BranchDescription": obj.get("BranchDescription"),
            "BranchFacilitiesName": obj.get("BranchFacilitiesName"),
            "BranchIdentification": obj.get("BranchIdentification"),
            "BranchMediatedServiceName": obj.get("BranchMediatedServiceName"),
            "BranchName": obj.get("BranchName"),
            "BranchOtherFacilities": obj.get("BranchOtherFacilities"),
            "BranchOtherMediatedServices": obj.get("BranchOtherMediatedServices"),
            "BranchOtherSelfServices": obj.get("BranchOtherSelfServices"),
            "BranchPhoto": obj.get("BranchPhoto"),
            "BranchSelfServeServiceName": obj.get("BranchSelfServeServiceName"),
            "BranchType": obj.get("BranchType"),
            "CustomerSegment": obj.get("CustomerSegment"),
            "DaysOfTheWeek": obj.get("DaysOfTheWeek"),
            "DepartureTime": obj.get("DepartureTime"),
            "FaxNumber": obj.get("FaxNumber"),
            "GeographicLocation": ATMGeographicLocation.from_dict(obj["GeographicLocation"]) if obj.get("GeographicLocation") is not None else None,
            "OpeningTimes": obj.get("OpeningTimes"),
            "Organisation": ATMOrganisation.from_dict(obj["Organisation"]) if obj.get("Organisation") is not None else None,
            "ParkingLocation": obj.get("ParkingLocation"),
            "PlannedBranchClosure": [BranchPlannedBranchClosureInner.from_dict(_item) for _item in obj["PlannedBranchClosure"]] if obj.get("PlannedBranchClosure") is not None else None,
            "StopName": obj.get("StopName"),
            "TelephoneNumber": obj.get("TelephoneNumber")
        })
        return _obj


