# coding: utf-8

"""
    Open Data API

    Latest Swagger specification for OpenData

    The version of the OpenAPI document: v1.3
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictStr, field_validator
from typing import Any, ClassVar, Dict, List, Optional
from typing_extensions import Annotated
from openapi_client.models.business_current_account_overdraft_inner_fees_and_charges_inner_fee_charge_other_application_frequency import BusinessCurrentAccountOverdraftInnerFeesAndChargesInnerFeeChargeOtherApplicationFrequency
from typing import Optional, Set
from typing_extensions import Self

class BusinessCurrentAccountOverdraftInnerFeesAndChargesInner(BaseModel):
    """
    Overdraft Fees Charges
    """ # noqa: E501
    fee_charge_amount: Optional[Annotated[str, Field(strict=True)]] = Field(default=None, description="Charge applied to tier", alias="FeeChargeAmount")
    fee_charge_application_frequency: Optional[StrictStr] = Field(default=None, description="Frequency with which the rate, or amount is charged", alias="FeeChargeApplicationFrequency")
    fee_charge_calculation_frequency: Optional[StrictStr] = Field(default=None, description="Frequency with which the rate, or amount is calculated", alias="FeeChargeCalculationFrequency")
    fee_charge_other_application_frequency: Optional[BusinessCurrentAccountOverdraftInnerFeesAndChargesInnerFeeChargeOtherApplicationFrequency] = Field(default=None, alias="FeeChargeOtherApplicationFrequency")
    fee_charge_other_calculation_frequency: Optional[BusinessCurrentAccountOverdraftInnerFeesAndChargesInnerFeeChargeOtherApplicationFrequency] = Field(default=None, alias="FeeChargeOtherCalculationFrequency")
    fee_charge_other_type: Optional[BusinessCurrentAccountOverdraftInnerFeesAndChargesInnerFeeChargeOtherApplicationFrequency] = Field(default=None, alias="FeeChargeOtherType")
    fee_charge_rate: Optional[Annotated[str, Field(strict=True)]] = Field(default=None, description="Fee charge rate applied to tier", alias="FeeChargeRate")
    fee_charge_rate_other_type: Optional[BusinessCurrentAccountOverdraftInnerFeesAndChargesInnerFeeChargeOtherApplicationFrequency] = Field(default=None, alias="FeeChargeRateOtherType")
    fee_charge_rate_type: Optional[StrictStr] = Field(default=None, description="Rate type other than EAR", alias="FeeChargeRateType")
    fee_charge_type: StrictStr = Field(description="Type of fee or charge", alias="FeeChargeType")
    __properties: ClassVar[List[str]] = ["FeeChargeAmount", "FeeChargeApplicationFrequency", "FeeChargeCalculationFrequency", "FeeChargeOtherApplicationFrequency", "FeeChargeOtherCalculationFrequency", "FeeChargeOtherType", "FeeChargeRate", "FeeChargeRateOtherType", "FeeChargeRateType", "FeeChargeType"]

    @field_validator('fee_charge_amount')
    def fee_charge_amount_validate_regular_expression(cls, value):
        """Validates the regular expression"""
        if value is None:
            return value

        if not re.match(r"^-?\d{1,10}\.\d{1,2}$", value):
            raise ValueError(r"must validate the regular expression /^-?\d{1,10}\.\d{1,2}$/")
        return value

    @field_validator('fee_charge_application_frequency')
    def fee_charge_application_frequency_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['AcademicTerm', 'Daily', 'Weekly', 'Monthly', 'Quarterly', 'Half-Yearly', 'Yearly', 'Overnight', 'Other']):
            raise ValueError("must be one of enum values ('AcademicTerm', 'Daily', 'Weekly', 'Monthly', 'Quarterly', 'Half-Yearly', 'Yearly', 'Overnight', 'Other')")
        return value

    @field_validator('fee_charge_calculation_frequency')
    def fee_charge_calculation_frequency_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['AcademicTerm', 'Daily', 'Weekly', 'Monthly', 'Quarterly', 'Half-Yearly', 'Yearly', 'Overnight', 'Other']):
            raise ValueError("must be one of enum values ('AcademicTerm', 'Daily', 'Weekly', 'Monthly', 'Quarterly', 'Half-Yearly', 'Yearly', 'Overnight', 'Other')")
        return value

    @field_validator('fee_charge_rate')
    def fee_charge_rate_validate_regular_expression(cls, value):
        """Validates the regular expression"""
        if value is None:
            return value

        if not re.match(r"^-?\d{1,3}\.\d{1,4}$", value):
            raise ValueError(r"must validate the regular expression /^-?\d{1,3}\.\d{1,4}$/")
        return value

    @field_validator('fee_charge_rate_type')
    def fee_charge_rate_type_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['Gross', 'Net', 'Other']):
            raise ValueError("must be one of enum values ('Gross', 'Net', 'Other')")
        return value

    @field_validator('fee_charge_type')
    def fee_charge_type_validate_enum(cls, value):
        """Validates the enum"""
        if value not in set(['Periodic', 'Minimum', 'Maximum', 'Setup', 'Review', 'Renewal', 'MinimumSetup', 'MaximumSetup', 'Total', 'Item', 'EmergencyLending', 'Other']):
            raise ValueError("must be one of enum values ('Periodic', 'Minimum', 'Maximum', 'Setup', 'Review', 'Renewal', 'MinimumSetup', 'MaximumSetup', 'Total', 'Item', 'EmergencyLending', 'Other')")
        return value

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of BusinessCurrentAccountOverdraftInnerFeesAndChargesInner from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of fee_charge_other_application_frequency
        if self.fee_charge_other_application_frequency:
            _dict['FeeChargeOtherApplicationFrequency'] = self.fee_charge_other_application_frequency.to_dict()
        # override the default output from pydantic by calling `to_dict()` of fee_charge_other_calculation_frequency
        if self.fee_charge_other_calculation_frequency:
            _dict['FeeChargeOtherCalculationFrequency'] = self.fee_charge_other_calculation_frequency.to_dict()
        # override the default output from pydantic by calling `to_dict()` of fee_charge_other_type
        if self.fee_charge_other_type:
            _dict['FeeChargeOtherType'] = self.fee_charge_other_type.to_dict()
        # override the default output from pydantic by calling `to_dict()` of fee_charge_rate_other_type
        if self.fee_charge_rate_other_type:
            _dict['FeeChargeRateOtherType'] = self.fee_charge_rate_other_type.to_dict()
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of BusinessCurrentAccountOverdraftInnerFeesAndChargesInner from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "FeeChargeAmount": obj.get("FeeChargeAmount"),
            "FeeChargeApplicationFrequency": obj.get("FeeChargeApplicationFrequency"),
            "FeeChargeCalculationFrequency": obj.get("FeeChargeCalculationFrequency"),
            "FeeChargeOtherApplicationFrequency": BusinessCurrentAccountOverdraftInnerFeesAndChargesInnerFeeChargeOtherApplicationFrequency.from_dict(obj["FeeChargeOtherApplicationFrequency"]) if obj.get("FeeChargeOtherApplicationFrequency") is not None else None,
            "FeeChargeOtherCalculationFrequency": BusinessCurrentAccountOverdraftInnerFeesAndChargesInnerFeeChargeOtherApplicationFrequency.from_dict(obj["FeeChargeOtherCalculationFrequency"]) if obj.get("FeeChargeOtherCalculationFrequency") is not None else None,
            "FeeChargeOtherType": BusinessCurrentAccountOverdraftInnerFeesAndChargesInnerFeeChargeOtherApplicationFrequency.from_dict(obj["FeeChargeOtherType"]) if obj.get("FeeChargeOtherType") is not None else None,
            "FeeChargeRate": obj.get("FeeChargeRate"),
            "FeeChargeRateOtherType": BusinessCurrentAccountOverdraftInnerFeesAndChargesInnerFeeChargeOtherApplicationFrequency.from_dict(obj["FeeChargeRateOtherType"]) if obj.get("FeeChargeRateOtherType") is not None else None,
            "FeeChargeRateType": obj.get("FeeChargeRateType"),
            "FeeChargeType": obj.get("FeeChargeType")
        })
        return _obj


