# coding: utf-8

"""
    Frankie Financial API

    ------   This API allows developers to integrate the Frankie Financial Compliance Utility into their applications. The API allows:   - Checking name, address, date of birth against national databases   - Validating Australian driver's licences, passports, medicare, visas and other Australian national ID documents   - Validating Australian electricity bills   - Validating NZ driver's licences   - Validating Chinese bank cards and national ID card   - Validating International passports and national ID documents   - PEP, Sanctions, Watchlist and adverse media checking   - Australian visa checks    - Fraud list and fraud background checks   - ID validation and selfie check comparisons.    ------     Industry specific services    - Comparing Australian electricity retailers for a better deal.  ------     KYB specific services    - Query organisation ownership   - Perform KYC & AML checks on shareholders, beneficial owners and office bearers.   - Query credit score and credit reports   - International company searches   - International company profiles    ------   The full version of this documentation along with supplemental articles can be found here:   - https://apidocs.frankiefinancial.com/  The traditional Swagger view of this documentation can be found here:   - https://app.swaggerhub.com/apis-docs/FrankieFinancial/kycutility  ------   Sandbox base URL is:   - https://api.demo.frankiefinancial.io/compliance/v1.2      - We do have an old sandbox at https://sandbox.frankiefinancial.com/compliance/v1.2 but this has been retired.    - All calls are the same as production, only with canned data.     - Full Swagger definition, along with test data for playing in the sandbox can be obtained once initial commercial discussions have commenced.    - Production and optional UAT access will be opened up only to those with a signed commercial contract.    ------   Contact us at hello@frankiefinancial.com to speak with a sales rep about issuing a Customer ID and Sandbox api key. 

    The version of the OpenAPI document: 1.5.3
    Contact: dev-support@frankiefinancial.com
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501

import warnings
from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
from typing import Any, Dict, List, Optional, Tuple, Union
from typing_extensions import Annotated

from pydantic import Field, StrictBool, StrictInt, StrictStr, field_validator
from typing import Optional
from typing_extensions import Annotated
from openapi_client.models.accepted_entity_result_object import AcceptedEntityResultObject
from openapi_client.models.basic_status_result_object import BasicStatusResultObject
from openapi_client.models.check_entity_check_result_object import CheckEntityCheckResultObject
from openapi_client.models.check_result_update_object import CheckResultUpdateObject
from openapi_client.models.entity_check_details_object import EntityCheckDetailsObject
from openapi_client.models.entity_idv_details_object import EntityIDVDetailsObject
from openapi_client.models.entity_idv_result_object import EntityIDVResultObject
from openapi_client.models.entity_object import EntityObject
from openapi_client.models.entity_result_object import EntityResultObject
from openapi_client.models.entity_search_result_object import EntitySearchResultObject

from openapi_client.api_client import ApiClient, RequestSerialized
from openapi_client.api_response import ApiResponse
from openapi_client.rest import RESTResponseType


class EntityApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client


    @validate_call
    def create_check_entity(
        self,
        x_frankie_customer_id: Annotated[StrictStr, Field(description="Customer ID issued by Frankie Financial. This will never change. Your API key, which is mapped to this identity, will change over time. ")],
        check_type: Annotated[StrictStr, Field(description="When creating a new check, you need to define the checks you wish to run.    The checkType is make up of a comma separated list of the types of check you wish to run. The order of the requested checks is not important, they will be re-ordered by the service and in some cases, depending on your account configuration, may be skipped.    The validation that is performed on the requested checks is to:   - ensure the check type is known   - is suitable for the type of entity (no KYC for organisations)   - disallow manual (mKYC) check with any other kind of KYC   - disallow mixing the \"profile\" check with any other kind of check.  The supported check types are:  Profile:   - \"profile\": By arrangement with Frankie we will create a \"profile\" check type that applies checks according to a recipe that you assign to the entity from a predefined set of profiles.      The profile to use will be taken from the entity.entityProfile field if set, or be run through a set of configurable rules to determine which one to use.      Profiles provide a pre-defined combination of individual checkTypes (see the list below). But they offer a lot more besides, including rules for determining default settings, inbuilt data aging and other configurable features.   They also allow for a new result set top be returned that provides a more detailed and useful breakdown of the check/verification process.      Entity Profiles are a recent feature (since v1.4.0) but are now the default checkType to use with Frankie Financial.  **Individual Check Types**  Whilst we strongly recommend the use of the \"profile\" checktype, it does map of any combination of the types below. If you wish to use these individually, please contact developer support for more details on how to use these effectively.  Entity Checks - One of:   - \"one_plus\": Checks name, address and DoB against a minimum of 1 data source. (also known as a 1+1)   - \"two_plus\": Checks name, address and DoB against a minimum of 2 independent data sources (also known as a 2+2)  ID Checks - One of:   - \"id\": Checks all of the identity documents, but not necessarily the entity itself independently. Use this in conjunction with a one_plus or two_plus for more.   - \"visa\":    ID Validate - One of:   - \"idvalidate\": Checks to see if photo ID has had OCR scanning, ID document validation and photo comparison run against it. Can be used in conjunction with any of the KYC/ID/AML checks.    Manual Check:   - \"manual\": (mKYC) Checks user has a sufficient amount of operator verified ID and will then \"pass\" all Entity and ID related checks.    Fraud Checks - One or more of:   - \"fraudlist\": Checks to see if the identity appears on any known fraud lists. Should be run after KYC/ID checks have passed.   - \"fraudcheck\": Checks external ID services to see if details appear in fraud detection services (e.g. EmailAge or FraudNet)    PEP Checks - One of:   - \"pep\": Will only run PEP/Sanctions checks (no identity verification)   - \"pep_media\": Will run PEP/Sanctions checks, as well as watchlist and adverse media checks. (no identity verification)      * NOTE: These checks will ONLY run if either the KYC/ID checks have been run prior, or it is the only check requested.    Custom:   - By arrangement with Frankie you can define your own KYC check type.      This will allow you to set the minimum number of matches for:     - name      - date of birth     - address     - government id      This allows for alternatives to the \"standard\" two_plus or one_plus (note, these can be overridden too). ")],
        result_level: Annotated[StrictStr, Field(description="How much detail we return.   Acceptable values are:   * simple - Only available with \"profile\" check type. Returns just an EntityProfileResultObject (which is also included for \"profile\" checks at the other result levels), and a CheckEntityCheckResultObjectEntityResult with just the entity details but no separate results.   * summary   * full - You need to have your account configured for this. ")],
        entity_details: Annotated[EntityCheckDetailsObject, Field(description="The entity and any associated / additional information to be checked")],
        x_frankie_customer_child_id: Annotated[Optional[StrictStr], Field(description="If, as a Frankie Customer, you are acting on behalf of your own customers, then you can populate this field with a Frankie-assigned ID.  Note: If using a CustomerChildID, you will also need a separate api_key for each child.  Any documents, checks, entities that are created when this field has been populated will now be tied to this CustomerID + CustomerChildID combination. Just as Customers cannot see data created by other Customers, so too a Customer's Children will not be able to see each other's data.  A Customer can see the documents/entities and checks of all their Children. ")] = None,
        x_frankie_background: Annotated[Optional[Annotated[int, Field(le=1, strict=True, ge=0)]], Field(description="If this header parameter is supplied and set to 1, then the request will not wait for the process to finish, and will return a 202 if there are no obvious errors in the input. The request will then run in the background and send a notification back to the customer. See out callback API for details on this.  See more details here:   https://apidocs.frankiefinancial.com/docs/asynchronous-calls-backgrounding-processes ")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> CheckEntityCheckResultObject:
        """Create and Verify Entity

        Create an entity object. An entity object can be used to simply store data around a given identity. You can attach ID documents, scans, PDFs, photos, videos, etc to the entity if you wish and these may be processed later (using the /scan function) to extract useful information. Or you can manually supply the  information if you choose.  If the entity is successfully created, take the details and documents provided, and set about verifying them all. So for example, you might extract:  * The name from the entity.name object * The address from the entity.address object * The DoB..  All documents that are attached to the entity will also be verified (if possible).  You can also specify the level of detail returned using the resultLevel parameter. You can choose \"summary\" or \"full\". For the \"profile\" check type you can also select \"simple\" to only get the entity profile result.  SPECIAL NOTE: A \"Full\" response includes details of all checks and how they map against each element, along with all the details of pep/sanctions/etc checks too.  Your account also needs to be configured to support a full response too (talk to your account manager for more information). If you're not configured for full responses, we'll only return summary level data regardless. 

        :param x_frankie_customer_id: Customer ID issued by Frankie Financial. This will never change. Your API key, which is mapped to this identity, will change over time.  (required)
        :type x_frankie_customer_id: str
        :param check_type: When creating a new check, you need to define the checks you wish to run.    The checkType is make up of a comma separated list of the types of check you wish to run. The order of the requested checks is not important, they will be re-ordered by the service and in some cases, depending on your account configuration, may be skipped.    The validation that is performed on the requested checks is to:   - ensure the check type is known   - is suitable for the type of entity (no KYC for organisations)   - disallow manual (mKYC) check with any other kind of KYC   - disallow mixing the \"profile\" check with any other kind of check.  The supported check types are:  Profile:   - \"profile\": By arrangement with Frankie we will create a \"profile\" check type that applies checks according to a recipe that you assign to the entity from a predefined set of profiles.      The profile to use will be taken from the entity.entityProfile field if set, or be run through a set of configurable rules to determine which one to use.      Profiles provide a pre-defined combination of individual checkTypes (see the list below). But they offer a lot more besides, including rules for determining default settings, inbuilt data aging and other configurable features.   They also allow for a new result set top be returned that provides a more detailed and useful breakdown of the check/verification process.      Entity Profiles are a recent feature (since v1.4.0) but are now the default checkType to use with Frankie Financial.  **Individual Check Types**  Whilst we strongly recommend the use of the \"profile\" checktype, it does map of any combination of the types below. If you wish to use these individually, please contact developer support for more details on how to use these effectively.  Entity Checks - One of:   - \"one_plus\": Checks name, address and DoB against a minimum of 1 data source. (also known as a 1+1)   - \"two_plus\": Checks name, address and DoB against a minimum of 2 independent data sources (also known as a 2+2)  ID Checks - One of:   - \"id\": Checks all of the identity documents, but not necessarily the entity itself independently. Use this in conjunction with a one_plus or two_plus for more.   - \"visa\":    ID Validate - One of:   - \"idvalidate\": Checks to see if photo ID has had OCR scanning, ID document validation and photo comparison run against it. Can be used in conjunction with any of the KYC/ID/AML checks.    Manual Check:   - \"manual\": (mKYC) Checks user has a sufficient amount of operator verified ID and will then \"pass\" all Entity and ID related checks.    Fraud Checks - One or more of:   - \"fraudlist\": Checks to see if the identity appears on any known fraud lists. Should be run after KYC/ID checks have passed.   - \"fraudcheck\": Checks external ID services to see if details appear in fraud detection services (e.g. EmailAge or FraudNet)    PEP Checks - One of:   - \"pep\": Will only run PEP/Sanctions checks (no identity verification)   - \"pep_media\": Will run PEP/Sanctions checks, as well as watchlist and adverse media checks. (no identity verification)      * NOTE: These checks will ONLY run if either the KYC/ID checks have been run prior, or it is the only check requested.    Custom:   - By arrangement with Frankie you can define your own KYC check type.      This will allow you to set the minimum number of matches for:     - name      - date of birth     - address     - government id      This allows for alternatives to the \"standard\" two_plus or one_plus (note, these can be overridden too).  (required)
        :type check_type: str
        :param result_level: How much detail we return.   Acceptable values are:   * simple - Only available with \"profile\" check type. Returns just an EntityProfileResultObject (which is also included for \"profile\" checks at the other result levels), and a CheckEntityCheckResultObjectEntityResult with just the entity details but no separate results.   * summary   * full - You need to have your account configured for this.  (required)
        :type result_level: str
        :param entity_details: The entity and any associated / additional information to be checked (required)
        :type entity_details: EntityCheckDetailsObject
        :param x_frankie_customer_child_id: If, as a Frankie Customer, you are acting on behalf of your own customers, then you can populate this field with a Frankie-assigned ID.  Note: If using a CustomerChildID, you will also need a separate api_key for each child.  Any documents, checks, entities that are created when this field has been populated will now be tied to this CustomerID + CustomerChildID combination. Just as Customers cannot see data created by other Customers, so too a Customer's Children will not be able to see each other's data.  A Customer can see the documents/entities and checks of all their Children. 
        :type x_frankie_customer_child_id: str
        :param x_frankie_background: If this header parameter is supplied and set to 1, then the request will not wait for the process to finish, and will return a 202 if there are no obvious errors in the input. The request will then run in the background and send a notification back to the customer. See out callback API for details on this.  See more details here:   https://apidocs.frankiefinancial.com/docs/asynchronous-calls-backgrounding-processes 
        :type x_frankie_background: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_check_entity_serialize(
            x_frankie_customer_id=x_frankie_customer_id,
            check_type=check_type,
            result_level=result_level,
            entity_details=entity_details,
            x_frankie_customer_child_id=x_frankie_customer_child_id,
            x_frankie_background=x_frankie_background,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CheckEntityCheckResultObject",
            '202': "AcceptedEntityResultObject",
            '400': "ErrorObject",
            '401': "ErrorObject",
            '404': "ErrorObject",
            '405': "ErrorObject",
            '415': "ErrorObject",
            '422': "ErrorObject",
            '429': "ErrorObject",
            '500': "ErrorObject",
            '503': "ErrorObject",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def create_check_entity_with_http_info(
        self,
        x_frankie_customer_id: Annotated[StrictStr, Field(description="Customer ID issued by Frankie Financial. This will never change. Your API key, which is mapped to this identity, will change over time. ")],
        check_type: Annotated[StrictStr, Field(description="When creating a new check, you need to define the checks you wish to run.    The checkType is make up of a comma separated list of the types of check you wish to run. The order of the requested checks is not important, they will be re-ordered by the service and in some cases, depending on your account configuration, may be skipped.    The validation that is performed on the requested checks is to:   - ensure the check type is known   - is suitable for the type of entity (no KYC for organisations)   - disallow manual (mKYC) check with any other kind of KYC   - disallow mixing the \"profile\" check with any other kind of check.  The supported check types are:  Profile:   - \"profile\": By arrangement with Frankie we will create a \"profile\" check type that applies checks according to a recipe that you assign to the entity from a predefined set of profiles.      The profile to use will be taken from the entity.entityProfile field if set, or be run through a set of configurable rules to determine which one to use.      Profiles provide a pre-defined combination of individual checkTypes (see the list below). But they offer a lot more besides, including rules for determining default settings, inbuilt data aging and other configurable features.   They also allow for a new result set top be returned that provides a more detailed and useful breakdown of the check/verification process.      Entity Profiles are a recent feature (since v1.4.0) but are now the default checkType to use with Frankie Financial.  **Individual Check Types**  Whilst we strongly recommend the use of the \"profile\" checktype, it does map of any combination of the types below. If you wish to use these individually, please contact developer support for more details on how to use these effectively.  Entity Checks - One of:   - \"one_plus\": Checks name, address and DoB against a minimum of 1 data source. (also known as a 1+1)   - \"two_plus\": Checks name, address and DoB against a minimum of 2 independent data sources (also known as a 2+2)  ID Checks - One of:   - \"id\": Checks all of the identity documents, but not necessarily the entity itself independently. Use this in conjunction with a one_plus or two_plus for more.   - \"visa\":    ID Validate - One of:   - \"idvalidate\": Checks to see if photo ID has had OCR scanning, ID document validation and photo comparison run against it. Can be used in conjunction with any of the KYC/ID/AML checks.    Manual Check:   - \"manual\": (mKYC) Checks user has a sufficient amount of operator verified ID and will then \"pass\" all Entity and ID related checks.    Fraud Checks - One or more of:   - \"fraudlist\": Checks to see if the identity appears on any known fraud lists. Should be run after KYC/ID checks have passed.   - \"fraudcheck\": Checks external ID services to see if details appear in fraud detection services (e.g. EmailAge or FraudNet)    PEP Checks - One of:   - \"pep\": Will only run PEP/Sanctions checks (no identity verification)   - \"pep_media\": Will run PEP/Sanctions checks, as well as watchlist and adverse media checks. (no identity verification)      * NOTE: These checks will ONLY run if either the KYC/ID checks have been run prior, or it is the only check requested.    Custom:   - By arrangement with Frankie you can define your own KYC check type.      This will allow you to set the minimum number of matches for:     - name      - date of birth     - address     - government id      This allows for alternatives to the \"standard\" two_plus or one_plus (note, these can be overridden too). ")],
        result_level: Annotated[StrictStr, Field(description="How much detail we return.   Acceptable values are:   * simple - Only available with \"profile\" check type. Returns just an EntityProfileResultObject (which is also included for \"profile\" checks at the other result levels), and a CheckEntityCheckResultObjectEntityResult with just the entity details but no separate results.   * summary   * full - You need to have your account configured for this. ")],
        entity_details: Annotated[EntityCheckDetailsObject, Field(description="The entity and any associated / additional information to be checked")],
        x_frankie_customer_child_id: Annotated[Optional[StrictStr], Field(description="If, as a Frankie Customer, you are acting on behalf of your own customers, then you can populate this field with a Frankie-assigned ID.  Note: If using a CustomerChildID, you will also need a separate api_key for each child.  Any documents, checks, entities that are created when this field has been populated will now be tied to this CustomerID + CustomerChildID combination. Just as Customers cannot see data created by other Customers, so too a Customer's Children will not be able to see each other's data.  A Customer can see the documents/entities and checks of all their Children. ")] = None,
        x_frankie_background: Annotated[Optional[Annotated[int, Field(le=1, strict=True, ge=0)]], Field(description="If this header parameter is supplied and set to 1, then the request will not wait for the process to finish, and will return a 202 if there are no obvious errors in the input. The request will then run in the background and send a notification back to the customer. See out callback API for details on this.  See more details here:   https://apidocs.frankiefinancial.com/docs/asynchronous-calls-backgrounding-processes ")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[CheckEntityCheckResultObject]:
        """Create and Verify Entity

        Create an entity object. An entity object can be used to simply store data around a given identity. You can attach ID documents, scans, PDFs, photos, videos, etc to the entity if you wish and these may be processed later (using the /scan function) to extract useful information. Or you can manually supply the  information if you choose.  If the entity is successfully created, take the details and documents provided, and set about verifying them all. So for example, you might extract:  * The name from the entity.name object * The address from the entity.address object * The DoB..  All documents that are attached to the entity will also be verified (if possible).  You can also specify the level of detail returned using the resultLevel parameter. You can choose \"summary\" or \"full\". For the \"profile\" check type you can also select \"simple\" to only get the entity profile result.  SPECIAL NOTE: A \"Full\" response includes details of all checks and how they map against each element, along with all the details of pep/sanctions/etc checks too.  Your account also needs to be configured to support a full response too (talk to your account manager for more information). If you're not configured for full responses, we'll only return summary level data regardless. 

        :param x_frankie_customer_id: Customer ID issued by Frankie Financial. This will never change. Your API key, which is mapped to this identity, will change over time.  (required)
        :type x_frankie_customer_id: str
        :param check_type: When creating a new check, you need to define the checks you wish to run.    The checkType is make up of a comma separated list of the types of check you wish to run. The order of the requested checks is not important, they will be re-ordered by the service and in some cases, depending on your account configuration, may be skipped.    The validation that is performed on the requested checks is to:   - ensure the check type is known   - is suitable for the type of entity (no KYC for organisations)   - disallow manual (mKYC) check with any other kind of KYC   - disallow mixing the \"profile\" check with any other kind of check.  The supported check types are:  Profile:   - \"profile\": By arrangement with Frankie we will create a \"profile\" check type that applies checks according to a recipe that you assign to the entity from a predefined set of profiles.      The profile to use will be taken from the entity.entityProfile field if set, or be run through a set of configurable rules to determine which one to use.      Profiles provide a pre-defined combination of individual checkTypes (see the list below). But they offer a lot more besides, including rules for determining default settings, inbuilt data aging and other configurable features.   They also allow for a new result set top be returned that provides a more detailed and useful breakdown of the check/verification process.      Entity Profiles are a recent feature (since v1.4.0) but are now the default checkType to use with Frankie Financial.  **Individual Check Types**  Whilst we strongly recommend the use of the \"profile\" checktype, it does map of any combination of the types below. If you wish to use these individually, please contact developer support for more details on how to use these effectively.  Entity Checks - One of:   - \"one_plus\": Checks name, address and DoB against a minimum of 1 data source. (also known as a 1+1)   - \"two_plus\": Checks name, address and DoB against a minimum of 2 independent data sources (also known as a 2+2)  ID Checks - One of:   - \"id\": Checks all of the identity documents, but not necessarily the entity itself independently. Use this in conjunction with a one_plus or two_plus for more.   - \"visa\":    ID Validate - One of:   - \"idvalidate\": Checks to see if photo ID has had OCR scanning, ID document validation and photo comparison run against it. Can be used in conjunction with any of the KYC/ID/AML checks.    Manual Check:   - \"manual\": (mKYC) Checks user has a sufficient amount of operator verified ID and will then \"pass\" all Entity and ID related checks.    Fraud Checks - One or more of:   - \"fraudlist\": Checks to see if the identity appears on any known fraud lists. Should be run after KYC/ID checks have passed.   - \"fraudcheck\": Checks external ID services to see if details appear in fraud detection services (e.g. EmailAge or FraudNet)    PEP Checks - One of:   - \"pep\": Will only run PEP/Sanctions checks (no identity verification)   - \"pep_media\": Will run PEP/Sanctions checks, as well as watchlist and adverse media checks. (no identity verification)      * NOTE: These checks will ONLY run if either the KYC/ID checks have been run prior, or it is the only check requested.    Custom:   - By arrangement with Frankie you can define your own KYC check type.      This will allow you to set the minimum number of matches for:     - name      - date of birth     - address     - government id      This allows for alternatives to the \"standard\" two_plus or one_plus (note, these can be overridden too).  (required)
        :type check_type: str
        :param result_level: How much detail we return.   Acceptable values are:   * simple - Only available with \"profile\" check type. Returns just an EntityProfileResultObject (which is also included for \"profile\" checks at the other result levels), and a CheckEntityCheckResultObjectEntityResult with just the entity details but no separate results.   * summary   * full - You need to have your account configured for this.  (required)
        :type result_level: str
        :param entity_details: The entity and any associated / additional information to be checked (required)
        :type entity_details: EntityCheckDetailsObject
        :param x_frankie_customer_child_id: If, as a Frankie Customer, you are acting on behalf of your own customers, then you can populate this field with a Frankie-assigned ID.  Note: If using a CustomerChildID, you will also need a separate api_key for each child.  Any documents, checks, entities that are created when this field has been populated will now be tied to this CustomerID + CustomerChildID combination. Just as Customers cannot see data created by other Customers, so too a Customer's Children will not be able to see each other's data.  A Customer can see the documents/entities and checks of all their Children. 
        :type x_frankie_customer_child_id: str
        :param x_frankie_background: If this header parameter is supplied and set to 1, then the request will not wait for the process to finish, and will return a 202 if there are no obvious errors in the input. The request will then run in the background and send a notification back to the customer. See out callback API for details on this.  See more details here:   https://apidocs.frankiefinancial.com/docs/asynchronous-calls-backgrounding-processes 
        :type x_frankie_background: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_check_entity_serialize(
            x_frankie_customer_id=x_frankie_customer_id,
            check_type=check_type,
            result_level=result_level,
            entity_details=entity_details,
            x_frankie_customer_child_id=x_frankie_customer_child_id,
            x_frankie_background=x_frankie_background,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CheckEntityCheckResultObject",
            '202': "AcceptedEntityResultObject",
            '400': "ErrorObject",
            '401': "ErrorObject",
            '404': "ErrorObject",
            '405': "ErrorObject",
            '415': "ErrorObject",
            '422': "ErrorObject",
            '429': "ErrorObject",
            '500': "ErrorObject",
            '503': "ErrorObject",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def create_check_entity_without_preload_content(
        self,
        x_frankie_customer_id: Annotated[StrictStr, Field(description="Customer ID issued by Frankie Financial. This will never change. Your API key, which is mapped to this identity, will change over time. ")],
        check_type: Annotated[StrictStr, Field(description="When creating a new check, you need to define the checks you wish to run.    The checkType is make up of a comma separated list of the types of check you wish to run. The order of the requested checks is not important, they will be re-ordered by the service and in some cases, depending on your account configuration, may be skipped.    The validation that is performed on the requested checks is to:   - ensure the check type is known   - is suitable for the type of entity (no KYC for organisations)   - disallow manual (mKYC) check with any other kind of KYC   - disallow mixing the \"profile\" check with any other kind of check.  The supported check types are:  Profile:   - \"profile\": By arrangement with Frankie we will create a \"profile\" check type that applies checks according to a recipe that you assign to the entity from a predefined set of profiles.      The profile to use will be taken from the entity.entityProfile field if set, or be run through a set of configurable rules to determine which one to use.      Profiles provide a pre-defined combination of individual checkTypes (see the list below). But they offer a lot more besides, including rules for determining default settings, inbuilt data aging and other configurable features.   They also allow for a new result set top be returned that provides a more detailed and useful breakdown of the check/verification process.      Entity Profiles are a recent feature (since v1.4.0) but are now the default checkType to use with Frankie Financial.  **Individual Check Types**  Whilst we strongly recommend the use of the \"profile\" checktype, it does map of any combination of the types below. If you wish to use these individually, please contact developer support for more details on how to use these effectively.  Entity Checks - One of:   - \"one_plus\": Checks name, address and DoB against a minimum of 1 data source. (also known as a 1+1)   - \"two_plus\": Checks name, address and DoB against a minimum of 2 independent data sources (also known as a 2+2)  ID Checks - One of:   - \"id\": Checks all of the identity documents, but not necessarily the entity itself independently. Use this in conjunction with a one_plus or two_plus for more.   - \"visa\":    ID Validate - One of:   - \"idvalidate\": Checks to see if photo ID has had OCR scanning, ID document validation and photo comparison run against it. Can be used in conjunction with any of the KYC/ID/AML checks.    Manual Check:   - \"manual\": (mKYC) Checks user has a sufficient amount of operator verified ID and will then \"pass\" all Entity and ID related checks.    Fraud Checks - One or more of:   - \"fraudlist\": Checks to see if the identity appears on any known fraud lists. Should be run after KYC/ID checks have passed.   - \"fraudcheck\": Checks external ID services to see if details appear in fraud detection services (e.g. EmailAge or FraudNet)    PEP Checks - One of:   - \"pep\": Will only run PEP/Sanctions checks (no identity verification)   - \"pep_media\": Will run PEP/Sanctions checks, as well as watchlist and adverse media checks. (no identity verification)      * NOTE: These checks will ONLY run if either the KYC/ID checks have been run prior, or it is the only check requested.    Custom:   - By arrangement with Frankie you can define your own KYC check type.      This will allow you to set the minimum number of matches for:     - name      - date of birth     - address     - government id      This allows for alternatives to the \"standard\" two_plus or one_plus (note, these can be overridden too). ")],
        result_level: Annotated[StrictStr, Field(description="How much detail we return.   Acceptable values are:   * simple - Only available with \"profile\" check type. Returns just an EntityProfileResultObject (which is also included for \"profile\" checks at the other result levels), and a CheckEntityCheckResultObjectEntityResult with just the entity details but no separate results.   * summary   * full - You need to have your account configured for this. ")],
        entity_details: Annotated[EntityCheckDetailsObject, Field(description="The entity and any associated / additional information to be checked")],
        x_frankie_customer_child_id: Annotated[Optional[StrictStr], Field(description="If, as a Frankie Customer, you are acting on behalf of your own customers, then you can populate this field with a Frankie-assigned ID.  Note: If using a CustomerChildID, you will also need a separate api_key for each child.  Any documents, checks, entities that are created when this field has been populated will now be tied to this CustomerID + CustomerChildID combination. Just as Customers cannot see data created by other Customers, so too a Customer's Children will not be able to see each other's data.  A Customer can see the documents/entities and checks of all their Children. ")] = None,
        x_frankie_background: Annotated[Optional[Annotated[int, Field(le=1, strict=True, ge=0)]], Field(description="If this header parameter is supplied and set to 1, then the request will not wait for the process to finish, and will return a 202 if there are no obvious errors in the input. The request will then run in the background and send a notification back to the customer. See out callback API for details on this.  See more details here:   https://apidocs.frankiefinancial.com/docs/asynchronous-calls-backgrounding-processes ")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Create and Verify Entity

        Create an entity object. An entity object can be used to simply store data around a given identity. You can attach ID documents, scans, PDFs, photos, videos, etc to the entity if you wish and these may be processed later (using the /scan function) to extract useful information. Or you can manually supply the  information if you choose.  If the entity is successfully created, take the details and documents provided, and set about verifying them all. So for example, you might extract:  * The name from the entity.name object * The address from the entity.address object * The DoB..  All documents that are attached to the entity will also be verified (if possible).  You can also specify the level of detail returned using the resultLevel parameter. You can choose \"summary\" or \"full\". For the \"profile\" check type you can also select \"simple\" to only get the entity profile result.  SPECIAL NOTE: A \"Full\" response includes details of all checks and how they map against each element, along with all the details of pep/sanctions/etc checks too.  Your account also needs to be configured to support a full response too (talk to your account manager for more information). If you're not configured for full responses, we'll only return summary level data regardless. 

        :param x_frankie_customer_id: Customer ID issued by Frankie Financial. This will never change. Your API key, which is mapped to this identity, will change over time.  (required)
        :type x_frankie_customer_id: str
        :param check_type: When creating a new check, you need to define the checks you wish to run.    The checkType is make up of a comma separated list of the types of check you wish to run. The order of the requested checks is not important, they will be re-ordered by the service and in some cases, depending on your account configuration, may be skipped.    The validation that is performed on the requested checks is to:   - ensure the check type is known   - is suitable for the type of entity (no KYC for organisations)   - disallow manual (mKYC) check with any other kind of KYC   - disallow mixing the \"profile\" check with any other kind of check.  The supported check types are:  Profile:   - \"profile\": By arrangement with Frankie we will create a \"profile\" check type that applies checks according to a recipe that you assign to the entity from a predefined set of profiles.      The profile to use will be taken from the entity.entityProfile field if set, or be run through a set of configurable rules to determine which one to use.      Profiles provide a pre-defined combination of individual checkTypes (see the list below). But they offer a lot more besides, including rules for determining default settings, inbuilt data aging and other configurable features.   They also allow for a new result set top be returned that provides a more detailed and useful breakdown of the check/verification process.      Entity Profiles are a recent feature (since v1.4.0) but are now the default checkType to use with Frankie Financial.  **Individual Check Types**  Whilst we strongly recommend the use of the \"profile\" checktype, it does map of any combination of the types below. If you wish to use these individually, please contact developer support for more details on how to use these effectively.  Entity Checks - One of:   - \"one_plus\": Checks name, address and DoB against a minimum of 1 data source. (also known as a 1+1)   - \"two_plus\": Checks name, address and DoB against a minimum of 2 independent data sources (also known as a 2+2)  ID Checks - One of:   - \"id\": Checks all of the identity documents, but not necessarily the entity itself independently. Use this in conjunction with a one_plus or two_plus for more.   - \"visa\":    ID Validate - One of:   - \"idvalidate\": Checks to see if photo ID has had OCR scanning, ID document validation and photo comparison run against it. Can be used in conjunction with any of the KYC/ID/AML checks.    Manual Check:   - \"manual\": (mKYC) Checks user has a sufficient amount of operator verified ID and will then \"pass\" all Entity and ID related checks.    Fraud Checks - One or more of:   - \"fraudlist\": Checks to see if the identity appears on any known fraud lists. Should be run after KYC/ID checks have passed.   - \"fraudcheck\": Checks external ID services to see if details appear in fraud detection services (e.g. EmailAge or FraudNet)    PEP Checks - One of:   - \"pep\": Will only run PEP/Sanctions checks (no identity verification)   - \"pep_media\": Will run PEP/Sanctions checks, as well as watchlist and adverse media checks. (no identity verification)      * NOTE: These checks will ONLY run if either the KYC/ID checks have been run prior, or it is the only check requested.    Custom:   - By arrangement with Frankie you can define your own KYC check type.      This will allow you to set the minimum number of matches for:     - name      - date of birth     - address     - government id      This allows for alternatives to the \"standard\" two_plus or one_plus (note, these can be overridden too).  (required)
        :type check_type: str
        :param result_level: How much detail we return.   Acceptable values are:   * simple - Only available with \"profile\" check type. Returns just an EntityProfileResultObject (which is also included for \"profile\" checks at the other result levels), and a CheckEntityCheckResultObjectEntityResult with just the entity details but no separate results.   * summary   * full - You need to have your account configured for this.  (required)
        :type result_level: str
        :param entity_details: The entity and any associated / additional information to be checked (required)
        :type entity_details: EntityCheckDetailsObject
        :param x_frankie_customer_child_id: If, as a Frankie Customer, you are acting on behalf of your own customers, then you can populate this field with a Frankie-assigned ID.  Note: If using a CustomerChildID, you will also need a separate api_key for each child.  Any documents, checks, entities that are created when this field has been populated will now be tied to this CustomerID + CustomerChildID combination. Just as Customers cannot see data created by other Customers, so too a Customer's Children will not be able to see each other's data.  A Customer can see the documents/entities and checks of all their Children. 
        :type x_frankie_customer_child_id: str
        :param x_frankie_background: If this header parameter is supplied and set to 1, then the request will not wait for the process to finish, and will return a 202 if there are no obvious errors in the input. The request will then run in the background and send a notification back to the customer. See out callback API for details on this.  See more details here:   https://apidocs.frankiefinancial.com/docs/asynchronous-calls-backgrounding-processes 
        :type x_frankie_background: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_check_entity_serialize(
            x_frankie_customer_id=x_frankie_customer_id,
            check_type=check_type,
            result_level=result_level,
            entity_details=entity_details,
            x_frankie_customer_child_id=x_frankie_customer_child_id,
            x_frankie_background=x_frankie_background,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CheckEntityCheckResultObject",
            '202': "AcceptedEntityResultObject",
            '400': "ErrorObject",
            '401': "ErrorObject",
            '404': "ErrorObject",
            '405': "ErrorObject",
            '415': "ErrorObject",
            '422': "ErrorObject",
            '429': "ErrorObject",
            '500': "ErrorObject",
            '503': "ErrorObject",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _create_check_entity_serialize(
        self,
        x_frankie_customer_id,
        check_type,
        result_level,
        entity_details,
        x_frankie_customer_child_id,
        x_frankie_background,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if check_type is not None:
            _path_params['checkType'] = check_type
        if result_level is not None:
            _path_params['resultLevel'] = result_level
        # process the query parameters
        # process the header parameters
        if x_frankie_customer_id is not None:
            _header_params['X-Frankie-CustomerID'] = x_frankie_customer_id
        if x_frankie_customer_child_id is not None:
            _header_params['X-Frankie-CustomerChildID'] = x_frankie_customer_child_id
        if x_frankie_background is not None:
            _header_params['X-Frankie-Background'] = x_frankie_background
        # process the form parameters
        # process the body parameter
        if entity_details is not None:
            _body_params = entity_details


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'api_key'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/entity/new/verify/{checkType}/{resultLevel}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def create_check_entity_push_to_mobile(
        self,
        x_frankie_customer_id: Annotated[StrictStr, Field(description="Customer ID issued by Frankie Financial. This will never change. Your API key, which is mapped to this identity, will change over time. ")],
        entity_details: Annotated[EntityCheckDetailsObject, Field(description="The entity and any associated / additional information to be checked")],
        x_frankie_customer_child_id: Annotated[Optional[StrictStr], Field(description="If, as a Frankie Customer, you are acting on behalf of your own customers, then you can populate this field with a Frankie-assigned ID.  Note: If using a CustomerChildID, you will also need a separate api_key for each child.  Any documents, checks, entities that are created when this field has been populated will now be tied to this CustomerID + CustomerChildID combination. Just as Customers cannot see data created by other Customers, so too a Customer's Children will not be able to see each other's data.  A Customer can see the documents/entities and checks of all their Children. ")] = None,
        x_frankie_background: Annotated[Optional[Annotated[int, Field(le=1, strict=True, ge=0)]], Field(description="If this header parameter is supplied and set to 1, then the request will not wait for the process to finish, and will return a 202 if there are no obvious errors in the input. The request will then run in the background and send a notification back to the customer. See out callback API for details on this.  See more details here:   https://apidocs.frankiefinancial.com/docs/asynchronous-calls-backgrounding-processes ")] = None,
        nopush: Annotated[Optional[StrictBool], Field(description="If set to true, then no SMS/email will be pushed. It will be up to the API caller to manage the delivery of the link. ")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> AcceptedEntityResultObject:
        """Create Entity and Push Self-Verification Link

        Create an entity object and begin the process of verification after pushing a message to a mobile number.  The entity will receive a link on their mobile and will then be guided through a series of steps to capture and OCR scan their ID, and perform a selfie comparison. We'll then attempt to verify the data received and push a notification back to the calling customer.  At a minimum, you will need to supply the name and a MOBILE_PHONE document type.   SPECIAL NOTE: This will only ever return a 202 response if successfully accepted. You will need to ensure your account is configured for push notifications. Contact developer supprt to arrange this. 

        :param x_frankie_customer_id: Customer ID issued by Frankie Financial. This will never change. Your API key, which is mapped to this identity, will change over time.  (required)
        :type x_frankie_customer_id: str
        :param entity_details: The entity and any associated / additional information to be checked (required)
        :type entity_details: EntityCheckDetailsObject
        :param x_frankie_customer_child_id: If, as a Frankie Customer, you are acting on behalf of your own customers, then you can populate this field with a Frankie-assigned ID.  Note: If using a CustomerChildID, you will also need a separate api_key for each child.  Any documents, checks, entities that are created when this field has been populated will now be tied to this CustomerID + CustomerChildID combination. Just as Customers cannot see data created by other Customers, so too a Customer's Children will not be able to see each other's data.  A Customer can see the documents/entities and checks of all their Children. 
        :type x_frankie_customer_child_id: str
        :param x_frankie_background: If this header parameter is supplied and set to 1, then the request will not wait for the process to finish, and will return a 202 if there are no obvious errors in the input. The request will then run in the background and send a notification back to the customer. See out callback API for details on this.  See more details here:   https://apidocs.frankiefinancial.com/docs/asynchronous-calls-backgrounding-processes 
        :type x_frankie_background: int
        :param nopush: If set to true, then no SMS/email will be pushed. It will be up to the API caller to manage the delivery of the link. 
        :type nopush: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_check_entity_push_to_mobile_serialize(
            x_frankie_customer_id=x_frankie_customer_id,
            entity_details=entity_details,
            x_frankie_customer_child_id=x_frankie_customer_child_id,
            x_frankie_background=x_frankie_background,
            nopush=nopush,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '202': "AcceptedEntityResultObject",
            '400': "ErrorObject",
            '401': "ErrorObject",
            '404': "ErrorObject",
            '405': "ErrorObject",
            '415': "ErrorObject",
            '422': "ErrorObject",
            '429': "ErrorObject",
            '500': "ErrorObject",
            '503': "ErrorObject",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def create_check_entity_push_to_mobile_with_http_info(
        self,
        x_frankie_customer_id: Annotated[StrictStr, Field(description="Customer ID issued by Frankie Financial. This will never change. Your API key, which is mapped to this identity, will change over time. ")],
        entity_details: Annotated[EntityCheckDetailsObject, Field(description="The entity and any associated / additional information to be checked")],
        x_frankie_customer_child_id: Annotated[Optional[StrictStr], Field(description="If, as a Frankie Customer, you are acting on behalf of your own customers, then you can populate this field with a Frankie-assigned ID.  Note: If using a CustomerChildID, you will also need a separate api_key for each child.  Any documents, checks, entities that are created when this field has been populated will now be tied to this CustomerID + CustomerChildID combination. Just as Customers cannot see data created by other Customers, so too a Customer's Children will not be able to see each other's data.  A Customer can see the documents/entities and checks of all their Children. ")] = None,
        x_frankie_background: Annotated[Optional[Annotated[int, Field(le=1, strict=True, ge=0)]], Field(description="If this header parameter is supplied and set to 1, then the request will not wait for the process to finish, and will return a 202 if there are no obvious errors in the input. The request will then run in the background and send a notification back to the customer. See out callback API for details on this.  See more details here:   https://apidocs.frankiefinancial.com/docs/asynchronous-calls-backgrounding-processes ")] = None,
        nopush: Annotated[Optional[StrictBool], Field(description="If set to true, then no SMS/email will be pushed. It will be up to the API caller to manage the delivery of the link. ")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[AcceptedEntityResultObject]:
        """Create Entity and Push Self-Verification Link

        Create an entity object and begin the process of verification after pushing a message to a mobile number.  The entity will receive a link on their mobile and will then be guided through a series of steps to capture and OCR scan their ID, and perform a selfie comparison. We'll then attempt to verify the data received and push a notification back to the calling customer.  At a minimum, you will need to supply the name and a MOBILE_PHONE document type.   SPECIAL NOTE: This will only ever return a 202 response if successfully accepted. You will need to ensure your account is configured for push notifications. Contact developer supprt to arrange this. 

        :param x_frankie_customer_id: Customer ID issued by Frankie Financial. This will never change. Your API key, which is mapped to this identity, will change over time.  (required)
        :type x_frankie_customer_id: str
        :param entity_details: The entity and any associated / additional information to be checked (required)
        :type entity_details: EntityCheckDetailsObject
        :param x_frankie_customer_child_id: If, as a Frankie Customer, you are acting on behalf of your own customers, then you can populate this field with a Frankie-assigned ID.  Note: If using a CustomerChildID, you will also need a separate api_key for each child.  Any documents, checks, entities that are created when this field has been populated will now be tied to this CustomerID + CustomerChildID combination. Just as Customers cannot see data created by other Customers, so too a Customer's Children will not be able to see each other's data.  A Customer can see the documents/entities and checks of all their Children. 
        :type x_frankie_customer_child_id: str
        :param x_frankie_background: If this header parameter is supplied and set to 1, then the request will not wait for the process to finish, and will return a 202 if there are no obvious errors in the input. The request will then run in the background and send a notification back to the customer. See out callback API for details on this.  See more details here:   https://apidocs.frankiefinancial.com/docs/asynchronous-calls-backgrounding-processes 
        :type x_frankie_background: int
        :param nopush: If set to true, then no SMS/email will be pushed. It will be up to the API caller to manage the delivery of the link. 
        :type nopush: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_check_entity_push_to_mobile_serialize(
            x_frankie_customer_id=x_frankie_customer_id,
            entity_details=entity_details,
            x_frankie_customer_child_id=x_frankie_customer_child_id,
            x_frankie_background=x_frankie_background,
            nopush=nopush,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '202': "AcceptedEntityResultObject",
            '400': "ErrorObject",
            '401': "ErrorObject",
            '404': "ErrorObject",
            '405': "ErrorObject",
            '415': "ErrorObject",
            '422': "ErrorObject",
            '429': "ErrorObject",
            '500': "ErrorObject",
            '503': "ErrorObject",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def create_check_entity_push_to_mobile_without_preload_content(
        self,
        x_frankie_customer_id: Annotated[StrictStr, Field(description="Customer ID issued by Frankie Financial. This will never change. Your API key, which is mapped to this identity, will change over time. ")],
        entity_details: Annotated[EntityCheckDetailsObject, Field(description="The entity and any associated / additional information to be checked")],
        x_frankie_customer_child_id: Annotated[Optional[StrictStr], Field(description="If, as a Frankie Customer, you are acting on behalf of your own customers, then you can populate this field with a Frankie-assigned ID.  Note: If using a CustomerChildID, you will also need a separate api_key for each child.  Any documents, checks, entities that are created when this field has been populated will now be tied to this CustomerID + CustomerChildID combination. Just as Customers cannot see data created by other Customers, so too a Customer's Children will not be able to see each other's data.  A Customer can see the documents/entities and checks of all their Children. ")] = None,
        x_frankie_background: Annotated[Optional[Annotated[int, Field(le=1, strict=True, ge=0)]], Field(description="If this header parameter is supplied and set to 1, then the request will not wait for the process to finish, and will return a 202 if there are no obvious errors in the input. The request will then run in the background and send a notification back to the customer. See out callback API for details on this.  See more details here:   https://apidocs.frankiefinancial.com/docs/asynchronous-calls-backgrounding-processes ")] = None,
        nopush: Annotated[Optional[StrictBool], Field(description="If set to true, then no SMS/email will be pushed. It will be up to the API caller to manage the delivery of the link. ")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Create Entity and Push Self-Verification Link

        Create an entity object and begin the process of verification after pushing a message to a mobile number.  The entity will receive a link on their mobile and will then be guided through a series of steps to capture and OCR scan their ID, and perform a selfie comparison. We'll then attempt to verify the data received and push a notification back to the calling customer.  At a minimum, you will need to supply the name and a MOBILE_PHONE document type.   SPECIAL NOTE: This will only ever return a 202 response if successfully accepted. You will need to ensure your account is configured for push notifications. Contact developer supprt to arrange this. 

        :param x_frankie_customer_id: Customer ID issued by Frankie Financial. This will never change. Your API key, which is mapped to this identity, will change over time.  (required)
        :type x_frankie_customer_id: str
        :param entity_details: The entity and any associated / additional information to be checked (required)
        :type entity_details: EntityCheckDetailsObject
        :param x_frankie_customer_child_id: If, as a Frankie Customer, you are acting on behalf of your own customers, then you can populate this field with a Frankie-assigned ID.  Note: If using a CustomerChildID, you will also need a separate api_key for each child.  Any documents, checks, entities that are created when this field has been populated will now be tied to this CustomerID + CustomerChildID combination. Just as Customers cannot see data created by other Customers, so too a Customer's Children will not be able to see each other's data.  A Customer can see the documents/entities and checks of all their Children. 
        :type x_frankie_customer_child_id: str
        :param x_frankie_background: If this header parameter is supplied and set to 1, then the request will not wait for the process to finish, and will return a 202 if there are no obvious errors in the input. The request will then run in the background and send a notification back to the customer. See out callback API for details on this.  See more details here:   https://apidocs.frankiefinancial.com/docs/asynchronous-calls-backgrounding-processes 
        :type x_frankie_background: int
        :param nopush: If set to true, then no SMS/email will be pushed. It will be up to the API caller to manage the delivery of the link. 
        :type nopush: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_check_entity_push_to_mobile_serialize(
            x_frankie_customer_id=x_frankie_customer_id,
            entity_details=entity_details,
            x_frankie_customer_child_id=x_frankie_customer_child_id,
            x_frankie_background=x_frankie_background,
            nopush=nopush,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '202': "AcceptedEntityResultObject",
            '400': "ErrorObject",
            '401': "ErrorObject",
            '404': "ErrorObject",
            '405': "ErrorObject",
            '415': "ErrorObject",
            '422': "ErrorObject",
            '429': "ErrorObject",
            '500': "ErrorObject",
            '503': "ErrorObject",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _create_check_entity_push_to_mobile_serialize(
        self,
        x_frankie_customer_id,
        entity_details,
        x_frankie_customer_child_id,
        x_frankie_background,
        nopush,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if nopush is not None:
            
            _query_params.append(('nopush', nopush))
            
        # process the header parameters
        if x_frankie_customer_id is not None:
            _header_params['X-Frankie-CustomerID'] = x_frankie_customer_id
        if x_frankie_customer_child_id is not None:
            _header_params['X-Frankie-CustomerChildID'] = x_frankie_customer_child_id
        if x_frankie_background is not None:
            _header_params['X-Frankie-Background'] = x_frankie_background
        # process the form parameters
        # process the body parameter
        if entity_details is not None:
            _body_params = entity_details


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'api_key'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/entity/new/verify/pushToMobile',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def create_entity(
        self,
        x_frankie_customer_id: Annotated[StrictStr, Field(description="Customer ID issued by Frankie Financial. This will never change. Your API key, which is mapped to this identity, will change over time. ")],
        x_frankie_customer_child_id: Annotated[Optional[StrictStr], Field(description="If, as a Frankie Customer, you are acting on behalf of your own customers, then you can populate this field with a Frankie-assigned ID.  Note: If using a CustomerChildID, you will also need a separate api_key for each child.  Any documents, checks, entities that are created when this field has been populated will now be tied to this CustomerID + CustomerChildID combination. Just as Customers cannot see data created by other Customers, so too a Customer's Children will not be able to see each other's data.  A Customer can see the documents/entities and checks of all their Children. ")] = None,
        entity: Optional[EntityObject] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> EntityResultObject:
        """Create New Entity.

        Create an entity object. An entity object can be used to simply store data around a given identity. You can attach ID documents, scans, PDFs, photos, videos, etc to the entity if you wish and these may be processed later (using the /scan function) to extract useful information. Or you can manually supply the  information if you choose.  Entity objects can be used to run a check, using the data held in the records. 

        :param x_frankie_customer_id: Customer ID issued by Frankie Financial. This will never change. Your API key, which is mapped to this identity, will change over time.  (required)
        :type x_frankie_customer_id: str
        :param x_frankie_customer_child_id: If, as a Frankie Customer, you are acting on behalf of your own customers, then you can populate this field with a Frankie-assigned ID.  Note: If using a CustomerChildID, you will also need a separate api_key for each child.  Any documents, checks, entities that are created when this field has been populated will now be tied to this CustomerID + CustomerChildID combination. Just as Customers cannot see data created by other Customers, so too a Customer's Children will not be able to see each other's data.  A Customer can see the documents/entities and checks of all their Children. 
        :type x_frankie_customer_child_id: str
        :param entity:
        :type entity: EntityObject
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_entity_serialize(
            x_frankie_customer_id=x_frankie_customer_id,
            x_frankie_customer_child_id=x_frankie_customer_child_id,
            entity=entity,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "EntityResultObject",
            '400': "ErrorObject",
            '401': "ErrorObject",
            '404': "ErrorObject",
            '415': "ErrorObject",
            '429': "ErrorObject",
            '500': "ErrorObject",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def create_entity_with_http_info(
        self,
        x_frankie_customer_id: Annotated[StrictStr, Field(description="Customer ID issued by Frankie Financial. This will never change. Your API key, which is mapped to this identity, will change over time. ")],
        x_frankie_customer_child_id: Annotated[Optional[StrictStr], Field(description="If, as a Frankie Customer, you are acting on behalf of your own customers, then you can populate this field with a Frankie-assigned ID.  Note: If using a CustomerChildID, you will also need a separate api_key for each child.  Any documents, checks, entities that are created when this field has been populated will now be tied to this CustomerID + CustomerChildID combination. Just as Customers cannot see data created by other Customers, so too a Customer's Children will not be able to see each other's data.  A Customer can see the documents/entities and checks of all their Children. ")] = None,
        entity: Optional[EntityObject] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[EntityResultObject]:
        """Create New Entity.

        Create an entity object. An entity object can be used to simply store data around a given identity. You can attach ID documents, scans, PDFs, photos, videos, etc to the entity if you wish and these may be processed later (using the /scan function) to extract useful information. Or you can manually supply the  information if you choose.  Entity objects can be used to run a check, using the data held in the records. 

        :param x_frankie_customer_id: Customer ID issued by Frankie Financial. This will never change. Your API key, which is mapped to this identity, will change over time.  (required)
        :type x_frankie_customer_id: str
        :param x_frankie_customer_child_id: If, as a Frankie Customer, you are acting on behalf of your own customers, then you can populate this field with a Frankie-assigned ID.  Note: If using a CustomerChildID, you will also need a separate api_key for each child.  Any documents, checks, entities that are created when this field has been populated will now be tied to this CustomerID + CustomerChildID combination. Just as Customers cannot see data created by other Customers, so too a Customer's Children will not be able to see each other's data.  A Customer can see the documents/entities and checks of all their Children. 
        :type x_frankie_customer_child_id: str
        :param entity:
        :type entity: EntityObject
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_entity_serialize(
            x_frankie_customer_id=x_frankie_customer_id,
            x_frankie_customer_child_id=x_frankie_customer_child_id,
            entity=entity,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "EntityResultObject",
            '400': "ErrorObject",
            '401': "ErrorObject",
            '404': "ErrorObject",
            '415': "ErrorObject",
            '429': "ErrorObject",
            '500': "ErrorObject",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def create_entity_without_preload_content(
        self,
        x_frankie_customer_id: Annotated[StrictStr, Field(description="Customer ID issued by Frankie Financial. This will never change. Your API key, which is mapped to this identity, will change over time. ")],
        x_frankie_customer_child_id: Annotated[Optional[StrictStr], Field(description="If, as a Frankie Customer, you are acting on behalf of your own customers, then you can populate this field with a Frankie-assigned ID.  Note: If using a CustomerChildID, you will also need a separate api_key for each child.  Any documents, checks, entities that are created when this field has been populated will now be tied to this CustomerID + CustomerChildID combination. Just as Customers cannot see data created by other Customers, so too a Customer's Children will not be able to see each other's data.  A Customer can see the documents/entities and checks of all their Children. ")] = None,
        entity: Optional[EntityObject] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Create New Entity.

        Create an entity object. An entity object can be used to simply store data around a given identity. You can attach ID documents, scans, PDFs, photos, videos, etc to the entity if you wish and these may be processed later (using the /scan function) to extract useful information. Or you can manually supply the  information if you choose.  Entity objects can be used to run a check, using the data held in the records. 

        :param x_frankie_customer_id: Customer ID issued by Frankie Financial. This will never change. Your API key, which is mapped to this identity, will change over time.  (required)
        :type x_frankie_customer_id: str
        :param x_frankie_customer_child_id: If, as a Frankie Customer, you are acting on behalf of your own customers, then you can populate this field with a Frankie-assigned ID.  Note: If using a CustomerChildID, you will also need a separate api_key for each child.  Any documents, checks, entities that are created when this field has been populated will now be tied to this CustomerID + CustomerChildID combination. Just as Customers cannot see data created by other Customers, so too a Customer's Children will not be able to see each other's data.  A Customer can see the documents/entities and checks of all their Children. 
        :type x_frankie_customer_child_id: str
        :param entity:
        :type entity: EntityObject
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_entity_serialize(
            x_frankie_customer_id=x_frankie_customer_id,
            x_frankie_customer_child_id=x_frankie_customer_child_id,
            entity=entity,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "EntityResultObject",
            '400': "ErrorObject",
            '401': "ErrorObject",
            '404': "ErrorObject",
            '415': "ErrorObject",
            '429': "ErrorObject",
            '500': "ErrorObject",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _create_entity_serialize(
        self,
        x_frankie_customer_id,
        x_frankie_customer_child_id,
        entity,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        if x_frankie_customer_id is not None:
            _header_params['X-Frankie-CustomerID'] = x_frankie_customer_id
        if x_frankie_customer_child_id is not None:
            _header_params['X-Frankie-CustomerChildID'] = x_frankie_customer_child_id
        # process the form parameters
        # process the body parameter
        if entity is not None:
            _body_params = entity


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'api_key'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/entity',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def create_entity_get_idv_token(
        self,
        x_frankie_customer_id: Annotated[StrictStr, Field(description="Customer ID issued by Frankie Financial. This will never change. Your API key, which is mapped to this identity, will change over time. ")],
        entity_idv_details: Annotated[EntityIDVDetailsObject, Field(description="The entity and required data to generate an IDV token")],
        x_frankie_customer_child_id: Annotated[Optional[StrictStr], Field(description="If, as a Frankie Customer, you are acting on behalf of your own customers, then you can populate this field with a Frankie-assigned ID.  Note: If using a CustomerChildID, you will also need a separate api_key for each child.  Any documents, checks, entities that are created when this field has been populated will now be tied to this CustomerID + CustomerChildID combination. Just as Customers cannot see data created by other Customers, so too a Customer's Children will not be able to see each other's data.  A Customer can see the documents/entities and checks of all their Children. ")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> EntityIDVResultObject:
        """Create Entity and Get IDV Token

        Create an entity object and if successful, obtain a token for use in an ID Validation service SDK (web or native app)   At a minimum, you will need to supply:  - the entity familyName.   - the entity givenName    For best results, you should gather the DoB, address, ID document details as well before  calling the initProcess function.  SPECIAL NOTE 1: Tokens have a limited lifespan, typically only 1 hour. Make sure you've used it or you will need to create another using update version of this function.   SPECIAL NOTE 2: This function will need to be followed up with a call to /entity/{id}/idvalidate/initProcess once you've collected all your data in your app/web capture process. 

        :param x_frankie_customer_id: Customer ID issued by Frankie Financial. This will never change. Your API key, which is mapped to this identity, will change over time.  (required)
        :type x_frankie_customer_id: str
        :param entity_idv_details: The entity and required data to generate an IDV token (required)
        :type entity_idv_details: EntityIDVDetailsObject
        :param x_frankie_customer_child_id: If, as a Frankie Customer, you are acting on behalf of your own customers, then you can populate this field with a Frankie-assigned ID.  Note: If using a CustomerChildID, you will also need a separate api_key for each child.  Any documents, checks, entities that are created when this field has been populated will now be tied to this CustomerID + CustomerChildID combination. Just as Customers cannot see data created by other Customers, so too a Customer's Children will not be able to see each other's data.  A Customer can see the documents/entities and checks of all their Children. 
        :type x_frankie_customer_child_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_entity_get_idv_token_serialize(
            x_frankie_customer_id=x_frankie_customer_id,
            entity_idv_details=entity_idv_details,
            x_frankie_customer_child_id=x_frankie_customer_child_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "EntityIDVResultObject",
            '400': "ErrorObject",
            '401': "ErrorObject",
            '404': "ErrorObject",
            '405': "ErrorObject",
            '415': "ErrorObject",
            '422': "ErrorObject",
            '429': "ErrorObject",
            '500': "ErrorObject",
            '503': "ErrorObject",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def create_entity_get_idv_token_with_http_info(
        self,
        x_frankie_customer_id: Annotated[StrictStr, Field(description="Customer ID issued by Frankie Financial. This will never change. Your API key, which is mapped to this identity, will change over time. ")],
        entity_idv_details: Annotated[EntityIDVDetailsObject, Field(description="The entity and required data to generate an IDV token")],
        x_frankie_customer_child_id: Annotated[Optional[StrictStr], Field(description="If, as a Frankie Customer, you are acting on behalf of your own customers, then you can populate this field with a Frankie-assigned ID.  Note: If using a CustomerChildID, you will also need a separate api_key for each child.  Any documents, checks, entities that are created when this field has been populated will now be tied to this CustomerID + CustomerChildID combination. Just as Customers cannot see data created by other Customers, so too a Customer's Children will not be able to see each other's data.  A Customer can see the documents/entities and checks of all their Children. ")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[EntityIDVResultObject]:
        """Create Entity and Get IDV Token

        Create an entity object and if successful, obtain a token for use in an ID Validation service SDK (web or native app)   At a minimum, you will need to supply:  - the entity familyName.   - the entity givenName    For best results, you should gather the DoB, address, ID document details as well before  calling the initProcess function.  SPECIAL NOTE 1: Tokens have a limited lifespan, typically only 1 hour. Make sure you've used it or you will need to create another using update version of this function.   SPECIAL NOTE 2: This function will need to be followed up with a call to /entity/{id}/idvalidate/initProcess once you've collected all your data in your app/web capture process. 

        :param x_frankie_customer_id: Customer ID issued by Frankie Financial. This will never change. Your API key, which is mapped to this identity, will change over time.  (required)
        :type x_frankie_customer_id: str
        :param entity_idv_details: The entity and required data to generate an IDV token (required)
        :type entity_idv_details: EntityIDVDetailsObject
        :param x_frankie_customer_child_id: If, as a Frankie Customer, you are acting on behalf of your own customers, then you can populate this field with a Frankie-assigned ID.  Note: If using a CustomerChildID, you will also need a separate api_key for each child.  Any documents, checks, entities that are created when this field has been populated will now be tied to this CustomerID + CustomerChildID combination. Just as Customers cannot see data created by other Customers, so too a Customer's Children will not be able to see each other's data.  A Customer can see the documents/entities and checks of all their Children. 
        :type x_frankie_customer_child_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_entity_get_idv_token_serialize(
            x_frankie_customer_id=x_frankie_customer_id,
            entity_idv_details=entity_idv_details,
            x_frankie_customer_child_id=x_frankie_customer_child_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "EntityIDVResultObject",
            '400': "ErrorObject",
            '401': "ErrorObject",
            '404': "ErrorObject",
            '405': "ErrorObject",
            '415': "ErrorObject",
            '422': "ErrorObject",
            '429': "ErrorObject",
            '500': "ErrorObject",
            '503': "ErrorObject",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def create_entity_get_idv_token_without_preload_content(
        self,
        x_frankie_customer_id: Annotated[StrictStr, Field(description="Customer ID issued by Frankie Financial. This will never change. Your API key, which is mapped to this identity, will change over time. ")],
        entity_idv_details: Annotated[EntityIDVDetailsObject, Field(description="The entity and required data to generate an IDV token")],
        x_frankie_customer_child_id: Annotated[Optional[StrictStr], Field(description="If, as a Frankie Customer, you are acting on behalf of your own customers, then you can populate this field with a Frankie-assigned ID.  Note: If using a CustomerChildID, you will also need a separate api_key for each child.  Any documents, checks, entities that are created when this field has been populated will now be tied to this CustomerID + CustomerChildID combination. Just as Customers cannot see data created by other Customers, so too a Customer's Children will not be able to see each other's data.  A Customer can see the documents/entities and checks of all their Children. ")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Create Entity and Get IDV Token

        Create an entity object and if successful, obtain a token for use in an ID Validation service SDK (web or native app)   At a minimum, you will need to supply:  - the entity familyName.   - the entity givenName    For best results, you should gather the DoB, address, ID document details as well before  calling the initProcess function.  SPECIAL NOTE 1: Tokens have a limited lifespan, typically only 1 hour. Make sure you've used it or you will need to create another using update version of this function.   SPECIAL NOTE 2: This function will need to be followed up with a call to /entity/{id}/idvalidate/initProcess once you've collected all your data in your app/web capture process. 

        :param x_frankie_customer_id: Customer ID issued by Frankie Financial. This will never change. Your API key, which is mapped to this identity, will change over time.  (required)
        :type x_frankie_customer_id: str
        :param entity_idv_details: The entity and required data to generate an IDV token (required)
        :type entity_idv_details: EntityIDVDetailsObject
        :param x_frankie_customer_child_id: If, as a Frankie Customer, you are acting on behalf of your own customers, then you can populate this field with a Frankie-assigned ID.  Note: If using a CustomerChildID, you will also need a separate api_key for each child.  Any documents, checks, entities that are created when this field has been populated will now be tied to this CustomerID + CustomerChildID combination. Just as Customers cannot see data created by other Customers, so too a Customer's Children will not be able to see each other's data.  A Customer can see the documents/entities and checks of all their Children. 
        :type x_frankie_customer_child_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_entity_get_idv_token_serialize(
            x_frankie_customer_id=x_frankie_customer_id,
            entity_idv_details=entity_idv_details,
            x_frankie_customer_child_id=x_frankie_customer_child_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "EntityIDVResultObject",
            '400': "ErrorObject",
            '401': "ErrorObject",
            '404': "ErrorObject",
            '405': "ErrorObject",
            '415': "ErrorObject",
            '422': "ErrorObject",
            '429': "ErrorObject",
            '500': "ErrorObject",
            '503': "ErrorObject",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _create_entity_get_idv_token_serialize(
        self,
        x_frankie_customer_id,
        entity_idv_details,
        x_frankie_customer_child_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        if x_frankie_customer_id is not None:
            _header_params['X-Frankie-CustomerID'] = x_frankie_customer_id
        if x_frankie_customer_child_id is not None:
            _header_params['X-Frankie-CustomerChildID'] = x_frankie_customer_child_id
        # process the form parameters
        # process the body parameter
        if entity_idv_details is not None:
            _body_params = entity_idv_details


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'api_key'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/entity/new/idvalidate/getToken',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def delete_entity(
        self,
        x_frankie_customer_id: Annotated[StrictStr, Field(description="Customer ID issued by Frankie Financial. This will never change. Your API key, which is mapped to this identity, will change over time. ")],
        entity_id: Annotated[StrictStr, Field(description="The entityId returned previously from an earlier call to /check or /entity")],
        x_frankie_customer_child_id: Annotated[Optional[StrictStr], Field(description="If, as a Frankie Customer, you are acting on behalf of your own customers, then you can populate this field with a Frankie-assigned ID.  Note: If using a CustomerChildID, you will also need a separate api_key for each child.  Any documents, checks, entities that are created when this field has been populated will now be tied to this CustomerID + CustomerChildID combination. Just as Customers cannot see data created by other Customers, so too a Customer's Children will not be able to see each other's data.  A Customer can see the documents/entities and checks of all their Children. ")] = None,
        x_frankie_background: Annotated[Optional[Annotated[int, Field(le=1, strict=True, ge=0)]], Field(description="If this header parameter is supplied and set to 1, then the request will not wait for the process to finish, and will return a 202 if there are no obvious errors in the input. The request will then run in the background and send a notification back to the customer. See out callback API for details on this.  See more details here:   https://apidocs.frankiefinancial.com/docs/asynchronous-calls-backgrounding-processes ")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> BasicStatusResultObject:
        """Delete Entity

        Marks the entity as deleted in the system, and no further operations or general queries may be executed against it by the Customer. If another customer is presently relying on this data, it will still be available to them (but only in the partially anonymised form they originally had.  An entity and its related data is only completely deleted from the database when either:    - a) There are no more references to it (i.e. it has been DELETEd by all Customers relying on the data), and 12 months have passed.      - b) The actual consumer who owns the data makes a direct request. If this occurs, then all subscribing Customers will be notified that this entity has been removed and they will need to contact them if needed in order to update their own records again. 

        :param x_frankie_customer_id: Customer ID issued by Frankie Financial. This will never change. Your API key, which is mapped to this identity, will change over time.  (required)
        :type x_frankie_customer_id: str
        :param entity_id: The entityId returned previously from an earlier call to /check or /entity (required)
        :type entity_id: str
        :param x_frankie_customer_child_id: If, as a Frankie Customer, you are acting on behalf of your own customers, then you can populate this field with a Frankie-assigned ID.  Note: If using a CustomerChildID, you will also need a separate api_key for each child.  Any documents, checks, entities that are created when this field has been populated will now be tied to this CustomerID + CustomerChildID combination. Just as Customers cannot see data created by other Customers, so too a Customer's Children will not be able to see each other's data.  A Customer can see the documents/entities and checks of all their Children. 
        :type x_frankie_customer_child_id: str
        :param x_frankie_background: If this header parameter is supplied and set to 1, then the request will not wait for the process to finish, and will return a 202 if there are no obvious errors in the input. The request will then run in the background and send a notification back to the customer. See out callback API for details on this.  See more details here:   https://apidocs.frankiefinancial.com/docs/asynchronous-calls-backgrounding-processes 
        :type x_frankie_background: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_entity_serialize(
            x_frankie_customer_id=x_frankie_customer_id,
            entity_id=entity_id,
            x_frankie_customer_child_id=x_frankie_customer_child_id,
            x_frankie_background=x_frankie_background,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "BasicStatusResultObject",
            '202': "AcceptedEntityResultObject",
            '400': "ErrorObject",
            '401': "ErrorObject",
            '404': "ErrorObject",
            '429': "ErrorObject",
            '500': "ErrorObject",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def delete_entity_with_http_info(
        self,
        x_frankie_customer_id: Annotated[StrictStr, Field(description="Customer ID issued by Frankie Financial. This will never change. Your API key, which is mapped to this identity, will change over time. ")],
        entity_id: Annotated[StrictStr, Field(description="The entityId returned previously from an earlier call to /check or /entity")],
        x_frankie_customer_child_id: Annotated[Optional[StrictStr], Field(description="If, as a Frankie Customer, you are acting on behalf of your own customers, then you can populate this field with a Frankie-assigned ID.  Note: If using a CustomerChildID, you will also need a separate api_key for each child.  Any documents, checks, entities that are created when this field has been populated will now be tied to this CustomerID + CustomerChildID combination. Just as Customers cannot see data created by other Customers, so too a Customer's Children will not be able to see each other's data.  A Customer can see the documents/entities and checks of all their Children. ")] = None,
        x_frankie_background: Annotated[Optional[Annotated[int, Field(le=1, strict=True, ge=0)]], Field(description="If this header parameter is supplied and set to 1, then the request will not wait for the process to finish, and will return a 202 if there are no obvious errors in the input. The request will then run in the background and send a notification back to the customer. See out callback API for details on this.  See more details here:   https://apidocs.frankiefinancial.com/docs/asynchronous-calls-backgrounding-processes ")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[BasicStatusResultObject]:
        """Delete Entity

        Marks the entity as deleted in the system, and no further operations or general queries may be executed against it by the Customer. If another customer is presently relying on this data, it will still be available to them (but only in the partially anonymised form they originally had.  An entity and its related data is only completely deleted from the database when either:    - a) There are no more references to it (i.e. it has been DELETEd by all Customers relying on the data), and 12 months have passed.      - b) The actual consumer who owns the data makes a direct request. If this occurs, then all subscribing Customers will be notified that this entity has been removed and they will need to contact them if needed in order to update their own records again. 

        :param x_frankie_customer_id: Customer ID issued by Frankie Financial. This will never change. Your API key, which is mapped to this identity, will change over time.  (required)
        :type x_frankie_customer_id: str
        :param entity_id: The entityId returned previously from an earlier call to /check or /entity (required)
        :type entity_id: str
        :param x_frankie_customer_child_id: If, as a Frankie Customer, you are acting on behalf of your own customers, then you can populate this field with a Frankie-assigned ID.  Note: If using a CustomerChildID, you will also need a separate api_key for each child.  Any documents, checks, entities that are created when this field has been populated will now be tied to this CustomerID + CustomerChildID combination. Just as Customers cannot see data created by other Customers, so too a Customer's Children will not be able to see each other's data.  A Customer can see the documents/entities and checks of all their Children. 
        :type x_frankie_customer_child_id: str
        :param x_frankie_background: If this header parameter is supplied and set to 1, then the request will not wait for the process to finish, and will return a 202 if there are no obvious errors in the input. The request will then run in the background and send a notification back to the customer. See out callback API for details on this.  See more details here:   https://apidocs.frankiefinancial.com/docs/asynchronous-calls-backgrounding-processes 
        :type x_frankie_background: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_entity_serialize(
            x_frankie_customer_id=x_frankie_customer_id,
            entity_id=entity_id,
            x_frankie_customer_child_id=x_frankie_customer_child_id,
            x_frankie_background=x_frankie_background,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "BasicStatusResultObject",
            '202': "AcceptedEntityResultObject",
            '400': "ErrorObject",
            '401': "ErrorObject",
            '404': "ErrorObject",
            '429': "ErrorObject",
            '500': "ErrorObject",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def delete_entity_without_preload_content(
        self,
        x_frankie_customer_id: Annotated[StrictStr, Field(description="Customer ID issued by Frankie Financial. This will never change. Your API key, which is mapped to this identity, will change over time. ")],
        entity_id: Annotated[StrictStr, Field(description="The entityId returned previously from an earlier call to /check or /entity")],
        x_frankie_customer_child_id: Annotated[Optional[StrictStr], Field(description="If, as a Frankie Customer, you are acting on behalf of your own customers, then you can populate this field with a Frankie-assigned ID.  Note: If using a CustomerChildID, you will also need a separate api_key for each child.  Any documents, checks, entities that are created when this field has been populated will now be tied to this CustomerID + CustomerChildID combination. Just as Customers cannot see data created by other Customers, so too a Customer's Children will not be able to see each other's data.  A Customer can see the documents/entities and checks of all their Children. ")] = None,
        x_frankie_background: Annotated[Optional[Annotated[int, Field(le=1, strict=True, ge=0)]], Field(description="If this header parameter is supplied and set to 1, then the request will not wait for the process to finish, and will return a 202 if there are no obvious errors in the input. The request will then run in the background and send a notification back to the customer. See out callback API for details on this.  See more details here:   https://apidocs.frankiefinancial.com/docs/asynchronous-calls-backgrounding-processes ")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Delete Entity

        Marks the entity as deleted in the system, and no further operations or general queries may be executed against it by the Customer. If another customer is presently relying on this data, it will still be available to them (but only in the partially anonymised form they originally had.  An entity and its related data is only completely deleted from the database when either:    - a) There are no more references to it (i.e. it has been DELETEd by all Customers relying on the data), and 12 months have passed.      - b) The actual consumer who owns the data makes a direct request. If this occurs, then all subscribing Customers will be notified that this entity has been removed and they will need to contact them if needed in order to update their own records again. 

        :param x_frankie_customer_id: Customer ID issued by Frankie Financial. This will never change. Your API key, which is mapped to this identity, will change over time.  (required)
        :type x_frankie_customer_id: str
        :param entity_id: The entityId returned previously from an earlier call to /check or /entity (required)
        :type entity_id: str
        :param x_frankie_customer_child_id: If, as a Frankie Customer, you are acting on behalf of your own customers, then you can populate this field with a Frankie-assigned ID.  Note: If using a CustomerChildID, you will also need a separate api_key for each child.  Any documents, checks, entities that are created when this field has been populated will now be tied to this CustomerID + CustomerChildID combination. Just as Customers cannot see data created by other Customers, so too a Customer's Children will not be able to see each other's data.  A Customer can see the documents/entities and checks of all their Children. 
        :type x_frankie_customer_child_id: str
        :param x_frankie_background: If this header parameter is supplied and set to 1, then the request will not wait for the process to finish, and will return a 202 if there are no obvious errors in the input. The request will then run in the background and send a notification back to the customer. See out callback API for details on this.  See more details here:   https://apidocs.frankiefinancial.com/docs/asynchronous-calls-backgrounding-processes 
        :type x_frankie_background: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_entity_serialize(
            x_frankie_customer_id=x_frankie_customer_id,
            entity_id=entity_id,
            x_frankie_customer_child_id=x_frankie_customer_child_id,
            x_frankie_background=x_frankie_background,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "BasicStatusResultObject",
            '202': "AcceptedEntityResultObject",
            '400': "ErrorObject",
            '401': "ErrorObject",
            '404': "ErrorObject",
            '429': "ErrorObject",
            '500': "ErrorObject",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _delete_entity_serialize(
        self,
        x_frankie_customer_id,
        entity_id,
        x_frankie_customer_child_id,
        x_frankie_background,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if entity_id is not None:
            _path_params['entityId'] = entity_id
        # process the query parameters
        # process the header parameters
        if x_frankie_customer_id is not None:
            _header_params['X-Frankie-CustomerID'] = x_frankie_customer_id
        if x_frankie_customer_child_id is not None:
            _header_params['X-Frankie-CustomerChildID'] = x_frankie_customer_child_id
        if x_frankie_background is not None:
            _header_params['X-Frankie-Background'] = x_frankie_background
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'api_key'
        ]

        return self.api_client.param_serialize(
            method='DELETE',
            resource_path='/entity/{entityId}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def query_entity(
        self,
        x_frankie_customer_id: Annotated[StrictStr, Field(description="Customer ID issued by Frankie Financial. This will never change. Your API key, which is mapped to this identity, will change over time. ")],
        entity_id: Annotated[StrictStr, Field(description="The entityId returned previously from an earlier call to /check or /entity")],
        x_frankie_customer_child_id: Annotated[Optional[StrictStr], Field(description="If, as a Frankie Customer, you are acting on behalf of your own customers, then you can populate this field with a Frankie-assigned ID.  Note: If using a CustomerChildID, you will also need a separate api_key for each child.  Any documents, checks, entities that are created when this field has been populated will now be tied to this CustomerID + CustomerChildID combination. Just as Customers cannot see data created by other Customers, so too a Customer's Children will not be able to see each other's data.  A Customer can see the documents/entities and checks of all their Children. ")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> EntityResultObject:
        """Retrieve Entity Details

        Query the current status and details of a given entityId. 

        :param x_frankie_customer_id: Customer ID issued by Frankie Financial. This will never change. Your API key, which is mapped to this identity, will change over time.  (required)
        :type x_frankie_customer_id: str
        :param entity_id: The entityId returned previously from an earlier call to /check or /entity (required)
        :type entity_id: str
        :param x_frankie_customer_child_id: If, as a Frankie Customer, you are acting on behalf of your own customers, then you can populate this field with a Frankie-assigned ID.  Note: If using a CustomerChildID, you will also need a separate api_key for each child.  Any documents, checks, entities that are created when this field has been populated will now be tied to this CustomerID + CustomerChildID combination. Just as Customers cannot see data created by other Customers, so too a Customer's Children will not be able to see each other's data.  A Customer can see the documents/entities and checks of all their Children. 
        :type x_frankie_customer_child_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._query_entity_serialize(
            x_frankie_customer_id=x_frankie_customer_id,
            entity_id=entity_id,
            x_frankie_customer_child_id=x_frankie_customer_child_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "EntityResultObject",
            '400': "ErrorObject",
            '401': "ErrorObject",
            '404': "ErrorObject",
            '429': "ErrorObject",
            '500': "ErrorObject",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def query_entity_with_http_info(
        self,
        x_frankie_customer_id: Annotated[StrictStr, Field(description="Customer ID issued by Frankie Financial. This will never change. Your API key, which is mapped to this identity, will change over time. ")],
        entity_id: Annotated[StrictStr, Field(description="The entityId returned previously from an earlier call to /check or /entity")],
        x_frankie_customer_child_id: Annotated[Optional[StrictStr], Field(description="If, as a Frankie Customer, you are acting on behalf of your own customers, then you can populate this field with a Frankie-assigned ID.  Note: If using a CustomerChildID, you will also need a separate api_key for each child.  Any documents, checks, entities that are created when this field has been populated will now be tied to this CustomerID + CustomerChildID combination. Just as Customers cannot see data created by other Customers, so too a Customer's Children will not be able to see each other's data.  A Customer can see the documents/entities and checks of all their Children. ")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[EntityResultObject]:
        """Retrieve Entity Details

        Query the current status and details of a given entityId. 

        :param x_frankie_customer_id: Customer ID issued by Frankie Financial. This will never change. Your API key, which is mapped to this identity, will change over time.  (required)
        :type x_frankie_customer_id: str
        :param entity_id: The entityId returned previously from an earlier call to /check or /entity (required)
        :type entity_id: str
        :param x_frankie_customer_child_id: If, as a Frankie Customer, you are acting on behalf of your own customers, then you can populate this field with a Frankie-assigned ID.  Note: If using a CustomerChildID, you will also need a separate api_key for each child.  Any documents, checks, entities that are created when this field has been populated will now be tied to this CustomerID + CustomerChildID combination. Just as Customers cannot see data created by other Customers, so too a Customer's Children will not be able to see each other's data.  A Customer can see the documents/entities and checks of all their Children. 
        :type x_frankie_customer_child_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._query_entity_serialize(
            x_frankie_customer_id=x_frankie_customer_id,
            entity_id=entity_id,
            x_frankie_customer_child_id=x_frankie_customer_child_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "EntityResultObject",
            '400': "ErrorObject",
            '401': "ErrorObject",
            '404': "ErrorObject",
            '429': "ErrorObject",
            '500': "ErrorObject",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def query_entity_without_preload_content(
        self,
        x_frankie_customer_id: Annotated[StrictStr, Field(description="Customer ID issued by Frankie Financial. This will never change. Your API key, which is mapped to this identity, will change over time. ")],
        entity_id: Annotated[StrictStr, Field(description="The entityId returned previously from an earlier call to /check or /entity")],
        x_frankie_customer_child_id: Annotated[Optional[StrictStr], Field(description="If, as a Frankie Customer, you are acting on behalf of your own customers, then you can populate this field with a Frankie-assigned ID.  Note: If using a CustomerChildID, you will also need a separate api_key for each child.  Any documents, checks, entities that are created when this field has been populated will now be tied to this CustomerID + CustomerChildID combination. Just as Customers cannot see data created by other Customers, so too a Customer's Children will not be able to see each other's data.  A Customer can see the documents/entities and checks of all their Children. ")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Retrieve Entity Details

        Query the current status and details of a given entityId. 

        :param x_frankie_customer_id: Customer ID issued by Frankie Financial. This will never change. Your API key, which is mapped to this identity, will change over time.  (required)
        :type x_frankie_customer_id: str
        :param entity_id: The entityId returned previously from an earlier call to /check or /entity (required)
        :type entity_id: str
        :param x_frankie_customer_child_id: If, as a Frankie Customer, you are acting on behalf of your own customers, then you can populate this field with a Frankie-assigned ID.  Note: If using a CustomerChildID, you will also need a separate api_key for each child.  Any documents, checks, entities that are created when this field has been populated will now be tied to this CustomerID + CustomerChildID combination. Just as Customers cannot see data created by other Customers, so too a Customer's Children will not be able to see each other's data.  A Customer can see the documents/entities and checks of all their Children. 
        :type x_frankie_customer_child_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._query_entity_serialize(
            x_frankie_customer_id=x_frankie_customer_id,
            entity_id=entity_id,
            x_frankie_customer_child_id=x_frankie_customer_child_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "EntityResultObject",
            '400': "ErrorObject",
            '401': "ErrorObject",
            '404': "ErrorObject",
            '429': "ErrorObject",
            '500': "ErrorObject",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _query_entity_serialize(
        self,
        x_frankie_customer_id,
        entity_id,
        x_frankie_customer_child_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if entity_id is not None:
            _path_params['entityId'] = entity_id
        # process the query parameters
        # process the header parameters
        if x_frankie_customer_id is not None:
            _header_params['X-Frankie-CustomerID'] = x_frankie_customer_id
        if x_frankie_customer_child_id is not None:
            _header_params['X-Frankie-CustomerChildID'] = x_frankie_customer_child_id
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'api_key'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/entity/{entityId}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def query_entity_checks(
        self,
        x_frankie_customer_id: Annotated[StrictStr, Field(description="Customer ID issued by Frankie Financial. This will never change. Your API key, which is mapped to this identity, will change over time. ")],
        entity_id: Annotated[StrictStr, Field(description="The entityId returned previously from an earlier call to /check or /entity")],
        x_frankie_customer_child_id: Annotated[Optional[StrictStr], Field(description="If, as a Frankie Customer, you are acting on behalf of your own customers, then you can populate this field with a Frankie-assigned ID.  Note: If using a CustomerChildID, you will also need a separate api_key for each child.  Any documents, checks, entities that are created when this field has been populated will now be tied to this CustomerID + CustomerChildID combination. Just as Customers cannot see data created by other Customers, so too a Customer's Children will not be able to see each other's data.  A Customer can see the documents/entities and checks of all their Children. ")] = None,
        alldata: Annotated[Optional[StrictBool], Field(description="Requests that literally all data should be included in the response to a \"get checks\" request. This is as opposed to a filtered view where expired results are by default not included for entities that have an assigned profile. ")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> CheckEntityCheckResultObject:
        """Retrieve Entity Verication Check Details 

        Get the complete list of all checks that have been performed upon a given entity and its documents, including the checks that have been performed by others (in those cases you just get the id, status and date run, none of the details). 

        :param x_frankie_customer_id: Customer ID issued by Frankie Financial. This will never change. Your API key, which is mapped to this identity, will change over time.  (required)
        :type x_frankie_customer_id: str
        :param entity_id: The entityId returned previously from an earlier call to /check or /entity (required)
        :type entity_id: str
        :param x_frankie_customer_child_id: If, as a Frankie Customer, you are acting on behalf of your own customers, then you can populate this field with a Frankie-assigned ID.  Note: If using a CustomerChildID, you will also need a separate api_key for each child.  Any documents, checks, entities that are created when this field has been populated will now be tied to this CustomerID + CustomerChildID combination. Just as Customers cannot see data created by other Customers, so too a Customer's Children will not be able to see each other's data.  A Customer can see the documents/entities and checks of all their Children. 
        :type x_frankie_customer_child_id: str
        :param alldata: Requests that literally all data should be included in the response to a \"get checks\" request. This is as opposed to a filtered view where expired results are by default not included for entities that have an assigned profile. 
        :type alldata: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._query_entity_checks_serialize(
            x_frankie_customer_id=x_frankie_customer_id,
            entity_id=entity_id,
            x_frankie_customer_child_id=x_frankie_customer_child_id,
            alldata=alldata,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CheckEntityCheckResultObject",
            '400': "ErrorObject",
            '401': "ErrorObject",
            '404': "ErrorObject",
            '429': "ErrorObject",
            '500': "ErrorObject",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def query_entity_checks_with_http_info(
        self,
        x_frankie_customer_id: Annotated[StrictStr, Field(description="Customer ID issued by Frankie Financial. This will never change. Your API key, which is mapped to this identity, will change over time. ")],
        entity_id: Annotated[StrictStr, Field(description="The entityId returned previously from an earlier call to /check or /entity")],
        x_frankie_customer_child_id: Annotated[Optional[StrictStr], Field(description="If, as a Frankie Customer, you are acting on behalf of your own customers, then you can populate this field with a Frankie-assigned ID.  Note: If using a CustomerChildID, you will also need a separate api_key for each child.  Any documents, checks, entities that are created when this field has been populated will now be tied to this CustomerID + CustomerChildID combination. Just as Customers cannot see data created by other Customers, so too a Customer's Children will not be able to see each other's data.  A Customer can see the documents/entities and checks of all their Children. ")] = None,
        alldata: Annotated[Optional[StrictBool], Field(description="Requests that literally all data should be included in the response to a \"get checks\" request. This is as opposed to a filtered view where expired results are by default not included for entities that have an assigned profile. ")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[CheckEntityCheckResultObject]:
        """Retrieve Entity Verication Check Details 

        Get the complete list of all checks that have been performed upon a given entity and its documents, including the checks that have been performed by others (in those cases you just get the id, status and date run, none of the details). 

        :param x_frankie_customer_id: Customer ID issued by Frankie Financial. This will never change. Your API key, which is mapped to this identity, will change over time.  (required)
        :type x_frankie_customer_id: str
        :param entity_id: The entityId returned previously from an earlier call to /check or /entity (required)
        :type entity_id: str
        :param x_frankie_customer_child_id: If, as a Frankie Customer, you are acting on behalf of your own customers, then you can populate this field with a Frankie-assigned ID.  Note: If using a CustomerChildID, you will also need a separate api_key for each child.  Any documents, checks, entities that are created when this field has been populated will now be tied to this CustomerID + CustomerChildID combination. Just as Customers cannot see data created by other Customers, so too a Customer's Children will not be able to see each other's data.  A Customer can see the documents/entities and checks of all their Children. 
        :type x_frankie_customer_child_id: str
        :param alldata: Requests that literally all data should be included in the response to a \"get checks\" request. This is as opposed to a filtered view where expired results are by default not included for entities that have an assigned profile. 
        :type alldata: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._query_entity_checks_serialize(
            x_frankie_customer_id=x_frankie_customer_id,
            entity_id=entity_id,
            x_frankie_customer_child_id=x_frankie_customer_child_id,
            alldata=alldata,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CheckEntityCheckResultObject",
            '400': "ErrorObject",
            '401': "ErrorObject",
            '404': "ErrorObject",
            '429': "ErrorObject",
            '500': "ErrorObject",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def query_entity_checks_without_preload_content(
        self,
        x_frankie_customer_id: Annotated[StrictStr, Field(description="Customer ID issued by Frankie Financial. This will never change. Your API key, which is mapped to this identity, will change over time. ")],
        entity_id: Annotated[StrictStr, Field(description="The entityId returned previously from an earlier call to /check or /entity")],
        x_frankie_customer_child_id: Annotated[Optional[StrictStr], Field(description="If, as a Frankie Customer, you are acting on behalf of your own customers, then you can populate this field with a Frankie-assigned ID.  Note: If using a CustomerChildID, you will also need a separate api_key for each child.  Any documents, checks, entities that are created when this field has been populated will now be tied to this CustomerID + CustomerChildID combination. Just as Customers cannot see data created by other Customers, so too a Customer's Children will not be able to see each other's data.  A Customer can see the documents/entities and checks of all their Children. ")] = None,
        alldata: Annotated[Optional[StrictBool], Field(description="Requests that literally all data should be included in the response to a \"get checks\" request. This is as opposed to a filtered view where expired results are by default not included for entities that have an assigned profile. ")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Retrieve Entity Verication Check Details 

        Get the complete list of all checks that have been performed upon a given entity and its documents, including the checks that have been performed by others (in those cases you just get the id, status and date run, none of the details). 

        :param x_frankie_customer_id: Customer ID issued by Frankie Financial. This will never change. Your API key, which is mapped to this identity, will change over time.  (required)
        :type x_frankie_customer_id: str
        :param entity_id: The entityId returned previously from an earlier call to /check or /entity (required)
        :type entity_id: str
        :param x_frankie_customer_child_id: If, as a Frankie Customer, you are acting on behalf of your own customers, then you can populate this field with a Frankie-assigned ID.  Note: If using a CustomerChildID, you will also need a separate api_key for each child.  Any documents, checks, entities that are created when this field has been populated will now be tied to this CustomerID + CustomerChildID combination. Just as Customers cannot see data created by other Customers, so too a Customer's Children will not be able to see each other's data.  A Customer can see the documents/entities and checks of all their Children. 
        :type x_frankie_customer_child_id: str
        :param alldata: Requests that literally all data should be included in the response to a \"get checks\" request. This is as opposed to a filtered view where expired results are by default not included for entities that have an assigned profile. 
        :type alldata: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._query_entity_checks_serialize(
            x_frankie_customer_id=x_frankie_customer_id,
            entity_id=entity_id,
            x_frankie_customer_child_id=x_frankie_customer_child_id,
            alldata=alldata,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CheckEntityCheckResultObject",
            '400': "ErrorObject",
            '401': "ErrorObject",
            '404': "ErrorObject",
            '429': "ErrorObject",
            '500': "ErrorObject",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _query_entity_checks_serialize(
        self,
        x_frankie_customer_id,
        entity_id,
        x_frankie_customer_child_id,
        alldata,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if entity_id is not None:
            _path_params['entityId'] = entity_id
        # process the query parameters
        if alldata is not None:
            
            _query_params.append(('alldata', alldata))
            
        # process the header parameters
        if x_frankie_customer_id is not None:
            _header_params['X-Frankie-CustomerID'] = x_frankie_customer_id
        if x_frankie_customer_child_id is not None:
            _header_params['X-Frankie-CustomerChildID'] = x_frankie_customer_child_id
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'api_key'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/entity/{entityId}/checks',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def query_entity_full(
        self,
        x_frankie_customer_id: Annotated[StrictStr, Field(description="Customer ID issued by Frankie Financial. This will never change. Your API key, which is mapped to this identity, will change over time. ")],
        entity_id: Annotated[StrictStr, Field(description="The entityId returned previously from an earlier call to /check or /entity")],
        x_frankie_customer_child_id: Annotated[Optional[StrictStr], Field(description="If, as a Frankie Customer, you are acting on behalf of your own customers, then you can populate this field with a Frankie-assigned ID.  Note: If using a CustomerChildID, you will also need a separate api_key for each child.  Any documents, checks, entities that are created when this field has been populated will now be tied to this CustomerID + CustomerChildID combination. Just as Customers cannot see data created by other Customers, so too a Customer's Children will not be able to see each other's data.  A Customer can see the documents/entities and checks of all their Children. ")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> EntityResultObject:
        """Retrieve Entity Details and Document Scan Data 

        Query the current status and details of a given entityId. Also returns all attached document file data, not just the metadata. Equivalent to a get /document/{documentId}/full) 

        :param x_frankie_customer_id: Customer ID issued by Frankie Financial. This will never change. Your API key, which is mapped to this identity, will change over time.  (required)
        :type x_frankie_customer_id: str
        :param entity_id: The entityId returned previously from an earlier call to /check or /entity (required)
        :type entity_id: str
        :param x_frankie_customer_child_id: If, as a Frankie Customer, you are acting on behalf of your own customers, then you can populate this field with a Frankie-assigned ID.  Note: If using a CustomerChildID, you will also need a separate api_key for each child.  Any documents, checks, entities that are created when this field has been populated will now be tied to this CustomerID + CustomerChildID combination. Just as Customers cannot see data created by other Customers, so too a Customer's Children will not be able to see each other's data.  A Customer can see the documents/entities and checks of all their Children. 
        :type x_frankie_customer_child_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._query_entity_full_serialize(
            x_frankie_customer_id=x_frankie_customer_id,
            entity_id=entity_id,
            x_frankie_customer_child_id=x_frankie_customer_child_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "EntityResultObject",
            '400': "ErrorObject",
            '401': "ErrorObject",
            '404': "ErrorObject",
            '429': "ErrorObject",
            '500': "ErrorObject",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def query_entity_full_with_http_info(
        self,
        x_frankie_customer_id: Annotated[StrictStr, Field(description="Customer ID issued by Frankie Financial. This will never change. Your API key, which is mapped to this identity, will change over time. ")],
        entity_id: Annotated[StrictStr, Field(description="The entityId returned previously from an earlier call to /check or /entity")],
        x_frankie_customer_child_id: Annotated[Optional[StrictStr], Field(description="If, as a Frankie Customer, you are acting on behalf of your own customers, then you can populate this field with a Frankie-assigned ID.  Note: If using a CustomerChildID, you will also need a separate api_key for each child.  Any documents, checks, entities that are created when this field has been populated will now be tied to this CustomerID + CustomerChildID combination. Just as Customers cannot see data created by other Customers, so too a Customer's Children will not be able to see each other's data.  A Customer can see the documents/entities and checks of all their Children. ")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[EntityResultObject]:
        """Retrieve Entity Details and Document Scan Data 

        Query the current status and details of a given entityId. Also returns all attached document file data, not just the metadata. Equivalent to a get /document/{documentId}/full) 

        :param x_frankie_customer_id: Customer ID issued by Frankie Financial. This will never change. Your API key, which is mapped to this identity, will change over time.  (required)
        :type x_frankie_customer_id: str
        :param entity_id: The entityId returned previously from an earlier call to /check or /entity (required)
        :type entity_id: str
        :param x_frankie_customer_child_id: If, as a Frankie Customer, you are acting on behalf of your own customers, then you can populate this field with a Frankie-assigned ID.  Note: If using a CustomerChildID, you will also need a separate api_key for each child.  Any documents, checks, entities that are created when this field has been populated will now be tied to this CustomerID + CustomerChildID combination. Just as Customers cannot see data created by other Customers, so too a Customer's Children will not be able to see each other's data.  A Customer can see the documents/entities and checks of all their Children. 
        :type x_frankie_customer_child_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._query_entity_full_serialize(
            x_frankie_customer_id=x_frankie_customer_id,
            entity_id=entity_id,
            x_frankie_customer_child_id=x_frankie_customer_child_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "EntityResultObject",
            '400': "ErrorObject",
            '401': "ErrorObject",
            '404': "ErrorObject",
            '429': "ErrorObject",
            '500': "ErrorObject",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def query_entity_full_without_preload_content(
        self,
        x_frankie_customer_id: Annotated[StrictStr, Field(description="Customer ID issued by Frankie Financial. This will never change. Your API key, which is mapped to this identity, will change over time. ")],
        entity_id: Annotated[StrictStr, Field(description="The entityId returned previously from an earlier call to /check or /entity")],
        x_frankie_customer_child_id: Annotated[Optional[StrictStr], Field(description="If, as a Frankie Customer, you are acting on behalf of your own customers, then you can populate this field with a Frankie-assigned ID.  Note: If using a CustomerChildID, you will also need a separate api_key for each child.  Any documents, checks, entities that are created when this field has been populated will now be tied to this CustomerID + CustomerChildID combination. Just as Customers cannot see data created by other Customers, so too a Customer's Children will not be able to see each other's data.  A Customer can see the documents/entities and checks of all their Children. ")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Retrieve Entity Details and Document Scan Data 

        Query the current status and details of a given entityId. Also returns all attached document file data, not just the metadata. Equivalent to a get /document/{documentId}/full) 

        :param x_frankie_customer_id: Customer ID issued by Frankie Financial. This will never change. Your API key, which is mapped to this identity, will change over time.  (required)
        :type x_frankie_customer_id: str
        :param entity_id: The entityId returned previously from an earlier call to /check or /entity (required)
        :type entity_id: str
        :param x_frankie_customer_child_id: If, as a Frankie Customer, you are acting on behalf of your own customers, then you can populate this field with a Frankie-assigned ID.  Note: If using a CustomerChildID, you will also need a separate api_key for each child.  Any documents, checks, entities that are created when this field has been populated will now be tied to this CustomerID + CustomerChildID combination. Just as Customers cannot see data created by other Customers, so too a Customer's Children will not be able to see each other's data.  A Customer can see the documents/entities and checks of all their Children. 
        :type x_frankie_customer_child_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._query_entity_full_serialize(
            x_frankie_customer_id=x_frankie_customer_id,
            entity_id=entity_id,
            x_frankie_customer_child_id=x_frankie_customer_child_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "EntityResultObject",
            '400': "ErrorObject",
            '401': "ErrorObject",
            '404': "ErrorObject",
            '429': "ErrorObject",
            '500': "ErrorObject",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _query_entity_full_serialize(
        self,
        x_frankie_customer_id,
        entity_id,
        x_frankie_customer_child_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if entity_id is not None:
            _path_params['entityId'] = entity_id
        # process the query parameters
        # process the header parameters
        if x_frankie_customer_id is not None:
            _header_params['X-Frankie-CustomerID'] = x_frankie_customer_id
        if x_frankie_customer_child_id is not None:
            _header_params['X-Frankie-CustomerChildID'] = x_frankie_customer_child_id
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'api_key'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/entity/{entityId}/full',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def search_entity(
        self,
        x_frankie_customer_id: Annotated[StrictStr, Field(description="Customer ID issued by Frankie Financial. This will never change. Your API key, which is mapped to this identity, will change over time. ")],
        search_entity: Annotated[EntityObject, Field(description="An entity object with the parameters you wish to search on. ")],
        x_frankie_customer_child_id: Annotated[Optional[StrictStr], Field(description="If, as a Frankie Customer, you are acting on behalf of your own customers, then you can populate this field with a Frankie-assigned ID.  Note: If using a CustomerChildID, you will also need a separate api_key for each child.  Any documents, checks, entities that are created when this field has been populated will now be tied to this CustomerID + CustomerChildID combination. Just as Customers cannot see data created by other Customers, so too a Customer's Children will not be able to see each other's data.  A Customer can see the documents/entities and checks of all their Children. ")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> EntitySearchResultObject:
        """Search for Entity

         Search for an existing entity that matches the criteria supplied  Criteria are supplied in the form of a populated entity object, with the name/address/DoB details supplied. You can also include documents that can be used to further refine your search (see the /document/search function for minimum requirements for a document search)  At an absolute minimum, you must supply one of the following combinations:    * name.familyName +   * name.givenNames      or      * name.familyName +   * one identityDocument object (that meets minimum criteria)    Obviously, the more data you provide, the better search results we can provide.  The service will return a list of matching entities with confidence levels.  If you are the \"owner\" of the entity - i.e. the same CustomerID and CustomerChildID (if relevant) - then the full details of the entity and any owned documents will be returned, except for the contents of any attached scans.  If you are not the owner of the entity (or linked documents), then just the ID and confidence level is returned. You can still use this ID to retrieve any check results (see GET  /entity/{entityId}/checks and GET /document/{documentId}/checks)  Note: This functionality must be enabled by Frankie administrators. Please contact your sales representative if you wish to discuss this. 

        :param x_frankie_customer_id: Customer ID issued by Frankie Financial. This will never change. Your API key, which is mapped to this identity, will change over time.  (required)
        :type x_frankie_customer_id: str
        :param search_entity: An entity object with the parameters you wish to search on.  (required)
        :type search_entity: EntityObject
        :param x_frankie_customer_child_id: If, as a Frankie Customer, you are acting on behalf of your own customers, then you can populate this field with a Frankie-assigned ID.  Note: If using a CustomerChildID, you will also need a separate api_key for each child.  Any documents, checks, entities that are created when this field has been populated will now be tied to this CustomerID + CustomerChildID combination. Just as Customers cannot see data created by other Customers, so too a Customer's Children will not be able to see each other's data.  A Customer can see the documents/entities and checks of all their Children. 
        :type x_frankie_customer_child_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._search_entity_serialize(
            x_frankie_customer_id=x_frankie_customer_id,
            search_entity=search_entity,
            x_frankie_customer_child_id=x_frankie_customer_child_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "EntitySearchResultObject",
            '400': "ErrorObject",
            '401': "ErrorObject",
            '404': "ErrorObject",
            '405': "ErrorObject",
            '422': "ErrorObject",
            '429': "ErrorObject",
            '500': "ErrorObject",
            '503': "ErrorObject",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def search_entity_with_http_info(
        self,
        x_frankie_customer_id: Annotated[StrictStr, Field(description="Customer ID issued by Frankie Financial. This will never change. Your API key, which is mapped to this identity, will change over time. ")],
        search_entity: Annotated[EntityObject, Field(description="An entity object with the parameters you wish to search on. ")],
        x_frankie_customer_child_id: Annotated[Optional[StrictStr], Field(description="If, as a Frankie Customer, you are acting on behalf of your own customers, then you can populate this field with a Frankie-assigned ID.  Note: If using a CustomerChildID, you will also need a separate api_key for each child.  Any documents, checks, entities that are created when this field has been populated will now be tied to this CustomerID + CustomerChildID combination. Just as Customers cannot see data created by other Customers, so too a Customer's Children will not be able to see each other's data.  A Customer can see the documents/entities and checks of all their Children. ")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[EntitySearchResultObject]:
        """Search for Entity

         Search for an existing entity that matches the criteria supplied  Criteria are supplied in the form of a populated entity object, with the name/address/DoB details supplied. You can also include documents that can be used to further refine your search (see the /document/search function for minimum requirements for a document search)  At an absolute minimum, you must supply one of the following combinations:    * name.familyName +   * name.givenNames      or      * name.familyName +   * one identityDocument object (that meets minimum criteria)    Obviously, the more data you provide, the better search results we can provide.  The service will return a list of matching entities with confidence levels.  If you are the \"owner\" of the entity - i.e. the same CustomerID and CustomerChildID (if relevant) - then the full details of the entity and any owned documents will be returned, except for the contents of any attached scans.  If you are not the owner of the entity (or linked documents), then just the ID and confidence level is returned. You can still use this ID to retrieve any check results (see GET  /entity/{entityId}/checks and GET /document/{documentId}/checks)  Note: This functionality must be enabled by Frankie administrators. Please contact your sales representative if you wish to discuss this. 

        :param x_frankie_customer_id: Customer ID issued by Frankie Financial. This will never change. Your API key, which is mapped to this identity, will change over time.  (required)
        :type x_frankie_customer_id: str
        :param search_entity: An entity object with the parameters you wish to search on.  (required)
        :type search_entity: EntityObject
        :param x_frankie_customer_child_id: If, as a Frankie Customer, you are acting on behalf of your own customers, then you can populate this field with a Frankie-assigned ID.  Note: If using a CustomerChildID, you will also need a separate api_key for each child.  Any documents, checks, entities that are created when this field has been populated will now be tied to this CustomerID + CustomerChildID combination. Just as Customers cannot see data created by other Customers, so too a Customer's Children will not be able to see each other's data.  A Customer can see the documents/entities and checks of all their Children. 
        :type x_frankie_customer_child_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._search_entity_serialize(
            x_frankie_customer_id=x_frankie_customer_id,
            search_entity=search_entity,
            x_frankie_customer_child_id=x_frankie_customer_child_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "EntitySearchResultObject",
            '400': "ErrorObject",
            '401': "ErrorObject",
            '404': "ErrorObject",
            '405': "ErrorObject",
            '422': "ErrorObject",
            '429': "ErrorObject",
            '500': "ErrorObject",
            '503': "ErrorObject",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def search_entity_without_preload_content(
        self,
        x_frankie_customer_id: Annotated[StrictStr, Field(description="Customer ID issued by Frankie Financial. This will never change. Your API key, which is mapped to this identity, will change over time. ")],
        search_entity: Annotated[EntityObject, Field(description="An entity object with the parameters you wish to search on. ")],
        x_frankie_customer_child_id: Annotated[Optional[StrictStr], Field(description="If, as a Frankie Customer, you are acting on behalf of your own customers, then you can populate this field with a Frankie-assigned ID.  Note: If using a CustomerChildID, you will also need a separate api_key for each child.  Any documents, checks, entities that are created when this field has been populated will now be tied to this CustomerID + CustomerChildID combination. Just as Customers cannot see data created by other Customers, so too a Customer's Children will not be able to see each other's data.  A Customer can see the documents/entities and checks of all their Children. ")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Search for Entity

         Search for an existing entity that matches the criteria supplied  Criteria are supplied in the form of a populated entity object, with the name/address/DoB details supplied. You can also include documents that can be used to further refine your search (see the /document/search function for minimum requirements for a document search)  At an absolute minimum, you must supply one of the following combinations:    * name.familyName +   * name.givenNames      or      * name.familyName +   * one identityDocument object (that meets minimum criteria)    Obviously, the more data you provide, the better search results we can provide.  The service will return a list of matching entities with confidence levels.  If you are the \"owner\" of the entity - i.e. the same CustomerID and CustomerChildID (if relevant) - then the full details of the entity and any owned documents will be returned, except for the contents of any attached scans.  If you are not the owner of the entity (or linked documents), then just the ID and confidence level is returned. You can still use this ID to retrieve any check results (see GET  /entity/{entityId}/checks and GET /document/{documentId}/checks)  Note: This functionality must be enabled by Frankie administrators. Please contact your sales representative if you wish to discuss this. 

        :param x_frankie_customer_id: Customer ID issued by Frankie Financial. This will never change. Your API key, which is mapped to this identity, will change over time.  (required)
        :type x_frankie_customer_id: str
        :param search_entity: An entity object with the parameters you wish to search on.  (required)
        :type search_entity: EntityObject
        :param x_frankie_customer_child_id: If, as a Frankie Customer, you are acting on behalf of your own customers, then you can populate this field with a Frankie-assigned ID.  Note: If using a CustomerChildID, you will also need a separate api_key for each child.  Any documents, checks, entities that are created when this field has been populated will now be tied to this CustomerID + CustomerChildID combination. Just as Customers cannot see data created by other Customers, so too a Customer's Children will not be able to see each other's data.  A Customer can see the documents/entities and checks of all their Children. 
        :type x_frankie_customer_child_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._search_entity_serialize(
            x_frankie_customer_id=x_frankie_customer_id,
            search_entity=search_entity,
            x_frankie_customer_child_id=x_frankie_customer_child_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "EntitySearchResultObject",
            '400': "ErrorObject",
            '401': "ErrorObject",
            '404': "ErrorObject",
            '405': "ErrorObject",
            '422': "ErrorObject",
            '429': "ErrorObject",
            '500': "ErrorObject",
            '503': "ErrorObject",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _search_entity_serialize(
        self,
        x_frankie_customer_id,
        search_entity,
        x_frankie_customer_child_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        if x_frankie_customer_id is not None:
            _header_params['X-Frankie-CustomerID'] = x_frankie_customer_id
        if x_frankie_customer_child_id is not None:
            _header_params['X-Frankie-CustomerChildID'] = x_frankie_customer_child_id
        # process the form parameters
        # process the body parameter
        if search_entity is not None:
            _body_params = search_entity


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'api_key'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/entity/search',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def update_check_class_result(
        self,
        x_frankie_customer_id: Annotated[StrictStr, Field(description="Customer ID issued by Frankie Financial. This will never change. Your API key, which is mapped to this identity, will change over time. ")],
        entity_id: Annotated[StrictStr, Field(description="The entityId returned previously from an earlier call to /check or /entity")],
        check_id: Annotated[StrictStr, Field(description="The checkId returned previously from an earlier call to */verify")],
        check_class: Annotated[StrictStr, Field(description="Specify which check Class this action will apply to (PRO, BCRO etc.). Valid values are:   - \"pro\": Update a Process Result Object   - \"bcro\": Update a Background Check Result Object. The class IDs in the request must be the IDs from Background Check Result Object Containers.   - \"fraudlist\": Update a fraud list Process Result Object. The class IDs in the request must be check sources from fraudlist Process Result Objects. ")],
        check_class_id: Annotated[StrictStr, Field(description="A PRO/BCRO ID ")],
        status: Annotated[StrictStr, Field(description="Set the new status of the Check Class (PRO/BCRO). Valid values are:   - \"unknown\"   - \"true_positive\"   - \"true_positive_accept\"   - \"true_positive_reject\"   - \"false_positive\"   - \"stale\" ")],
        x_frankie_customer_child_id: Annotated[Optional[StrictStr], Field(description="If, as a Frankie Customer, you are acting on behalf of your own customers, then you can populate this field with a Frankie-assigned ID.  Note: If using a CustomerChildID, you will also need a separate api_key for each child.  Any documents, checks, entities that are created when this field has been populated will now be tied to this CustomerID + CustomerChildID combination. Just as Customers cannot see data created by other Customers, so too a Customer's Children will not be able to see each other's data.  A Customer can see the documents/entities and checks of all their Children. ")] = None,
        undo: Annotated[Optional[StrictBool], Field(description="Undo a prior operation. ")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> CheckEntityCheckResultObject:
        """Update Check Result State

        Internal only  Update a given KYC or AML check result status in order to force a re-evaluation of the overall check result. 

        :param x_frankie_customer_id: Customer ID issued by Frankie Financial. This will never change. Your API key, which is mapped to this identity, will change over time.  (required)
        :type x_frankie_customer_id: str
        :param entity_id: The entityId returned previously from an earlier call to /check or /entity (required)
        :type entity_id: str
        :param check_id: The checkId returned previously from an earlier call to */verify (required)
        :type check_id: str
        :param check_class: Specify which check Class this action will apply to (PRO, BCRO etc.). Valid values are:   - \"pro\": Update a Process Result Object   - \"bcro\": Update a Background Check Result Object. The class IDs in the request must be the IDs from Background Check Result Object Containers.   - \"fraudlist\": Update a fraud list Process Result Object. The class IDs in the request must be check sources from fraudlist Process Result Objects.  (required)
        :type check_class: str
        :param check_class_id: A PRO/BCRO ID  (required)
        :type check_class_id: str
        :param status: Set the new status of the Check Class (PRO/BCRO). Valid values are:   - \"unknown\"   - \"true_positive\"   - \"true_positive_accept\"   - \"true_positive_reject\"   - \"false_positive\"   - \"stale\"  (required)
        :type status: str
        :param x_frankie_customer_child_id: If, as a Frankie Customer, you are acting on behalf of your own customers, then you can populate this field with a Frankie-assigned ID.  Note: If using a CustomerChildID, you will also need a separate api_key for each child.  Any documents, checks, entities that are created when this field has been populated will now be tied to this CustomerID + CustomerChildID combination. Just as Customers cannot see data created by other Customers, so too a Customer's Children will not be able to see each other's data.  A Customer can see the documents/entities and checks of all their Children. 
        :type x_frankie_customer_child_id: str
        :param undo: Undo a prior operation. 
        :type undo: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_check_class_result_serialize(
            x_frankie_customer_id=x_frankie_customer_id,
            entity_id=entity_id,
            check_id=check_id,
            check_class=check_class,
            check_class_id=check_class_id,
            status=status,
            x_frankie_customer_child_id=x_frankie_customer_child_id,
            undo=undo,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CheckEntityCheckResultObject",
            '400': "ErrorObject",
            '401': "ErrorObject",
            '404': "ErrorObject",
            '405': "ErrorObject",
            '422': "ErrorObject",
            '429': "ErrorObject",
            '500': "ErrorObject",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def update_check_class_result_with_http_info(
        self,
        x_frankie_customer_id: Annotated[StrictStr, Field(description="Customer ID issued by Frankie Financial. This will never change. Your API key, which is mapped to this identity, will change over time. ")],
        entity_id: Annotated[StrictStr, Field(description="The entityId returned previously from an earlier call to /check or /entity")],
        check_id: Annotated[StrictStr, Field(description="The checkId returned previously from an earlier call to */verify")],
        check_class: Annotated[StrictStr, Field(description="Specify which check Class this action will apply to (PRO, BCRO etc.). Valid values are:   - \"pro\": Update a Process Result Object   - \"bcro\": Update a Background Check Result Object. The class IDs in the request must be the IDs from Background Check Result Object Containers.   - \"fraudlist\": Update a fraud list Process Result Object. The class IDs in the request must be check sources from fraudlist Process Result Objects. ")],
        check_class_id: Annotated[StrictStr, Field(description="A PRO/BCRO ID ")],
        status: Annotated[StrictStr, Field(description="Set the new status of the Check Class (PRO/BCRO). Valid values are:   - \"unknown\"   - \"true_positive\"   - \"true_positive_accept\"   - \"true_positive_reject\"   - \"false_positive\"   - \"stale\" ")],
        x_frankie_customer_child_id: Annotated[Optional[StrictStr], Field(description="If, as a Frankie Customer, you are acting on behalf of your own customers, then you can populate this field with a Frankie-assigned ID.  Note: If using a CustomerChildID, you will also need a separate api_key for each child.  Any documents, checks, entities that are created when this field has been populated will now be tied to this CustomerID + CustomerChildID combination. Just as Customers cannot see data created by other Customers, so too a Customer's Children will not be able to see each other's data.  A Customer can see the documents/entities and checks of all their Children. ")] = None,
        undo: Annotated[Optional[StrictBool], Field(description="Undo a prior operation. ")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[CheckEntityCheckResultObject]:
        """Update Check Result State

        Internal only  Update a given KYC or AML check result status in order to force a re-evaluation of the overall check result. 

        :param x_frankie_customer_id: Customer ID issued by Frankie Financial. This will never change. Your API key, which is mapped to this identity, will change over time.  (required)
        :type x_frankie_customer_id: str
        :param entity_id: The entityId returned previously from an earlier call to /check or /entity (required)
        :type entity_id: str
        :param check_id: The checkId returned previously from an earlier call to */verify (required)
        :type check_id: str
        :param check_class: Specify which check Class this action will apply to (PRO, BCRO etc.). Valid values are:   - \"pro\": Update a Process Result Object   - \"bcro\": Update a Background Check Result Object. The class IDs in the request must be the IDs from Background Check Result Object Containers.   - \"fraudlist\": Update a fraud list Process Result Object. The class IDs in the request must be check sources from fraudlist Process Result Objects.  (required)
        :type check_class: str
        :param check_class_id: A PRO/BCRO ID  (required)
        :type check_class_id: str
        :param status: Set the new status of the Check Class (PRO/BCRO). Valid values are:   - \"unknown\"   - \"true_positive\"   - \"true_positive_accept\"   - \"true_positive_reject\"   - \"false_positive\"   - \"stale\"  (required)
        :type status: str
        :param x_frankie_customer_child_id: If, as a Frankie Customer, you are acting on behalf of your own customers, then you can populate this field with a Frankie-assigned ID.  Note: If using a CustomerChildID, you will also need a separate api_key for each child.  Any documents, checks, entities that are created when this field has been populated will now be tied to this CustomerID + CustomerChildID combination. Just as Customers cannot see data created by other Customers, so too a Customer's Children will not be able to see each other's data.  A Customer can see the documents/entities and checks of all their Children. 
        :type x_frankie_customer_child_id: str
        :param undo: Undo a prior operation. 
        :type undo: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_check_class_result_serialize(
            x_frankie_customer_id=x_frankie_customer_id,
            entity_id=entity_id,
            check_id=check_id,
            check_class=check_class,
            check_class_id=check_class_id,
            status=status,
            x_frankie_customer_child_id=x_frankie_customer_child_id,
            undo=undo,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CheckEntityCheckResultObject",
            '400': "ErrorObject",
            '401': "ErrorObject",
            '404': "ErrorObject",
            '405': "ErrorObject",
            '422': "ErrorObject",
            '429': "ErrorObject",
            '500': "ErrorObject",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def update_check_class_result_without_preload_content(
        self,
        x_frankie_customer_id: Annotated[StrictStr, Field(description="Customer ID issued by Frankie Financial. This will never change. Your API key, which is mapped to this identity, will change over time. ")],
        entity_id: Annotated[StrictStr, Field(description="The entityId returned previously from an earlier call to /check or /entity")],
        check_id: Annotated[StrictStr, Field(description="The checkId returned previously from an earlier call to */verify")],
        check_class: Annotated[StrictStr, Field(description="Specify which check Class this action will apply to (PRO, BCRO etc.). Valid values are:   - \"pro\": Update a Process Result Object   - \"bcro\": Update a Background Check Result Object. The class IDs in the request must be the IDs from Background Check Result Object Containers.   - \"fraudlist\": Update a fraud list Process Result Object. The class IDs in the request must be check sources from fraudlist Process Result Objects. ")],
        check_class_id: Annotated[StrictStr, Field(description="A PRO/BCRO ID ")],
        status: Annotated[StrictStr, Field(description="Set the new status of the Check Class (PRO/BCRO). Valid values are:   - \"unknown\"   - \"true_positive\"   - \"true_positive_accept\"   - \"true_positive_reject\"   - \"false_positive\"   - \"stale\" ")],
        x_frankie_customer_child_id: Annotated[Optional[StrictStr], Field(description="If, as a Frankie Customer, you are acting on behalf of your own customers, then you can populate this field with a Frankie-assigned ID.  Note: If using a CustomerChildID, you will also need a separate api_key for each child.  Any documents, checks, entities that are created when this field has been populated will now be tied to this CustomerID + CustomerChildID combination. Just as Customers cannot see data created by other Customers, so too a Customer's Children will not be able to see each other's data.  A Customer can see the documents/entities and checks of all their Children. ")] = None,
        undo: Annotated[Optional[StrictBool], Field(description="Undo a prior operation. ")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Update Check Result State

        Internal only  Update a given KYC or AML check result status in order to force a re-evaluation of the overall check result. 

        :param x_frankie_customer_id: Customer ID issued by Frankie Financial. This will never change. Your API key, which is mapped to this identity, will change over time.  (required)
        :type x_frankie_customer_id: str
        :param entity_id: The entityId returned previously from an earlier call to /check or /entity (required)
        :type entity_id: str
        :param check_id: The checkId returned previously from an earlier call to */verify (required)
        :type check_id: str
        :param check_class: Specify which check Class this action will apply to (PRO, BCRO etc.). Valid values are:   - \"pro\": Update a Process Result Object   - \"bcro\": Update a Background Check Result Object. The class IDs in the request must be the IDs from Background Check Result Object Containers.   - \"fraudlist\": Update a fraud list Process Result Object. The class IDs in the request must be check sources from fraudlist Process Result Objects.  (required)
        :type check_class: str
        :param check_class_id: A PRO/BCRO ID  (required)
        :type check_class_id: str
        :param status: Set the new status of the Check Class (PRO/BCRO). Valid values are:   - \"unknown\"   - \"true_positive\"   - \"true_positive_accept\"   - \"true_positive_reject\"   - \"false_positive\"   - \"stale\"  (required)
        :type status: str
        :param x_frankie_customer_child_id: If, as a Frankie Customer, you are acting on behalf of your own customers, then you can populate this field with a Frankie-assigned ID.  Note: If using a CustomerChildID, you will also need a separate api_key for each child.  Any documents, checks, entities that are created when this field has been populated will now be tied to this CustomerID + CustomerChildID combination. Just as Customers cannot see data created by other Customers, so too a Customer's Children will not be able to see each other's data.  A Customer can see the documents/entities and checks of all their Children. 
        :type x_frankie_customer_child_id: str
        :param undo: Undo a prior operation. 
        :type undo: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_check_class_result_serialize(
            x_frankie_customer_id=x_frankie_customer_id,
            entity_id=entity_id,
            check_id=check_id,
            check_class=check_class,
            check_class_id=check_class_id,
            status=status,
            x_frankie_customer_child_id=x_frankie_customer_child_id,
            undo=undo,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CheckEntityCheckResultObject",
            '400': "ErrorObject",
            '401': "ErrorObject",
            '404': "ErrorObject",
            '405': "ErrorObject",
            '422': "ErrorObject",
            '429': "ErrorObject",
            '500': "ErrorObject",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _update_check_class_result_serialize(
        self,
        x_frankie_customer_id,
        entity_id,
        check_id,
        check_class,
        check_class_id,
        status,
        x_frankie_customer_child_id,
        undo,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if entity_id is not None:
            _path_params['entityId'] = entity_id
        if check_id is not None:
            _path_params['checkId'] = check_id
        if check_class is not None:
            _path_params['checkClass'] = check_class
        if check_class_id is not None:
            _path_params['checkClassId'] = check_class_id
        # process the query parameters
        if status is not None:
            
            _query_params.append(('status', status))
            
        if undo is not None:
            
            _query_params.append(('undo', undo))
            
        # process the header parameters
        if x_frankie_customer_id is not None:
            _header_params['X-Frankie-CustomerID'] = x_frankie_customer_id
        if x_frankie_customer_child_id is not None:
            _header_params['X-Frankie-CustomerChildID'] = x_frankie_customer_child_id
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'api_key'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/entity/{entityId}/check/{checkId}/{checkClass}/{checkClassId}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def update_check_class_results(
        self,
        x_frankie_customer_id: Annotated[StrictStr, Field(description="Customer ID issued by Frankie Financial. This will never change. Your API key, which is mapped to this identity, will change over time. ")],
        entity_id: Annotated[StrictStr, Field(description="The entityId returned previously from an earlier call to /check or /entity")],
        check_id: Annotated[StrictStr, Field(description="The checkId returned previously from an earlier call to */verify")],
        check_class: Annotated[StrictStr, Field(description="Specify which check Class this action will apply to (PRO, BCRO etc.). Valid values are:   - \"pro\": Update a Process Result Object   - \"bcro\": Update a Background Check Result Object. The class IDs in the request must be the IDs from Background Check Result Object Containers.   - \"fraudlist\": Update a fraud list Process Result Object. The class IDs in the request must be check sources from fraudlist Process Result Objects. ")],
        check_result_update: Annotated[CheckResultUpdateObject, Field(description="The check result status change details to apply")],
        x_frankie_customer_child_id: Annotated[Optional[StrictStr], Field(description="If, as a Frankie Customer, you are acting on behalf of your own customers, then you can populate this field with a Frankie-assigned ID.  Note: If using a CustomerChildID, you will also need a separate api_key for each child.  Any documents, checks, entities that are created when this field has been populated will now be tied to this CustomerID + CustomerChildID combination. Just as Customers cannot see data created by other Customers, so too a Customer's Children will not be able to see each other's data.  A Customer can see the documents/entities and checks of all their Children. ")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> CheckEntityCheckResultObject:
        """Update Check Result States (Batch)

        Internal only  Update a given set of KYC and/or AML check result statuses in order to force a re-evaluation of the overall check result. 

        :param x_frankie_customer_id: Customer ID issued by Frankie Financial. This will never change. Your API key, which is mapped to this identity, will change over time.  (required)
        :type x_frankie_customer_id: str
        :param entity_id: The entityId returned previously from an earlier call to /check or /entity (required)
        :type entity_id: str
        :param check_id: The checkId returned previously from an earlier call to */verify (required)
        :type check_id: str
        :param check_class: Specify which check Class this action will apply to (PRO, BCRO etc.). Valid values are:   - \"pro\": Update a Process Result Object   - \"bcro\": Update a Background Check Result Object. The class IDs in the request must be the IDs from Background Check Result Object Containers.   - \"fraudlist\": Update a fraud list Process Result Object. The class IDs in the request must be check sources from fraudlist Process Result Objects.  (required)
        :type check_class: str
        :param check_result_update: The check result status change details to apply (required)
        :type check_result_update: CheckResultUpdateObject
        :param x_frankie_customer_child_id: If, as a Frankie Customer, you are acting on behalf of your own customers, then you can populate this field with a Frankie-assigned ID.  Note: If using a CustomerChildID, you will also need a separate api_key for each child.  Any documents, checks, entities that are created when this field has been populated will now be tied to this CustomerID + CustomerChildID combination. Just as Customers cannot see data created by other Customers, so too a Customer's Children will not be able to see each other's data.  A Customer can see the documents/entities and checks of all their Children. 
        :type x_frankie_customer_child_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_check_class_results_serialize(
            x_frankie_customer_id=x_frankie_customer_id,
            entity_id=entity_id,
            check_id=check_id,
            check_class=check_class,
            check_result_update=check_result_update,
            x_frankie_customer_child_id=x_frankie_customer_child_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CheckEntityCheckResultObject",
            '400': "ErrorObject",
            '401': "ErrorObject",
            '404': "ErrorObject",
            '405': "ErrorObject",
            '422': "ErrorObject",
            '429': "ErrorObject",
            '500': "ErrorObject",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def update_check_class_results_with_http_info(
        self,
        x_frankie_customer_id: Annotated[StrictStr, Field(description="Customer ID issued by Frankie Financial. This will never change. Your API key, which is mapped to this identity, will change over time. ")],
        entity_id: Annotated[StrictStr, Field(description="The entityId returned previously from an earlier call to /check or /entity")],
        check_id: Annotated[StrictStr, Field(description="The checkId returned previously from an earlier call to */verify")],
        check_class: Annotated[StrictStr, Field(description="Specify which check Class this action will apply to (PRO, BCRO etc.). Valid values are:   - \"pro\": Update a Process Result Object   - \"bcro\": Update a Background Check Result Object. The class IDs in the request must be the IDs from Background Check Result Object Containers.   - \"fraudlist\": Update a fraud list Process Result Object. The class IDs in the request must be check sources from fraudlist Process Result Objects. ")],
        check_result_update: Annotated[CheckResultUpdateObject, Field(description="The check result status change details to apply")],
        x_frankie_customer_child_id: Annotated[Optional[StrictStr], Field(description="If, as a Frankie Customer, you are acting on behalf of your own customers, then you can populate this field with a Frankie-assigned ID.  Note: If using a CustomerChildID, you will also need a separate api_key for each child.  Any documents, checks, entities that are created when this field has been populated will now be tied to this CustomerID + CustomerChildID combination. Just as Customers cannot see data created by other Customers, so too a Customer's Children will not be able to see each other's data.  A Customer can see the documents/entities and checks of all their Children. ")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[CheckEntityCheckResultObject]:
        """Update Check Result States (Batch)

        Internal only  Update a given set of KYC and/or AML check result statuses in order to force a re-evaluation of the overall check result. 

        :param x_frankie_customer_id: Customer ID issued by Frankie Financial. This will never change. Your API key, which is mapped to this identity, will change over time.  (required)
        :type x_frankie_customer_id: str
        :param entity_id: The entityId returned previously from an earlier call to /check or /entity (required)
        :type entity_id: str
        :param check_id: The checkId returned previously from an earlier call to */verify (required)
        :type check_id: str
        :param check_class: Specify which check Class this action will apply to (PRO, BCRO etc.). Valid values are:   - \"pro\": Update a Process Result Object   - \"bcro\": Update a Background Check Result Object. The class IDs in the request must be the IDs from Background Check Result Object Containers.   - \"fraudlist\": Update a fraud list Process Result Object. The class IDs in the request must be check sources from fraudlist Process Result Objects.  (required)
        :type check_class: str
        :param check_result_update: The check result status change details to apply (required)
        :type check_result_update: CheckResultUpdateObject
        :param x_frankie_customer_child_id: If, as a Frankie Customer, you are acting on behalf of your own customers, then you can populate this field with a Frankie-assigned ID.  Note: If using a CustomerChildID, you will also need a separate api_key for each child.  Any documents, checks, entities that are created when this field has been populated will now be tied to this CustomerID + CustomerChildID combination. Just as Customers cannot see data created by other Customers, so too a Customer's Children will not be able to see each other's data.  A Customer can see the documents/entities and checks of all their Children. 
        :type x_frankie_customer_child_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_check_class_results_serialize(
            x_frankie_customer_id=x_frankie_customer_id,
            entity_id=entity_id,
            check_id=check_id,
            check_class=check_class,
            check_result_update=check_result_update,
            x_frankie_customer_child_id=x_frankie_customer_child_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CheckEntityCheckResultObject",
            '400': "ErrorObject",
            '401': "ErrorObject",
            '404': "ErrorObject",
            '405': "ErrorObject",
            '422': "ErrorObject",
            '429': "ErrorObject",
            '500': "ErrorObject",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def update_check_class_results_without_preload_content(
        self,
        x_frankie_customer_id: Annotated[StrictStr, Field(description="Customer ID issued by Frankie Financial. This will never change. Your API key, which is mapped to this identity, will change over time. ")],
        entity_id: Annotated[StrictStr, Field(description="The entityId returned previously from an earlier call to /check or /entity")],
        check_id: Annotated[StrictStr, Field(description="The checkId returned previously from an earlier call to */verify")],
        check_class: Annotated[StrictStr, Field(description="Specify which check Class this action will apply to (PRO, BCRO etc.). Valid values are:   - \"pro\": Update a Process Result Object   - \"bcro\": Update a Background Check Result Object. The class IDs in the request must be the IDs from Background Check Result Object Containers.   - \"fraudlist\": Update a fraud list Process Result Object. The class IDs in the request must be check sources from fraudlist Process Result Objects. ")],
        check_result_update: Annotated[CheckResultUpdateObject, Field(description="The check result status change details to apply")],
        x_frankie_customer_child_id: Annotated[Optional[StrictStr], Field(description="If, as a Frankie Customer, you are acting on behalf of your own customers, then you can populate this field with a Frankie-assigned ID.  Note: If using a CustomerChildID, you will also need a separate api_key for each child.  Any documents, checks, entities that are created when this field has been populated will now be tied to this CustomerID + CustomerChildID combination. Just as Customers cannot see data created by other Customers, so too a Customer's Children will not be able to see each other's data.  A Customer can see the documents/entities and checks of all their Children. ")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Update Check Result States (Batch)

        Internal only  Update a given set of KYC and/or AML check result statuses in order to force a re-evaluation of the overall check result. 

        :param x_frankie_customer_id: Customer ID issued by Frankie Financial. This will never change. Your API key, which is mapped to this identity, will change over time.  (required)
        :type x_frankie_customer_id: str
        :param entity_id: The entityId returned previously from an earlier call to /check or /entity (required)
        :type entity_id: str
        :param check_id: The checkId returned previously from an earlier call to */verify (required)
        :type check_id: str
        :param check_class: Specify which check Class this action will apply to (PRO, BCRO etc.). Valid values are:   - \"pro\": Update a Process Result Object   - \"bcro\": Update a Background Check Result Object. The class IDs in the request must be the IDs from Background Check Result Object Containers.   - \"fraudlist\": Update a fraud list Process Result Object. The class IDs in the request must be check sources from fraudlist Process Result Objects.  (required)
        :type check_class: str
        :param check_result_update: The check result status change details to apply (required)
        :type check_result_update: CheckResultUpdateObject
        :param x_frankie_customer_child_id: If, as a Frankie Customer, you are acting on behalf of your own customers, then you can populate this field with a Frankie-assigned ID.  Note: If using a CustomerChildID, you will also need a separate api_key for each child.  Any documents, checks, entities that are created when this field has been populated will now be tied to this CustomerID + CustomerChildID combination. Just as Customers cannot see data created by other Customers, so too a Customer's Children will not be able to see each other's data.  A Customer can see the documents/entities and checks of all their Children. 
        :type x_frankie_customer_child_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_check_class_results_serialize(
            x_frankie_customer_id=x_frankie_customer_id,
            entity_id=entity_id,
            check_id=check_id,
            check_class=check_class,
            check_result_update=check_result_update,
            x_frankie_customer_child_id=x_frankie_customer_child_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CheckEntityCheckResultObject",
            '400': "ErrorObject",
            '401': "ErrorObject",
            '404': "ErrorObject",
            '405': "ErrorObject",
            '422': "ErrorObject",
            '429': "ErrorObject",
            '500': "ErrorObject",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _update_check_class_results_serialize(
        self,
        x_frankie_customer_id,
        entity_id,
        check_id,
        check_class,
        check_result_update,
        x_frankie_customer_child_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if entity_id is not None:
            _path_params['entityId'] = entity_id
        if check_id is not None:
            _path_params['checkId'] = check_id
        if check_class is not None:
            _path_params['checkClass'] = check_class
        # process the query parameters
        # process the header parameters
        if x_frankie_customer_id is not None:
            _header_params['X-Frankie-CustomerID'] = x_frankie_customer_id
        if x_frankie_customer_child_id is not None:
            _header_params['X-Frankie-CustomerChildID'] = x_frankie_customer_child_id
        # process the form parameters
        # process the body parameter
        if check_result_update is not None:
            _body_params = check_result_update


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'api_key'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/entity/{entityId}/check/{checkId}/{checkClass}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def update_check_entity(
        self,
        x_frankie_customer_id: Annotated[StrictStr, Field(description="Customer ID issued by Frankie Financial. This will never change. Your API key, which is mapped to this identity, will change over time. ")],
        entity_id: Annotated[StrictStr, Field(description="The entityId returned previously from an earlier call to /check or /entity")],
        check_type: Annotated[StrictStr, Field(description="When creating a new check, you need to define the checks you wish to run.    The checkType is make up of a comma separated list of the types of check you wish to run. The order of the requested checks is not important, they will be re-ordered by the service and in some cases, depending on your account configuration, may be skipped.    The validation that is performed on the requested checks is to:   - ensure the check type is known   - is suitable for the type of entity (no KYC for organisations)   - disallow manual (mKYC) check with any other kind of KYC   - disallow mixing the \"profile\" check with any other kind of check.  The supported check types are:  Profile:   - \"profile\": By arrangement with Frankie we will create a \"profile\" check type that applies checks according to a recipe that you assign to the entity from a predefined set of profiles.      The profile to use will be taken from the entity.entityProfile field if set, or be run through a set of configurable rules to determine which one to use.      Profiles provide a pre-defined combination of individual checkTypes (see the list below). But they offer a lot more besides, including rules for determining default settings, inbuilt data aging and other configurable features.   They also allow for a new result set top be returned that provides a more detailed and useful breakdown of the check/verification process.      Entity Profiles are a recent feature (since v1.4.0) but are now the default checkType to use with Frankie Financial.  **Individual Check Types**  Whilst we strongly recommend the use of the \"profile\" checktype, it does map of any combination of the types below. If you wish to use these individually, please contact developer support for more details on how to use these effectively.  Entity Checks - One of:   - \"one_plus\": Checks name, address and DoB against a minimum of 1 data source. (also known as a 1+1)   - \"two_plus\": Checks name, address and DoB against a minimum of 2 independent data sources (also known as a 2+2)  ID Checks - One of:   - \"id\": Checks all of the identity documents, but not necessarily the entity itself independently. Use this in conjunction with a one_plus or two_plus for more.   - \"visa\":    ID Validate - One of:   - \"idvalidate\": Checks to see if photo ID has had OCR scanning, ID document validation and photo comparison run against it. Can be used in conjunction with any of the KYC/ID/AML checks.    Manual Check:   - \"manual\": (mKYC) Checks user has a sufficient amount of operator verified ID and will then \"pass\" all Entity and ID related checks.    Fraud Checks - One or more of:   - \"fraudlist\": Checks to see if the identity appears on any known fraud lists. Should be run after KYC/ID checks have passed.   - \"fraudcheck\": Checks external ID services to see if details appear in fraud detection services (e.g. EmailAge or FraudNet)    PEP Checks - One of:   - \"pep\": Will only run PEP/Sanctions checks (no identity verification)   - \"pep_media\": Will run PEP/Sanctions checks, as well as watchlist and adverse media checks. (no identity verification)      * NOTE: These checks will ONLY run if either the KYC/ID checks have been run prior, or it is the only check requested.    Custom:   - By arrangement with Frankie you can define your own KYC check type.      This will allow you to set the minimum number of matches for:     - name      - date of birth     - address     - government id      This allows for alternatives to the \"standard\" two_plus or one_plus (note, these can be overridden too). ")],
        result_level: Annotated[StrictStr, Field(description="How much detail we return.   Acceptable values are:   * simple - Only available with \"profile\" check type. Returns just an EntityProfileResultObject (which is also included for \"profile\" checks at the other result levels), and a CheckEntityCheckResultObjectEntityResult with just the entity details but no separate results.   * summary   * full - You need to have your account configured for this. ")],
        entity_details: Annotated[EntityCheckDetailsObject, Field(description="The entity to be checked")],
        x_frankie_customer_child_id: Annotated[Optional[StrictStr], Field(description="If, as a Frankie Customer, you are acting on behalf of your own customers, then you can populate this field with a Frankie-assigned ID.  Note: If using a CustomerChildID, you will also need a separate api_key for each child.  Any documents, checks, entities that are created when this field has been populated will now be tied to this CustomerID + CustomerChildID combination. Just as Customers cannot see data created by other Customers, so too a Customer's Children will not be able to see each other's data.  A Customer can see the documents/entities and checks of all their Children. ")] = None,
        x_frankie_background: Annotated[Optional[Annotated[int, Field(le=1, strict=True, ge=0)]], Field(description="If this header parameter is supplied and set to 1, then the request will not wait for the process to finish, and will return a 202 if there are no obvious errors in the input. The request will then run in the background and send a notification back to the customer. See out callback API for details on this.  See more details here:   https://apidocs.frankiefinancial.com/docs/asynchronous-calls-backgrounding-processes ")] = None,
        force: Annotated[Optional[StrictBool], Field(description="Force the verification to run, overriding any data aging or past check ")] = None,
        no_invalidate: Annotated[Optional[StrictBool], Field(description="Disable check result invalidation for this update request. ")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> CheckEntityCheckResultObject:
        """Update Entity and Verify Details

        Take the details and documents provided in the entity, and set about verifying them all. So for example, you might extract:  * The name from the entity.name object * The address from the entity.address object * The DoB..  All documents that are presently attached to the entity will also be verified (if requested)  You can also specify the level of detail returned using the resultLevel parameter. You can choose \"summary\" or \"full\". For the \"profile\" check type you can also select \"simple\" to only get the entity profile result.  SPECIAL NOTE: A \"Full\" response includes details of all checks and how they map against each element, along with all the details of pep/sanctions/etc checks too.  Your account also needs to be configured to support a full response too (talk to your account manager for more information). If you're not configured for full responses, we'll only return summary level data regardless. 

        :param x_frankie_customer_id: Customer ID issued by Frankie Financial. This will never change. Your API key, which is mapped to this identity, will change over time.  (required)
        :type x_frankie_customer_id: str
        :param entity_id: The entityId returned previously from an earlier call to /check or /entity (required)
        :type entity_id: str
        :param check_type: When creating a new check, you need to define the checks you wish to run.    The checkType is make up of a comma separated list of the types of check you wish to run. The order of the requested checks is not important, they will be re-ordered by the service and in some cases, depending on your account configuration, may be skipped.    The validation that is performed on the requested checks is to:   - ensure the check type is known   - is suitable for the type of entity (no KYC for organisations)   - disallow manual (mKYC) check with any other kind of KYC   - disallow mixing the \"profile\" check with any other kind of check.  The supported check types are:  Profile:   - \"profile\": By arrangement with Frankie we will create a \"profile\" check type that applies checks according to a recipe that you assign to the entity from a predefined set of profiles.      The profile to use will be taken from the entity.entityProfile field if set, or be run through a set of configurable rules to determine which one to use.      Profiles provide a pre-defined combination of individual checkTypes (see the list below). But they offer a lot more besides, including rules for determining default settings, inbuilt data aging and other configurable features.   They also allow for a new result set top be returned that provides a more detailed and useful breakdown of the check/verification process.      Entity Profiles are a recent feature (since v1.4.0) but are now the default checkType to use with Frankie Financial.  **Individual Check Types**  Whilst we strongly recommend the use of the \"profile\" checktype, it does map of any combination of the types below. If you wish to use these individually, please contact developer support for more details on how to use these effectively.  Entity Checks - One of:   - \"one_plus\": Checks name, address and DoB against a minimum of 1 data source. (also known as a 1+1)   - \"two_plus\": Checks name, address and DoB against a minimum of 2 independent data sources (also known as a 2+2)  ID Checks - One of:   - \"id\": Checks all of the identity documents, but not necessarily the entity itself independently. Use this in conjunction with a one_plus or two_plus for more.   - \"visa\":    ID Validate - One of:   - \"idvalidate\": Checks to see if photo ID has had OCR scanning, ID document validation and photo comparison run against it. Can be used in conjunction with any of the KYC/ID/AML checks.    Manual Check:   - \"manual\": (mKYC) Checks user has a sufficient amount of operator verified ID and will then \"pass\" all Entity and ID related checks.    Fraud Checks - One or more of:   - \"fraudlist\": Checks to see if the identity appears on any known fraud lists. Should be run after KYC/ID checks have passed.   - \"fraudcheck\": Checks external ID services to see if details appear in fraud detection services (e.g. EmailAge or FraudNet)    PEP Checks - One of:   - \"pep\": Will only run PEP/Sanctions checks (no identity verification)   - \"pep_media\": Will run PEP/Sanctions checks, as well as watchlist and adverse media checks. (no identity verification)      * NOTE: These checks will ONLY run if either the KYC/ID checks have been run prior, or it is the only check requested.    Custom:   - By arrangement with Frankie you can define your own KYC check type.      This will allow you to set the minimum number of matches for:     - name      - date of birth     - address     - government id      This allows for alternatives to the \"standard\" two_plus or one_plus (note, these can be overridden too).  (required)
        :type check_type: str
        :param result_level: How much detail we return.   Acceptable values are:   * simple - Only available with \"profile\" check type. Returns just an EntityProfileResultObject (which is also included for \"profile\" checks at the other result levels), and a CheckEntityCheckResultObjectEntityResult with just the entity details but no separate results.   * summary   * full - You need to have your account configured for this.  (required)
        :type result_level: str
        :param entity_details: The entity to be checked (required)
        :type entity_details: EntityCheckDetailsObject
        :param x_frankie_customer_child_id: If, as a Frankie Customer, you are acting on behalf of your own customers, then you can populate this field with a Frankie-assigned ID.  Note: If using a CustomerChildID, you will also need a separate api_key for each child.  Any documents, checks, entities that are created when this field has been populated will now be tied to this CustomerID + CustomerChildID combination. Just as Customers cannot see data created by other Customers, so too a Customer's Children will not be able to see each other's data.  A Customer can see the documents/entities and checks of all their Children. 
        :type x_frankie_customer_child_id: str
        :param x_frankie_background: If this header parameter is supplied and set to 1, then the request will not wait for the process to finish, and will return a 202 if there are no obvious errors in the input. The request will then run in the background and send a notification back to the customer. See out callback API for details on this.  See more details here:   https://apidocs.frankiefinancial.com/docs/asynchronous-calls-backgrounding-processes 
        :type x_frankie_background: int
        :param force: Force the verification to run, overriding any data aging or past check 
        :type force: bool
        :param no_invalidate: Disable check result invalidation for this update request. 
        :type no_invalidate: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_check_entity_serialize(
            x_frankie_customer_id=x_frankie_customer_id,
            entity_id=entity_id,
            check_type=check_type,
            result_level=result_level,
            entity_details=entity_details,
            x_frankie_customer_child_id=x_frankie_customer_child_id,
            x_frankie_background=x_frankie_background,
            force=force,
            no_invalidate=no_invalidate,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CheckEntityCheckResultObject",
            '202': "AcceptedEntityResultObject",
            '400': "ErrorObject",
            '401': "ErrorObject",
            '404': "ErrorObject",
            '405': "ErrorObject",
            '415': "ErrorObject",
            '422': "ErrorObject",
            '429': "ErrorObject",
            '500': "ErrorObject",
            '503': "ErrorObject",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def update_check_entity_with_http_info(
        self,
        x_frankie_customer_id: Annotated[StrictStr, Field(description="Customer ID issued by Frankie Financial. This will never change. Your API key, which is mapped to this identity, will change over time. ")],
        entity_id: Annotated[StrictStr, Field(description="The entityId returned previously from an earlier call to /check or /entity")],
        check_type: Annotated[StrictStr, Field(description="When creating a new check, you need to define the checks you wish to run.    The checkType is make up of a comma separated list of the types of check you wish to run. The order of the requested checks is not important, they will be re-ordered by the service and in some cases, depending on your account configuration, may be skipped.    The validation that is performed on the requested checks is to:   - ensure the check type is known   - is suitable for the type of entity (no KYC for organisations)   - disallow manual (mKYC) check with any other kind of KYC   - disallow mixing the \"profile\" check with any other kind of check.  The supported check types are:  Profile:   - \"profile\": By arrangement with Frankie we will create a \"profile\" check type that applies checks according to a recipe that you assign to the entity from a predefined set of profiles.      The profile to use will be taken from the entity.entityProfile field if set, or be run through a set of configurable rules to determine which one to use.      Profiles provide a pre-defined combination of individual checkTypes (see the list below). But they offer a lot more besides, including rules for determining default settings, inbuilt data aging and other configurable features.   They also allow for a new result set top be returned that provides a more detailed and useful breakdown of the check/verification process.      Entity Profiles are a recent feature (since v1.4.0) but are now the default checkType to use with Frankie Financial.  **Individual Check Types**  Whilst we strongly recommend the use of the \"profile\" checktype, it does map of any combination of the types below. If you wish to use these individually, please contact developer support for more details on how to use these effectively.  Entity Checks - One of:   - \"one_plus\": Checks name, address and DoB against a minimum of 1 data source. (also known as a 1+1)   - \"two_plus\": Checks name, address and DoB against a minimum of 2 independent data sources (also known as a 2+2)  ID Checks - One of:   - \"id\": Checks all of the identity documents, but not necessarily the entity itself independently. Use this in conjunction with a one_plus or two_plus for more.   - \"visa\":    ID Validate - One of:   - \"idvalidate\": Checks to see if photo ID has had OCR scanning, ID document validation and photo comparison run against it. Can be used in conjunction with any of the KYC/ID/AML checks.    Manual Check:   - \"manual\": (mKYC) Checks user has a sufficient amount of operator verified ID and will then \"pass\" all Entity and ID related checks.    Fraud Checks - One or more of:   - \"fraudlist\": Checks to see if the identity appears on any known fraud lists. Should be run after KYC/ID checks have passed.   - \"fraudcheck\": Checks external ID services to see if details appear in fraud detection services (e.g. EmailAge or FraudNet)    PEP Checks - One of:   - \"pep\": Will only run PEP/Sanctions checks (no identity verification)   - \"pep_media\": Will run PEP/Sanctions checks, as well as watchlist and adverse media checks. (no identity verification)      * NOTE: These checks will ONLY run if either the KYC/ID checks have been run prior, or it is the only check requested.    Custom:   - By arrangement with Frankie you can define your own KYC check type.      This will allow you to set the minimum number of matches for:     - name      - date of birth     - address     - government id      This allows for alternatives to the \"standard\" two_plus or one_plus (note, these can be overridden too). ")],
        result_level: Annotated[StrictStr, Field(description="How much detail we return.   Acceptable values are:   * simple - Only available with \"profile\" check type. Returns just an EntityProfileResultObject (which is also included for \"profile\" checks at the other result levels), and a CheckEntityCheckResultObjectEntityResult with just the entity details but no separate results.   * summary   * full - You need to have your account configured for this. ")],
        entity_details: Annotated[EntityCheckDetailsObject, Field(description="The entity to be checked")],
        x_frankie_customer_child_id: Annotated[Optional[StrictStr], Field(description="If, as a Frankie Customer, you are acting on behalf of your own customers, then you can populate this field with a Frankie-assigned ID.  Note: If using a CustomerChildID, you will also need a separate api_key for each child.  Any documents, checks, entities that are created when this field has been populated will now be tied to this CustomerID + CustomerChildID combination. Just as Customers cannot see data created by other Customers, so too a Customer's Children will not be able to see each other's data.  A Customer can see the documents/entities and checks of all their Children. ")] = None,
        x_frankie_background: Annotated[Optional[Annotated[int, Field(le=1, strict=True, ge=0)]], Field(description="If this header parameter is supplied and set to 1, then the request will not wait for the process to finish, and will return a 202 if there are no obvious errors in the input. The request will then run in the background and send a notification back to the customer. See out callback API for details on this.  See more details here:   https://apidocs.frankiefinancial.com/docs/asynchronous-calls-backgrounding-processes ")] = None,
        force: Annotated[Optional[StrictBool], Field(description="Force the verification to run, overriding any data aging or past check ")] = None,
        no_invalidate: Annotated[Optional[StrictBool], Field(description="Disable check result invalidation for this update request. ")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[CheckEntityCheckResultObject]:
        """Update Entity and Verify Details

        Take the details and documents provided in the entity, and set about verifying them all. So for example, you might extract:  * The name from the entity.name object * The address from the entity.address object * The DoB..  All documents that are presently attached to the entity will also be verified (if requested)  You can also specify the level of detail returned using the resultLevel parameter. You can choose \"summary\" or \"full\". For the \"profile\" check type you can also select \"simple\" to only get the entity profile result.  SPECIAL NOTE: A \"Full\" response includes details of all checks and how they map against each element, along with all the details of pep/sanctions/etc checks too.  Your account also needs to be configured to support a full response too (talk to your account manager for more information). If you're not configured for full responses, we'll only return summary level data regardless. 

        :param x_frankie_customer_id: Customer ID issued by Frankie Financial. This will never change. Your API key, which is mapped to this identity, will change over time.  (required)
        :type x_frankie_customer_id: str
        :param entity_id: The entityId returned previously from an earlier call to /check or /entity (required)
        :type entity_id: str
        :param check_type: When creating a new check, you need to define the checks you wish to run.    The checkType is make up of a comma separated list of the types of check you wish to run. The order of the requested checks is not important, they will be re-ordered by the service and in some cases, depending on your account configuration, may be skipped.    The validation that is performed on the requested checks is to:   - ensure the check type is known   - is suitable for the type of entity (no KYC for organisations)   - disallow manual (mKYC) check with any other kind of KYC   - disallow mixing the \"profile\" check with any other kind of check.  The supported check types are:  Profile:   - \"profile\": By arrangement with Frankie we will create a \"profile\" check type that applies checks according to a recipe that you assign to the entity from a predefined set of profiles.      The profile to use will be taken from the entity.entityProfile field if set, or be run through a set of configurable rules to determine which one to use.      Profiles provide a pre-defined combination of individual checkTypes (see the list below). But they offer a lot more besides, including rules for determining default settings, inbuilt data aging and other configurable features.   They also allow for a new result set top be returned that provides a more detailed and useful breakdown of the check/verification process.      Entity Profiles are a recent feature (since v1.4.0) but are now the default checkType to use with Frankie Financial.  **Individual Check Types**  Whilst we strongly recommend the use of the \"profile\" checktype, it does map of any combination of the types below. If you wish to use these individually, please contact developer support for more details on how to use these effectively.  Entity Checks - One of:   - \"one_plus\": Checks name, address and DoB against a minimum of 1 data source. (also known as a 1+1)   - \"two_plus\": Checks name, address and DoB against a minimum of 2 independent data sources (also known as a 2+2)  ID Checks - One of:   - \"id\": Checks all of the identity documents, but not necessarily the entity itself independently. Use this in conjunction with a one_plus or two_plus for more.   - \"visa\":    ID Validate - One of:   - \"idvalidate\": Checks to see if photo ID has had OCR scanning, ID document validation and photo comparison run against it. Can be used in conjunction with any of the KYC/ID/AML checks.    Manual Check:   - \"manual\": (mKYC) Checks user has a sufficient amount of operator verified ID and will then \"pass\" all Entity and ID related checks.    Fraud Checks - One or more of:   - \"fraudlist\": Checks to see if the identity appears on any known fraud lists. Should be run after KYC/ID checks have passed.   - \"fraudcheck\": Checks external ID services to see if details appear in fraud detection services (e.g. EmailAge or FraudNet)    PEP Checks - One of:   - \"pep\": Will only run PEP/Sanctions checks (no identity verification)   - \"pep_media\": Will run PEP/Sanctions checks, as well as watchlist and adverse media checks. (no identity verification)      * NOTE: These checks will ONLY run if either the KYC/ID checks have been run prior, or it is the only check requested.    Custom:   - By arrangement with Frankie you can define your own KYC check type.      This will allow you to set the minimum number of matches for:     - name      - date of birth     - address     - government id      This allows for alternatives to the \"standard\" two_plus or one_plus (note, these can be overridden too).  (required)
        :type check_type: str
        :param result_level: How much detail we return.   Acceptable values are:   * simple - Only available with \"profile\" check type. Returns just an EntityProfileResultObject (which is also included for \"profile\" checks at the other result levels), and a CheckEntityCheckResultObjectEntityResult with just the entity details but no separate results.   * summary   * full - You need to have your account configured for this.  (required)
        :type result_level: str
        :param entity_details: The entity to be checked (required)
        :type entity_details: EntityCheckDetailsObject
        :param x_frankie_customer_child_id: If, as a Frankie Customer, you are acting on behalf of your own customers, then you can populate this field with a Frankie-assigned ID.  Note: If using a CustomerChildID, you will also need a separate api_key for each child.  Any documents, checks, entities that are created when this field has been populated will now be tied to this CustomerID + CustomerChildID combination. Just as Customers cannot see data created by other Customers, so too a Customer's Children will not be able to see each other's data.  A Customer can see the documents/entities and checks of all their Children. 
        :type x_frankie_customer_child_id: str
        :param x_frankie_background: If this header parameter is supplied and set to 1, then the request will not wait for the process to finish, and will return a 202 if there are no obvious errors in the input. The request will then run in the background and send a notification back to the customer. See out callback API for details on this.  See more details here:   https://apidocs.frankiefinancial.com/docs/asynchronous-calls-backgrounding-processes 
        :type x_frankie_background: int
        :param force: Force the verification to run, overriding any data aging or past check 
        :type force: bool
        :param no_invalidate: Disable check result invalidation for this update request. 
        :type no_invalidate: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_check_entity_serialize(
            x_frankie_customer_id=x_frankie_customer_id,
            entity_id=entity_id,
            check_type=check_type,
            result_level=result_level,
            entity_details=entity_details,
            x_frankie_customer_child_id=x_frankie_customer_child_id,
            x_frankie_background=x_frankie_background,
            force=force,
            no_invalidate=no_invalidate,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CheckEntityCheckResultObject",
            '202': "AcceptedEntityResultObject",
            '400': "ErrorObject",
            '401': "ErrorObject",
            '404': "ErrorObject",
            '405': "ErrorObject",
            '415': "ErrorObject",
            '422': "ErrorObject",
            '429': "ErrorObject",
            '500': "ErrorObject",
            '503': "ErrorObject",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def update_check_entity_without_preload_content(
        self,
        x_frankie_customer_id: Annotated[StrictStr, Field(description="Customer ID issued by Frankie Financial. This will never change. Your API key, which is mapped to this identity, will change over time. ")],
        entity_id: Annotated[StrictStr, Field(description="The entityId returned previously from an earlier call to /check or /entity")],
        check_type: Annotated[StrictStr, Field(description="When creating a new check, you need to define the checks you wish to run.    The checkType is make up of a comma separated list of the types of check you wish to run. The order of the requested checks is not important, they will be re-ordered by the service and in some cases, depending on your account configuration, may be skipped.    The validation that is performed on the requested checks is to:   - ensure the check type is known   - is suitable for the type of entity (no KYC for organisations)   - disallow manual (mKYC) check with any other kind of KYC   - disallow mixing the \"profile\" check with any other kind of check.  The supported check types are:  Profile:   - \"profile\": By arrangement with Frankie we will create a \"profile\" check type that applies checks according to a recipe that you assign to the entity from a predefined set of profiles.      The profile to use will be taken from the entity.entityProfile field if set, or be run through a set of configurable rules to determine which one to use.      Profiles provide a pre-defined combination of individual checkTypes (see the list below). But they offer a lot more besides, including rules for determining default settings, inbuilt data aging and other configurable features.   They also allow for a new result set top be returned that provides a more detailed and useful breakdown of the check/verification process.      Entity Profiles are a recent feature (since v1.4.0) but are now the default checkType to use with Frankie Financial.  **Individual Check Types**  Whilst we strongly recommend the use of the \"profile\" checktype, it does map of any combination of the types below. If you wish to use these individually, please contact developer support for more details on how to use these effectively.  Entity Checks - One of:   - \"one_plus\": Checks name, address and DoB against a minimum of 1 data source. (also known as a 1+1)   - \"two_plus\": Checks name, address and DoB against a minimum of 2 independent data sources (also known as a 2+2)  ID Checks - One of:   - \"id\": Checks all of the identity documents, but not necessarily the entity itself independently. Use this in conjunction with a one_plus or two_plus for more.   - \"visa\":    ID Validate - One of:   - \"idvalidate\": Checks to see if photo ID has had OCR scanning, ID document validation and photo comparison run against it. Can be used in conjunction with any of the KYC/ID/AML checks.    Manual Check:   - \"manual\": (mKYC) Checks user has a sufficient amount of operator verified ID and will then \"pass\" all Entity and ID related checks.    Fraud Checks - One or more of:   - \"fraudlist\": Checks to see if the identity appears on any known fraud lists. Should be run after KYC/ID checks have passed.   - \"fraudcheck\": Checks external ID services to see if details appear in fraud detection services (e.g. EmailAge or FraudNet)    PEP Checks - One of:   - \"pep\": Will only run PEP/Sanctions checks (no identity verification)   - \"pep_media\": Will run PEP/Sanctions checks, as well as watchlist and adverse media checks. (no identity verification)      * NOTE: These checks will ONLY run if either the KYC/ID checks have been run prior, or it is the only check requested.    Custom:   - By arrangement with Frankie you can define your own KYC check type.      This will allow you to set the minimum number of matches for:     - name      - date of birth     - address     - government id      This allows for alternatives to the \"standard\" two_plus or one_plus (note, these can be overridden too). ")],
        result_level: Annotated[StrictStr, Field(description="How much detail we return.   Acceptable values are:   * simple - Only available with \"profile\" check type. Returns just an EntityProfileResultObject (which is also included for \"profile\" checks at the other result levels), and a CheckEntityCheckResultObjectEntityResult with just the entity details but no separate results.   * summary   * full - You need to have your account configured for this. ")],
        entity_details: Annotated[EntityCheckDetailsObject, Field(description="The entity to be checked")],
        x_frankie_customer_child_id: Annotated[Optional[StrictStr], Field(description="If, as a Frankie Customer, you are acting on behalf of your own customers, then you can populate this field with a Frankie-assigned ID.  Note: If using a CustomerChildID, you will also need a separate api_key for each child.  Any documents, checks, entities that are created when this field has been populated will now be tied to this CustomerID + CustomerChildID combination. Just as Customers cannot see data created by other Customers, so too a Customer's Children will not be able to see each other's data.  A Customer can see the documents/entities and checks of all their Children. ")] = None,
        x_frankie_background: Annotated[Optional[Annotated[int, Field(le=1, strict=True, ge=0)]], Field(description="If this header parameter is supplied and set to 1, then the request will not wait for the process to finish, and will return a 202 if there are no obvious errors in the input. The request will then run in the background and send a notification back to the customer. See out callback API for details on this.  See more details here:   https://apidocs.frankiefinancial.com/docs/asynchronous-calls-backgrounding-processes ")] = None,
        force: Annotated[Optional[StrictBool], Field(description="Force the verification to run, overriding any data aging or past check ")] = None,
        no_invalidate: Annotated[Optional[StrictBool], Field(description="Disable check result invalidation for this update request. ")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Update Entity and Verify Details

        Take the details and documents provided in the entity, and set about verifying them all. So for example, you might extract:  * The name from the entity.name object * The address from the entity.address object * The DoB..  All documents that are presently attached to the entity will also be verified (if requested)  You can also specify the level of detail returned using the resultLevel parameter. You can choose \"summary\" or \"full\". For the \"profile\" check type you can also select \"simple\" to only get the entity profile result.  SPECIAL NOTE: A \"Full\" response includes details of all checks and how they map against each element, along with all the details of pep/sanctions/etc checks too.  Your account also needs to be configured to support a full response too (talk to your account manager for more information). If you're not configured for full responses, we'll only return summary level data regardless. 

        :param x_frankie_customer_id: Customer ID issued by Frankie Financial. This will never change. Your API key, which is mapped to this identity, will change over time.  (required)
        :type x_frankie_customer_id: str
        :param entity_id: The entityId returned previously from an earlier call to /check or /entity (required)
        :type entity_id: str
        :param check_type: When creating a new check, you need to define the checks you wish to run.    The checkType is make up of a comma separated list of the types of check you wish to run. The order of the requested checks is not important, they will be re-ordered by the service and in some cases, depending on your account configuration, may be skipped.    The validation that is performed on the requested checks is to:   - ensure the check type is known   - is suitable for the type of entity (no KYC for organisations)   - disallow manual (mKYC) check with any other kind of KYC   - disallow mixing the \"profile\" check with any other kind of check.  The supported check types are:  Profile:   - \"profile\": By arrangement with Frankie we will create a \"profile\" check type that applies checks according to a recipe that you assign to the entity from a predefined set of profiles.      The profile to use will be taken from the entity.entityProfile field if set, or be run through a set of configurable rules to determine which one to use.      Profiles provide a pre-defined combination of individual checkTypes (see the list below). But they offer a lot more besides, including rules for determining default settings, inbuilt data aging and other configurable features.   They also allow for a new result set top be returned that provides a more detailed and useful breakdown of the check/verification process.      Entity Profiles are a recent feature (since v1.4.0) but are now the default checkType to use with Frankie Financial.  **Individual Check Types**  Whilst we strongly recommend the use of the \"profile\" checktype, it does map of any combination of the types below. If you wish to use these individually, please contact developer support for more details on how to use these effectively.  Entity Checks - One of:   - \"one_plus\": Checks name, address and DoB against a minimum of 1 data source. (also known as a 1+1)   - \"two_plus\": Checks name, address and DoB against a minimum of 2 independent data sources (also known as a 2+2)  ID Checks - One of:   - \"id\": Checks all of the identity documents, but not necessarily the entity itself independently. Use this in conjunction with a one_plus or two_plus for more.   - \"visa\":    ID Validate - One of:   - \"idvalidate\": Checks to see if photo ID has had OCR scanning, ID document validation and photo comparison run against it. Can be used in conjunction with any of the KYC/ID/AML checks.    Manual Check:   - \"manual\": (mKYC) Checks user has a sufficient amount of operator verified ID and will then \"pass\" all Entity and ID related checks.    Fraud Checks - One or more of:   - \"fraudlist\": Checks to see if the identity appears on any known fraud lists. Should be run after KYC/ID checks have passed.   - \"fraudcheck\": Checks external ID services to see if details appear in fraud detection services (e.g. EmailAge or FraudNet)    PEP Checks - One of:   - \"pep\": Will only run PEP/Sanctions checks (no identity verification)   - \"pep_media\": Will run PEP/Sanctions checks, as well as watchlist and adverse media checks. (no identity verification)      * NOTE: These checks will ONLY run if either the KYC/ID checks have been run prior, or it is the only check requested.    Custom:   - By arrangement with Frankie you can define your own KYC check type.      This will allow you to set the minimum number of matches for:     - name      - date of birth     - address     - government id      This allows for alternatives to the \"standard\" two_plus or one_plus (note, these can be overridden too).  (required)
        :type check_type: str
        :param result_level: How much detail we return.   Acceptable values are:   * simple - Only available with \"profile\" check type. Returns just an EntityProfileResultObject (which is also included for \"profile\" checks at the other result levels), and a CheckEntityCheckResultObjectEntityResult with just the entity details but no separate results.   * summary   * full - You need to have your account configured for this.  (required)
        :type result_level: str
        :param entity_details: The entity to be checked (required)
        :type entity_details: EntityCheckDetailsObject
        :param x_frankie_customer_child_id: If, as a Frankie Customer, you are acting on behalf of your own customers, then you can populate this field with a Frankie-assigned ID.  Note: If using a CustomerChildID, you will also need a separate api_key for each child.  Any documents, checks, entities that are created when this field has been populated will now be tied to this CustomerID + CustomerChildID combination. Just as Customers cannot see data created by other Customers, so too a Customer's Children will not be able to see each other's data.  A Customer can see the documents/entities and checks of all their Children. 
        :type x_frankie_customer_child_id: str
        :param x_frankie_background: If this header parameter is supplied and set to 1, then the request will not wait for the process to finish, and will return a 202 if there are no obvious errors in the input. The request will then run in the background and send a notification back to the customer. See out callback API for details on this.  See more details here:   https://apidocs.frankiefinancial.com/docs/asynchronous-calls-backgrounding-processes 
        :type x_frankie_background: int
        :param force: Force the verification to run, overriding any data aging or past check 
        :type force: bool
        :param no_invalidate: Disable check result invalidation for this update request. 
        :type no_invalidate: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_check_entity_serialize(
            x_frankie_customer_id=x_frankie_customer_id,
            entity_id=entity_id,
            check_type=check_type,
            result_level=result_level,
            entity_details=entity_details,
            x_frankie_customer_child_id=x_frankie_customer_child_id,
            x_frankie_background=x_frankie_background,
            force=force,
            no_invalidate=no_invalidate,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CheckEntityCheckResultObject",
            '202': "AcceptedEntityResultObject",
            '400': "ErrorObject",
            '401': "ErrorObject",
            '404': "ErrorObject",
            '405': "ErrorObject",
            '415': "ErrorObject",
            '422': "ErrorObject",
            '429': "ErrorObject",
            '500': "ErrorObject",
            '503': "ErrorObject",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _update_check_entity_serialize(
        self,
        x_frankie_customer_id,
        entity_id,
        check_type,
        result_level,
        entity_details,
        x_frankie_customer_child_id,
        x_frankie_background,
        force,
        no_invalidate,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if entity_id is not None:
            _path_params['entityId'] = entity_id
        if check_type is not None:
            _path_params['checkType'] = check_type
        if result_level is not None:
            _path_params['resultLevel'] = result_level
        # process the query parameters
        if force is not None:
            
            _query_params.append(('force', force))
            
        if no_invalidate is not None:
            
            _query_params.append(('noInvalidate', no_invalidate))
            
        # process the header parameters
        if x_frankie_customer_id is not None:
            _header_params['X-Frankie-CustomerID'] = x_frankie_customer_id
        if x_frankie_customer_child_id is not None:
            _header_params['X-Frankie-CustomerChildID'] = x_frankie_customer_child_id
        if x_frankie_background is not None:
            _header_params['X-Frankie-Background'] = x_frankie_background
        # process the form parameters
        # process the body parameter
        if entity_details is not None:
            _body_params = entity_details


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'api_key'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/entity/{entityId}/verify/{checkType}/{resultLevel}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def update_check_entity_push_to_mobile(
        self,
        x_frankie_customer_id: Annotated[StrictStr, Field(description="Customer ID issued by Frankie Financial. This will never change. Your API key, which is mapped to this identity, will change over time. ")],
        entity_id: Annotated[StrictStr, Field(description="The entityId returned previously from an earlier call to /check or /entity")],
        entity_details: Annotated[EntityCheckDetailsObject, Field(description="The entity and any associated / additional information to be checked")],
        x_frankie_customer_child_id: Annotated[Optional[StrictStr], Field(description="If, as a Frankie Customer, you are acting on behalf of your own customers, then you can populate this field with a Frankie-assigned ID.  Note: If using a CustomerChildID, you will also need a separate api_key for each child.  Any documents, checks, entities that are created when this field has been populated will now be tied to this CustomerID + CustomerChildID combination. Just as Customers cannot see data created by other Customers, so too a Customer's Children will not be able to see each other's data.  A Customer can see the documents/entities and checks of all their Children. ")] = None,
        x_frankie_background: Annotated[Optional[Annotated[int, Field(le=1, strict=True, ge=0)]], Field(description="If this header parameter is supplied and set to 1, then the request will not wait for the process to finish, and will return a 202 if there are no obvious errors in the input. The request will then run in the background and send a notification back to the customer. See out callback API for details on this.  See more details here:   https://apidocs.frankiefinancial.com/docs/asynchronous-calls-backgrounding-processes ")] = None,
        nopush: Annotated[Optional[StrictBool], Field(description="If set to true, then no SMS/email will be pushed. It will be up to the API caller to manage the delivery of the link. ")] = None,
        phase: Annotated[Optional[StrictInt], Field(description="Set the Push To Mobile phase.  Currently supported values: - 2 ")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> AcceptedEntityResultObject:
        """Update Entity and Push Self-Verification Link

        Update an existing entity object and begin the process of verification after pushing a message to a mobile number.  The entity will receive a link on their mobile and will then be guided through a series of steps to capture and OCR scan their ID, and perform a selfie comparison. We'll then attempt to verify the data received and push a notification back to the calling customer.  At a minimum, you will need to supply the name and a MOBILE_PHONE document type.         If you wish to skip the detail capture and jump straight to the ID and selfie capture, the append the call with the ?phase=2 parameter.   SPECIAL NOTE: This will only ever return a 202 response if successfully accepted. You will need to ensure your account is configured for push notifications. Contact developer supprt to arrange this. 

        :param x_frankie_customer_id: Customer ID issued by Frankie Financial. This will never change. Your API key, which is mapped to this identity, will change over time.  (required)
        :type x_frankie_customer_id: str
        :param entity_id: The entityId returned previously from an earlier call to /check or /entity (required)
        :type entity_id: str
        :param entity_details: The entity and any associated / additional information to be checked (required)
        :type entity_details: EntityCheckDetailsObject
        :param x_frankie_customer_child_id: If, as a Frankie Customer, you are acting on behalf of your own customers, then you can populate this field with a Frankie-assigned ID.  Note: If using a CustomerChildID, you will also need a separate api_key for each child.  Any documents, checks, entities that are created when this field has been populated will now be tied to this CustomerID + CustomerChildID combination. Just as Customers cannot see data created by other Customers, so too a Customer's Children will not be able to see each other's data.  A Customer can see the documents/entities and checks of all their Children. 
        :type x_frankie_customer_child_id: str
        :param x_frankie_background: If this header parameter is supplied and set to 1, then the request will not wait for the process to finish, and will return a 202 if there are no obvious errors in the input. The request will then run in the background and send a notification back to the customer. See out callback API for details on this.  See more details here:   https://apidocs.frankiefinancial.com/docs/asynchronous-calls-backgrounding-processes 
        :type x_frankie_background: int
        :param nopush: If set to true, then no SMS/email will be pushed. It will be up to the API caller to manage the delivery of the link. 
        :type nopush: bool
        :param phase: Set the Push To Mobile phase.  Currently supported values: - 2 
        :type phase: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_check_entity_push_to_mobile_serialize(
            x_frankie_customer_id=x_frankie_customer_id,
            entity_id=entity_id,
            entity_details=entity_details,
            x_frankie_customer_child_id=x_frankie_customer_child_id,
            x_frankie_background=x_frankie_background,
            nopush=nopush,
            phase=phase,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '202': "AcceptedEntityResultObject",
            '400': "ErrorObject",
            '401': "ErrorObject",
            '404': "ErrorObject",
            '405': "ErrorObject",
            '415': "ErrorObject",
            '422': "ErrorObject",
            '429': "ErrorObject",
            '500': "ErrorObject",
            '503': "ErrorObject",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def update_check_entity_push_to_mobile_with_http_info(
        self,
        x_frankie_customer_id: Annotated[StrictStr, Field(description="Customer ID issued by Frankie Financial. This will never change. Your API key, which is mapped to this identity, will change over time. ")],
        entity_id: Annotated[StrictStr, Field(description="The entityId returned previously from an earlier call to /check or /entity")],
        entity_details: Annotated[EntityCheckDetailsObject, Field(description="The entity and any associated / additional information to be checked")],
        x_frankie_customer_child_id: Annotated[Optional[StrictStr], Field(description="If, as a Frankie Customer, you are acting on behalf of your own customers, then you can populate this field with a Frankie-assigned ID.  Note: If using a CustomerChildID, you will also need a separate api_key for each child.  Any documents, checks, entities that are created when this field has been populated will now be tied to this CustomerID + CustomerChildID combination. Just as Customers cannot see data created by other Customers, so too a Customer's Children will not be able to see each other's data.  A Customer can see the documents/entities and checks of all their Children. ")] = None,
        x_frankie_background: Annotated[Optional[Annotated[int, Field(le=1, strict=True, ge=0)]], Field(description="If this header parameter is supplied and set to 1, then the request will not wait for the process to finish, and will return a 202 if there are no obvious errors in the input. The request will then run in the background and send a notification back to the customer. See out callback API for details on this.  See more details here:   https://apidocs.frankiefinancial.com/docs/asynchronous-calls-backgrounding-processes ")] = None,
        nopush: Annotated[Optional[StrictBool], Field(description="If set to true, then no SMS/email will be pushed. It will be up to the API caller to manage the delivery of the link. ")] = None,
        phase: Annotated[Optional[StrictInt], Field(description="Set the Push To Mobile phase.  Currently supported values: - 2 ")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[AcceptedEntityResultObject]:
        """Update Entity and Push Self-Verification Link

        Update an existing entity object and begin the process of verification after pushing a message to a mobile number.  The entity will receive a link on their mobile and will then be guided through a series of steps to capture and OCR scan their ID, and perform a selfie comparison. We'll then attempt to verify the data received and push a notification back to the calling customer.  At a minimum, you will need to supply the name and a MOBILE_PHONE document type.         If you wish to skip the detail capture and jump straight to the ID and selfie capture, the append the call with the ?phase=2 parameter.   SPECIAL NOTE: This will only ever return a 202 response if successfully accepted. You will need to ensure your account is configured for push notifications. Contact developer supprt to arrange this. 

        :param x_frankie_customer_id: Customer ID issued by Frankie Financial. This will never change. Your API key, which is mapped to this identity, will change over time.  (required)
        :type x_frankie_customer_id: str
        :param entity_id: The entityId returned previously from an earlier call to /check or /entity (required)
        :type entity_id: str
        :param entity_details: The entity and any associated / additional information to be checked (required)
        :type entity_details: EntityCheckDetailsObject
        :param x_frankie_customer_child_id: If, as a Frankie Customer, you are acting on behalf of your own customers, then you can populate this field with a Frankie-assigned ID.  Note: If using a CustomerChildID, you will also need a separate api_key for each child.  Any documents, checks, entities that are created when this field has been populated will now be tied to this CustomerID + CustomerChildID combination. Just as Customers cannot see data created by other Customers, so too a Customer's Children will not be able to see each other's data.  A Customer can see the documents/entities and checks of all their Children. 
        :type x_frankie_customer_child_id: str
        :param x_frankie_background: If this header parameter is supplied and set to 1, then the request will not wait for the process to finish, and will return a 202 if there are no obvious errors in the input. The request will then run in the background and send a notification back to the customer. See out callback API for details on this.  See more details here:   https://apidocs.frankiefinancial.com/docs/asynchronous-calls-backgrounding-processes 
        :type x_frankie_background: int
        :param nopush: If set to true, then no SMS/email will be pushed. It will be up to the API caller to manage the delivery of the link. 
        :type nopush: bool
        :param phase: Set the Push To Mobile phase.  Currently supported values: - 2 
        :type phase: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_check_entity_push_to_mobile_serialize(
            x_frankie_customer_id=x_frankie_customer_id,
            entity_id=entity_id,
            entity_details=entity_details,
            x_frankie_customer_child_id=x_frankie_customer_child_id,
            x_frankie_background=x_frankie_background,
            nopush=nopush,
            phase=phase,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '202': "AcceptedEntityResultObject",
            '400': "ErrorObject",
            '401': "ErrorObject",
            '404': "ErrorObject",
            '405': "ErrorObject",
            '415': "ErrorObject",
            '422': "ErrorObject",
            '429': "ErrorObject",
            '500': "ErrorObject",
            '503': "ErrorObject",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def update_check_entity_push_to_mobile_without_preload_content(
        self,
        x_frankie_customer_id: Annotated[StrictStr, Field(description="Customer ID issued by Frankie Financial. This will never change. Your API key, which is mapped to this identity, will change over time. ")],
        entity_id: Annotated[StrictStr, Field(description="The entityId returned previously from an earlier call to /check or /entity")],
        entity_details: Annotated[EntityCheckDetailsObject, Field(description="The entity and any associated / additional information to be checked")],
        x_frankie_customer_child_id: Annotated[Optional[StrictStr], Field(description="If, as a Frankie Customer, you are acting on behalf of your own customers, then you can populate this field with a Frankie-assigned ID.  Note: If using a CustomerChildID, you will also need a separate api_key for each child.  Any documents, checks, entities that are created when this field has been populated will now be tied to this CustomerID + CustomerChildID combination. Just as Customers cannot see data created by other Customers, so too a Customer's Children will not be able to see each other's data.  A Customer can see the documents/entities and checks of all their Children. ")] = None,
        x_frankie_background: Annotated[Optional[Annotated[int, Field(le=1, strict=True, ge=0)]], Field(description="If this header parameter is supplied and set to 1, then the request will not wait for the process to finish, and will return a 202 if there are no obvious errors in the input. The request will then run in the background and send a notification back to the customer. See out callback API for details on this.  See more details here:   https://apidocs.frankiefinancial.com/docs/asynchronous-calls-backgrounding-processes ")] = None,
        nopush: Annotated[Optional[StrictBool], Field(description="If set to true, then no SMS/email will be pushed. It will be up to the API caller to manage the delivery of the link. ")] = None,
        phase: Annotated[Optional[StrictInt], Field(description="Set the Push To Mobile phase.  Currently supported values: - 2 ")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Update Entity and Push Self-Verification Link

        Update an existing entity object and begin the process of verification after pushing a message to a mobile number.  The entity will receive a link on their mobile and will then be guided through a series of steps to capture and OCR scan their ID, and perform a selfie comparison. We'll then attempt to verify the data received and push a notification back to the calling customer.  At a minimum, you will need to supply the name and a MOBILE_PHONE document type.         If you wish to skip the detail capture and jump straight to the ID and selfie capture, the append the call with the ?phase=2 parameter.   SPECIAL NOTE: This will only ever return a 202 response if successfully accepted. You will need to ensure your account is configured for push notifications. Contact developer supprt to arrange this. 

        :param x_frankie_customer_id: Customer ID issued by Frankie Financial. This will never change. Your API key, which is mapped to this identity, will change over time.  (required)
        :type x_frankie_customer_id: str
        :param entity_id: The entityId returned previously from an earlier call to /check or /entity (required)
        :type entity_id: str
        :param entity_details: The entity and any associated / additional information to be checked (required)
        :type entity_details: EntityCheckDetailsObject
        :param x_frankie_customer_child_id: If, as a Frankie Customer, you are acting on behalf of your own customers, then you can populate this field with a Frankie-assigned ID.  Note: If using a CustomerChildID, you will also need a separate api_key for each child.  Any documents, checks, entities that are created when this field has been populated will now be tied to this CustomerID + CustomerChildID combination. Just as Customers cannot see data created by other Customers, so too a Customer's Children will not be able to see each other's data.  A Customer can see the documents/entities and checks of all their Children. 
        :type x_frankie_customer_child_id: str
        :param x_frankie_background: If this header parameter is supplied and set to 1, then the request will not wait for the process to finish, and will return a 202 if there are no obvious errors in the input. The request will then run in the background and send a notification back to the customer. See out callback API for details on this.  See more details here:   https://apidocs.frankiefinancial.com/docs/asynchronous-calls-backgrounding-processes 
        :type x_frankie_background: int
        :param nopush: If set to true, then no SMS/email will be pushed. It will be up to the API caller to manage the delivery of the link. 
        :type nopush: bool
        :param phase: Set the Push To Mobile phase.  Currently supported values: - 2 
        :type phase: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_check_entity_push_to_mobile_serialize(
            x_frankie_customer_id=x_frankie_customer_id,
            entity_id=entity_id,
            entity_details=entity_details,
            x_frankie_customer_child_id=x_frankie_customer_child_id,
            x_frankie_background=x_frankie_background,
            nopush=nopush,
            phase=phase,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '202': "AcceptedEntityResultObject",
            '400': "ErrorObject",
            '401': "ErrorObject",
            '404': "ErrorObject",
            '405': "ErrorObject",
            '415': "ErrorObject",
            '422': "ErrorObject",
            '429': "ErrorObject",
            '500': "ErrorObject",
            '503': "ErrorObject",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _update_check_entity_push_to_mobile_serialize(
        self,
        x_frankie_customer_id,
        entity_id,
        entity_details,
        x_frankie_customer_child_id,
        x_frankie_background,
        nopush,
        phase,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if entity_id is not None:
            _path_params['entityId'] = entity_id
        # process the query parameters
        if nopush is not None:
            
            _query_params.append(('nopush', nopush))
            
        if phase is not None:
            
            _query_params.append(('phase', phase))
            
        # process the header parameters
        if x_frankie_customer_id is not None:
            _header_params['X-Frankie-CustomerID'] = x_frankie_customer_id
        if x_frankie_customer_child_id is not None:
            _header_params['X-Frankie-CustomerChildID'] = x_frankie_customer_child_id
        if x_frankie_background is not None:
            _header_params['X-Frankie-Background'] = x_frankie_background
        # process the form parameters
        # process the body parameter
        if entity_details is not None:
            _body_params = entity_details


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'api_key'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/entity/{entityId}/verify/pushToMobile',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def update_entity(
        self,
        x_frankie_customer_id: Annotated[StrictStr, Field(description="Customer ID issued by Frankie Financial. This will never change. Your API key, which is mapped to this identity, will change over time. ")],
        entity_id: Annotated[StrictStr, Field(description="The entityId returned previously from an earlier call to /check or /entity")],
        entity: Annotated[EntityObject, Field(description="The entity to be updated")],
        x_frankie_customer_child_id: Annotated[Optional[StrictStr], Field(description="If, as a Frankie Customer, you are acting on behalf of your own customers, then you can populate this field with a Frankie-assigned ID.  Note: If using a CustomerChildID, you will also need a separate api_key for each child.  Any documents, checks, entities that are created when this field has been populated will now be tied to this CustomerID + CustomerChildID combination. Just as Customers cannot see data created by other Customers, so too a Customer's Children will not be able to see each other's data.  A Customer can see the documents/entities and checks of all their Children. ")] = None,
        x_frankie_background: Annotated[Optional[Annotated[int, Field(le=1, strict=True, ge=0)]], Field(description="If this header parameter is supplied and set to 1, then the request will not wait for the process to finish, and will return a 202 if there are no obvious errors in the input. The request will then run in the background and send a notification back to the customer. See out callback API for details on this.  See more details here:   https://apidocs.frankiefinancial.com/docs/asynchronous-calls-backgrounding-processes ")] = None,
        no_invalidate: Annotated[Optional[StrictBool], Field(description="Disable check result invalidation for this update request. ")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> EntityResultObject:
        """Update Existing Entity.

        Using a previously uploaded but incomplete Entity, you can optionally supply updated details (such as corrections on a previous address), along with one or more additional ID docs/scans (e.g. new documents to parse, etc). 

        :param x_frankie_customer_id: Customer ID issued by Frankie Financial. This will never change. Your API key, which is mapped to this identity, will change over time.  (required)
        :type x_frankie_customer_id: str
        :param entity_id: The entityId returned previously from an earlier call to /check or /entity (required)
        :type entity_id: str
        :param entity: The entity to be updated (required)
        :type entity: EntityObject
        :param x_frankie_customer_child_id: If, as a Frankie Customer, you are acting on behalf of your own customers, then you can populate this field with a Frankie-assigned ID.  Note: If using a CustomerChildID, you will also need a separate api_key for each child.  Any documents, checks, entities that are created when this field has been populated will now be tied to this CustomerID + CustomerChildID combination. Just as Customers cannot see data created by other Customers, so too a Customer's Children will not be able to see each other's data.  A Customer can see the documents/entities and checks of all their Children. 
        :type x_frankie_customer_child_id: str
        :param x_frankie_background: If this header parameter is supplied and set to 1, then the request will not wait for the process to finish, and will return a 202 if there are no obvious errors in the input. The request will then run in the background and send a notification back to the customer. See out callback API for details on this.  See more details here:   https://apidocs.frankiefinancial.com/docs/asynchronous-calls-backgrounding-processes 
        :type x_frankie_background: int
        :param no_invalidate: Disable check result invalidation for this update request. 
        :type no_invalidate: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_entity_serialize(
            x_frankie_customer_id=x_frankie_customer_id,
            entity_id=entity_id,
            entity=entity,
            x_frankie_customer_child_id=x_frankie_customer_child_id,
            x_frankie_background=x_frankie_background,
            no_invalidate=no_invalidate,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "EntityResultObject",
            '202': "AcceptedEntityResultObject",
            '400': "ErrorObject",
            '401': "ErrorObject",
            '404': "ErrorObject",
            '405': "ErrorObject",
            '415': "ErrorObject",
            '422': "ErrorObject",
            '429': "ErrorObject",
            '500': "ErrorObject",
            '503': "ErrorObject",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def update_entity_with_http_info(
        self,
        x_frankie_customer_id: Annotated[StrictStr, Field(description="Customer ID issued by Frankie Financial. This will never change. Your API key, which is mapped to this identity, will change over time. ")],
        entity_id: Annotated[StrictStr, Field(description="The entityId returned previously from an earlier call to /check or /entity")],
        entity: Annotated[EntityObject, Field(description="The entity to be updated")],
        x_frankie_customer_child_id: Annotated[Optional[StrictStr], Field(description="If, as a Frankie Customer, you are acting on behalf of your own customers, then you can populate this field with a Frankie-assigned ID.  Note: If using a CustomerChildID, you will also need a separate api_key for each child.  Any documents, checks, entities that are created when this field has been populated will now be tied to this CustomerID + CustomerChildID combination. Just as Customers cannot see data created by other Customers, so too a Customer's Children will not be able to see each other's data.  A Customer can see the documents/entities and checks of all their Children. ")] = None,
        x_frankie_background: Annotated[Optional[Annotated[int, Field(le=1, strict=True, ge=0)]], Field(description="If this header parameter is supplied and set to 1, then the request will not wait for the process to finish, and will return a 202 if there are no obvious errors in the input. The request will then run in the background and send a notification back to the customer. See out callback API for details on this.  See more details here:   https://apidocs.frankiefinancial.com/docs/asynchronous-calls-backgrounding-processes ")] = None,
        no_invalidate: Annotated[Optional[StrictBool], Field(description="Disable check result invalidation for this update request. ")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[EntityResultObject]:
        """Update Existing Entity.

        Using a previously uploaded but incomplete Entity, you can optionally supply updated details (such as corrections on a previous address), along with one or more additional ID docs/scans (e.g. new documents to parse, etc). 

        :param x_frankie_customer_id: Customer ID issued by Frankie Financial. This will never change. Your API key, which is mapped to this identity, will change over time.  (required)
        :type x_frankie_customer_id: str
        :param entity_id: The entityId returned previously from an earlier call to /check or /entity (required)
        :type entity_id: str
        :param entity: The entity to be updated (required)
        :type entity: EntityObject
        :param x_frankie_customer_child_id: If, as a Frankie Customer, you are acting on behalf of your own customers, then you can populate this field with a Frankie-assigned ID.  Note: If using a CustomerChildID, you will also need a separate api_key for each child.  Any documents, checks, entities that are created when this field has been populated will now be tied to this CustomerID + CustomerChildID combination. Just as Customers cannot see data created by other Customers, so too a Customer's Children will not be able to see each other's data.  A Customer can see the documents/entities and checks of all their Children. 
        :type x_frankie_customer_child_id: str
        :param x_frankie_background: If this header parameter is supplied and set to 1, then the request will not wait for the process to finish, and will return a 202 if there are no obvious errors in the input. The request will then run in the background and send a notification back to the customer. See out callback API for details on this.  See more details here:   https://apidocs.frankiefinancial.com/docs/asynchronous-calls-backgrounding-processes 
        :type x_frankie_background: int
        :param no_invalidate: Disable check result invalidation for this update request. 
        :type no_invalidate: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_entity_serialize(
            x_frankie_customer_id=x_frankie_customer_id,
            entity_id=entity_id,
            entity=entity,
            x_frankie_customer_child_id=x_frankie_customer_child_id,
            x_frankie_background=x_frankie_background,
            no_invalidate=no_invalidate,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "EntityResultObject",
            '202': "AcceptedEntityResultObject",
            '400': "ErrorObject",
            '401': "ErrorObject",
            '404': "ErrorObject",
            '405': "ErrorObject",
            '415': "ErrorObject",
            '422': "ErrorObject",
            '429': "ErrorObject",
            '500': "ErrorObject",
            '503': "ErrorObject",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def update_entity_without_preload_content(
        self,
        x_frankie_customer_id: Annotated[StrictStr, Field(description="Customer ID issued by Frankie Financial. This will never change. Your API key, which is mapped to this identity, will change over time. ")],
        entity_id: Annotated[StrictStr, Field(description="The entityId returned previously from an earlier call to /check or /entity")],
        entity: Annotated[EntityObject, Field(description="The entity to be updated")],
        x_frankie_customer_child_id: Annotated[Optional[StrictStr], Field(description="If, as a Frankie Customer, you are acting on behalf of your own customers, then you can populate this field with a Frankie-assigned ID.  Note: If using a CustomerChildID, you will also need a separate api_key for each child.  Any documents, checks, entities that are created when this field has been populated will now be tied to this CustomerID + CustomerChildID combination. Just as Customers cannot see data created by other Customers, so too a Customer's Children will not be able to see each other's data.  A Customer can see the documents/entities and checks of all their Children. ")] = None,
        x_frankie_background: Annotated[Optional[Annotated[int, Field(le=1, strict=True, ge=0)]], Field(description="If this header parameter is supplied and set to 1, then the request will not wait for the process to finish, and will return a 202 if there are no obvious errors in the input. The request will then run in the background and send a notification back to the customer. See out callback API for details on this.  See more details here:   https://apidocs.frankiefinancial.com/docs/asynchronous-calls-backgrounding-processes ")] = None,
        no_invalidate: Annotated[Optional[StrictBool], Field(description="Disable check result invalidation for this update request. ")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Update Existing Entity.

        Using a previously uploaded but incomplete Entity, you can optionally supply updated details (such as corrections on a previous address), along with one or more additional ID docs/scans (e.g. new documents to parse, etc). 

        :param x_frankie_customer_id: Customer ID issued by Frankie Financial. This will never change. Your API key, which is mapped to this identity, will change over time.  (required)
        :type x_frankie_customer_id: str
        :param entity_id: The entityId returned previously from an earlier call to /check or /entity (required)
        :type entity_id: str
        :param entity: The entity to be updated (required)
        :type entity: EntityObject
        :param x_frankie_customer_child_id: If, as a Frankie Customer, you are acting on behalf of your own customers, then you can populate this field with a Frankie-assigned ID.  Note: If using a CustomerChildID, you will also need a separate api_key for each child.  Any documents, checks, entities that are created when this field has been populated will now be tied to this CustomerID + CustomerChildID combination. Just as Customers cannot see data created by other Customers, so too a Customer's Children will not be able to see each other's data.  A Customer can see the documents/entities and checks of all their Children. 
        :type x_frankie_customer_child_id: str
        :param x_frankie_background: If this header parameter is supplied and set to 1, then the request will not wait for the process to finish, and will return a 202 if there are no obvious errors in the input. The request will then run in the background and send a notification back to the customer. See out callback API for details on this.  See more details here:   https://apidocs.frankiefinancial.com/docs/asynchronous-calls-backgrounding-processes 
        :type x_frankie_background: int
        :param no_invalidate: Disable check result invalidation for this update request. 
        :type no_invalidate: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_entity_serialize(
            x_frankie_customer_id=x_frankie_customer_id,
            entity_id=entity_id,
            entity=entity,
            x_frankie_customer_child_id=x_frankie_customer_child_id,
            x_frankie_background=x_frankie_background,
            no_invalidate=no_invalidate,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "EntityResultObject",
            '202': "AcceptedEntityResultObject",
            '400': "ErrorObject",
            '401': "ErrorObject",
            '404': "ErrorObject",
            '405': "ErrorObject",
            '415': "ErrorObject",
            '422': "ErrorObject",
            '429': "ErrorObject",
            '500': "ErrorObject",
            '503': "ErrorObject",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _update_entity_serialize(
        self,
        x_frankie_customer_id,
        entity_id,
        entity,
        x_frankie_customer_child_id,
        x_frankie_background,
        no_invalidate,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if entity_id is not None:
            _path_params['entityId'] = entity_id
        # process the query parameters
        if no_invalidate is not None:
            
            _query_params.append(('noInvalidate', no_invalidate))
            
        # process the header parameters
        if x_frankie_customer_id is not None:
            _header_params['X-Frankie-CustomerID'] = x_frankie_customer_id
        if x_frankie_customer_child_id is not None:
            _header_params['X-Frankie-CustomerChildID'] = x_frankie_customer_child_id
        if x_frankie_background is not None:
            _header_params['X-Frankie-Background'] = x_frankie_background
        # process the form parameters
        # process the body parameter
        if entity is not None:
            _body_params = entity


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'api_key'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/entity/{entityId}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def update_entity_get_idv_token(
        self,
        x_frankie_customer_id: Annotated[StrictStr, Field(description="Customer ID issued by Frankie Financial. This will never change. Your API key, which is mapped to this identity, will change over time. ")],
        entity_id: Annotated[StrictStr, Field(description="The entityId returned previously from an earlier call to /check or /entity")],
        entity_idv_details: Annotated[EntityIDVDetailsObject, Field(description="The entity to update and required data to generate an IDV token")],
        x_frankie_customer_child_id: Annotated[Optional[StrictStr], Field(description="If, as a Frankie Customer, you are acting on behalf of your own customers, then you can populate this field with a Frankie-assigned ID.  Note: If using a CustomerChildID, you will also need a separate api_key for each child.  Any documents, checks, entities that are created when this field has been populated will now be tied to this CustomerID + CustomerChildID combination. Just as Customers cannot see data created by other Customers, so too a Customer's Children will not be able to see each other's data.  A Customer can see the documents/entities and checks of all their Children. ")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> EntityIDVResultObject:
        """Update Entity and Get IDV Token

        Update an entity object and if successful, obtain a token for use in an ID Validation service SDK (web or native app)   At a minimum, the entity will need to have a name. For best results, you should gather the DoB, address, ID document details as well before calling the initProcess function.  SPECIAL NOTE 1: Tokens have a limited lifespan, typically only 1 hour. Make sure you've used it or you will need to create another using update version of this function.   SPECIAL NOTE 2: This function will need to be followed up with a call to /entity/{id}/idvalidate/initProcess once you've collected all your data in your app/web capture process. 

        :param x_frankie_customer_id: Customer ID issued by Frankie Financial. This will never change. Your API key, which is mapped to this identity, will change over time.  (required)
        :type x_frankie_customer_id: str
        :param entity_id: The entityId returned previously from an earlier call to /check or /entity (required)
        :type entity_id: str
        :param entity_idv_details: The entity to update and required data to generate an IDV token (required)
        :type entity_idv_details: EntityIDVDetailsObject
        :param x_frankie_customer_child_id: If, as a Frankie Customer, you are acting on behalf of your own customers, then you can populate this field with a Frankie-assigned ID.  Note: If using a CustomerChildID, you will also need a separate api_key for each child.  Any documents, checks, entities that are created when this field has been populated will now be tied to this CustomerID + CustomerChildID combination. Just as Customers cannot see data created by other Customers, so too a Customer's Children will not be able to see each other's data.  A Customer can see the documents/entities and checks of all their Children. 
        :type x_frankie_customer_child_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_entity_get_idv_token_serialize(
            x_frankie_customer_id=x_frankie_customer_id,
            entity_id=entity_id,
            entity_idv_details=entity_idv_details,
            x_frankie_customer_child_id=x_frankie_customer_child_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "EntityIDVResultObject",
            '400': "ErrorObject",
            '401': "ErrorObject",
            '404': "ErrorObject",
            '405': "ErrorObject",
            '415': "ErrorObject",
            '422': "ErrorObject",
            '429': "ErrorObject",
            '500': "ErrorObject",
            '503': "ErrorObject",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def update_entity_get_idv_token_with_http_info(
        self,
        x_frankie_customer_id: Annotated[StrictStr, Field(description="Customer ID issued by Frankie Financial. This will never change. Your API key, which is mapped to this identity, will change over time. ")],
        entity_id: Annotated[StrictStr, Field(description="The entityId returned previously from an earlier call to /check or /entity")],
        entity_idv_details: Annotated[EntityIDVDetailsObject, Field(description="The entity to update and required data to generate an IDV token")],
        x_frankie_customer_child_id: Annotated[Optional[StrictStr], Field(description="If, as a Frankie Customer, you are acting on behalf of your own customers, then you can populate this field with a Frankie-assigned ID.  Note: If using a CustomerChildID, you will also need a separate api_key for each child.  Any documents, checks, entities that are created when this field has been populated will now be tied to this CustomerID + CustomerChildID combination. Just as Customers cannot see data created by other Customers, so too a Customer's Children will not be able to see each other's data.  A Customer can see the documents/entities and checks of all their Children. ")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[EntityIDVResultObject]:
        """Update Entity and Get IDV Token

        Update an entity object and if successful, obtain a token for use in an ID Validation service SDK (web or native app)   At a minimum, the entity will need to have a name. For best results, you should gather the DoB, address, ID document details as well before calling the initProcess function.  SPECIAL NOTE 1: Tokens have a limited lifespan, typically only 1 hour. Make sure you've used it or you will need to create another using update version of this function.   SPECIAL NOTE 2: This function will need to be followed up with a call to /entity/{id}/idvalidate/initProcess once you've collected all your data in your app/web capture process. 

        :param x_frankie_customer_id: Customer ID issued by Frankie Financial. This will never change. Your API key, which is mapped to this identity, will change over time.  (required)
        :type x_frankie_customer_id: str
        :param entity_id: The entityId returned previously from an earlier call to /check or /entity (required)
        :type entity_id: str
        :param entity_idv_details: The entity to update and required data to generate an IDV token (required)
        :type entity_idv_details: EntityIDVDetailsObject
        :param x_frankie_customer_child_id: If, as a Frankie Customer, you are acting on behalf of your own customers, then you can populate this field with a Frankie-assigned ID.  Note: If using a CustomerChildID, you will also need a separate api_key for each child.  Any documents, checks, entities that are created when this field has been populated will now be tied to this CustomerID + CustomerChildID combination. Just as Customers cannot see data created by other Customers, so too a Customer's Children will not be able to see each other's data.  A Customer can see the documents/entities and checks of all their Children. 
        :type x_frankie_customer_child_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_entity_get_idv_token_serialize(
            x_frankie_customer_id=x_frankie_customer_id,
            entity_id=entity_id,
            entity_idv_details=entity_idv_details,
            x_frankie_customer_child_id=x_frankie_customer_child_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "EntityIDVResultObject",
            '400': "ErrorObject",
            '401': "ErrorObject",
            '404': "ErrorObject",
            '405': "ErrorObject",
            '415': "ErrorObject",
            '422': "ErrorObject",
            '429': "ErrorObject",
            '500': "ErrorObject",
            '503': "ErrorObject",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def update_entity_get_idv_token_without_preload_content(
        self,
        x_frankie_customer_id: Annotated[StrictStr, Field(description="Customer ID issued by Frankie Financial. This will never change. Your API key, which is mapped to this identity, will change over time. ")],
        entity_id: Annotated[StrictStr, Field(description="The entityId returned previously from an earlier call to /check or /entity")],
        entity_idv_details: Annotated[EntityIDVDetailsObject, Field(description="The entity to update and required data to generate an IDV token")],
        x_frankie_customer_child_id: Annotated[Optional[StrictStr], Field(description="If, as a Frankie Customer, you are acting on behalf of your own customers, then you can populate this field with a Frankie-assigned ID.  Note: If using a CustomerChildID, you will also need a separate api_key for each child.  Any documents, checks, entities that are created when this field has been populated will now be tied to this CustomerID + CustomerChildID combination. Just as Customers cannot see data created by other Customers, so too a Customer's Children will not be able to see each other's data.  A Customer can see the documents/entities and checks of all their Children. ")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Update Entity and Get IDV Token

        Update an entity object and if successful, obtain a token for use in an ID Validation service SDK (web or native app)   At a minimum, the entity will need to have a name. For best results, you should gather the DoB, address, ID document details as well before calling the initProcess function.  SPECIAL NOTE 1: Tokens have a limited lifespan, typically only 1 hour. Make sure you've used it or you will need to create another using update version of this function.   SPECIAL NOTE 2: This function will need to be followed up with a call to /entity/{id}/idvalidate/initProcess once you've collected all your data in your app/web capture process. 

        :param x_frankie_customer_id: Customer ID issued by Frankie Financial. This will never change. Your API key, which is mapped to this identity, will change over time.  (required)
        :type x_frankie_customer_id: str
        :param entity_id: The entityId returned previously from an earlier call to /check or /entity (required)
        :type entity_id: str
        :param entity_idv_details: The entity to update and required data to generate an IDV token (required)
        :type entity_idv_details: EntityIDVDetailsObject
        :param x_frankie_customer_child_id: If, as a Frankie Customer, you are acting on behalf of your own customers, then you can populate this field with a Frankie-assigned ID.  Note: If using a CustomerChildID, you will also need a separate api_key for each child.  Any documents, checks, entities that are created when this field has been populated will now be tied to this CustomerID + CustomerChildID combination. Just as Customers cannot see data created by other Customers, so too a Customer's Children will not be able to see each other's data.  A Customer can see the documents/entities and checks of all their Children. 
        :type x_frankie_customer_child_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_entity_get_idv_token_serialize(
            x_frankie_customer_id=x_frankie_customer_id,
            entity_id=entity_id,
            entity_idv_details=entity_idv_details,
            x_frankie_customer_child_id=x_frankie_customer_child_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "EntityIDVResultObject",
            '400': "ErrorObject",
            '401': "ErrorObject",
            '404': "ErrorObject",
            '405': "ErrorObject",
            '415': "ErrorObject",
            '422': "ErrorObject",
            '429': "ErrorObject",
            '500': "ErrorObject",
            '503': "ErrorObject",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _update_entity_get_idv_token_serialize(
        self,
        x_frankie_customer_id,
        entity_id,
        entity_idv_details,
        x_frankie_customer_child_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if entity_id is not None:
            _path_params['entityId'] = entity_id
        # process the query parameters
        # process the header parameters
        if x_frankie_customer_id is not None:
            _header_params['X-Frankie-CustomerID'] = x_frankie_customer_id
        if x_frankie_customer_child_id is not None:
            _header_params['X-Frankie-CustomerChildID'] = x_frankie_customer_child_id
        # process the form parameters
        # process the body parameter
        if entity_idv_details is not None:
            _body_params = entity_idv_details


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'api_key'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/entity/{entityId}/idvalidate/getToken',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def update_entity_init_idv_process(
        self,
        x_frankie_customer_id: Annotated[StrictStr, Field(description="Customer ID issued by Frankie Financial. This will never change. Your API key, which is mapped to this identity, will change over time. ")],
        entity_id: Annotated[StrictStr, Field(description="The entityId returned previously from an earlier call to /check or /entity")],
        entity_details: Annotated[EntityCheckDetailsObject, Field(description="The entity to update")],
        x_frankie_customer_child_id: Annotated[Optional[StrictStr], Field(description="If, as a Frankie Customer, you are acting on behalf of your own customers, then you can populate this field with a Frankie-assigned ID.  Note: If using a CustomerChildID, you will also need a separate api_key for each child.  Any documents, checks, entities that are created when this field has been populated will now be tied to this CustomerID + CustomerChildID combination. Just as Customers cannot see data created by other Customers, so too a Customer's Children will not be able to see each other's data.  A Customer can see the documents/entities and checks of all their Children. ")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> EntityIDVResultObject:
        """Update Entity and Initiate IDV Process

        Update an entity object and if successful, start the process of downloading the captured data and processing the reports and results of the ID validation process.   At a minimum, the entity will need to have a name. For best results, you should gather the DoB, address, ID document details as well before calling this initProcess function, or supply the details as part of this update. 

        :param x_frankie_customer_id: Customer ID issued by Frankie Financial. This will never change. Your API key, which is mapped to this identity, will change over time.  (required)
        :type x_frankie_customer_id: str
        :param entity_id: The entityId returned previously from an earlier call to /check or /entity (required)
        :type entity_id: str
        :param entity_details: The entity to update (required)
        :type entity_details: EntityCheckDetailsObject
        :param x_frankie_customer_child_id: If, as a Frankie Customer, you are acting on behalf of your own customers, then you can populate this field with a Frankie-assigned ID.  Note: If using a CustomerChildID, you will also need a separate api_key for each child.  Any documents, checks, entities that are created when this field has been populated will now be tied to this CustomerID + CustomerChildID combination. Just as Customers cannot see data created by other Customers, so too a Customer's Children will not be able to see each other's data.  A Customer can see the documents/entities and checks of all their Children. 
        :type x_frankie_customer_child_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_entity_init_idv_process_serialize(
            x_frankie_customer_id=x_frankie_customer_id,
            entity_id=entity_id,
            entity_details=entity_details,
            x_frankie_customer_child_id=x_frankie_customer_child_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "EntityIDVResultObject",
            '400': "ErrorObject",
            '401': "ErrorObject",
            '404': "ErrorObject",
            '405': "ErrorObject",
            '415': "ErrorObject",
            '422': "ErrorObject",
            '429': "ErrorObject",
            '500': "ErrorObject",
            '503': "ErrorObject",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def update_entity_init_idv_process_with_http_info(
        self,
        x_frankie_customer_id: Annotated[StrictStr, Field(description="Customer ID issued by Frankie Financial. This will never change. Your API key, which is mapped to this identity, will change over time. ")],
        entity_id: Annotated[StrictStr, Field(description="The entityId returned previously from an earlier call to /check or /entity")],
        entity_details: Annotated[EntityCheckDetailsObject, Field(description="The entity to update")],
        x_frankie_customer_child_id: Annotated[Optional[StrictStr], Field(description="If, as a Frankie Customer, you are acting on behalf of your own customers, then you can populate this field with a Frankie-assigned ID.  Note: If using a CustomerChildID, you will also need a separate api_key for each child.  Any documents, checks, entities that are created when this field has been populated will now be tied to this CustomerID + CustomerChildID combination. Just as Customers cannot see data created by other Customers, so too a Customer's Children will not be able to see each other's data.  A Customer can see the documents/entities and checks of all their Children. ")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[EntityIDVResultObject]:
        """Update Entity and Initiate IDV Process

        Update an entity object and if successful, start the process of downloading the captured data and processing the reports and results of the ID validation process.   At a minimum, the entity will need to have a name. For best results, you should gather the DoB, address, ID document details as well before calling this initProcess function, or supply the details as part of this update. 

        :param x_frankie_customer_id: Customer ID issued by Frankie Financial. This will never change. Your API key, which is mapped to this identity, will change over time.  (required)
        :type x_frankie_customer_id: str
        :param entity_id: The entityId returned previously from an earlier call to /check or /entity (required)
        :type entity_id: str
        :param entity_details: The entity to update (required)
        :type entity_details: EntityCheckDetailsObject
        :param x_frankie_customer_child_id: If, as a Frankie Customer, you are acting on behalf of your own customers, then you can populate this field with a Frankie-assigned ID.  Note: If using a CustomerChildID, you will also need a separate api_key for each child.  Any documents, checks, entities that are created when this field has been populated will now be tied to this CustomerID + CustomerChildID combination. Just as Customers cannot see data created by other Customers, so too a Customer's Children will not be able to see each other's data.  A Customer can see the documents/entities and checks of all their Children. 
        :type x_frankie_customer_child_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_entity_init_idv_process_serialize(
            x_frankie_customer_id=x_frankie_customer_id,
            entity_id=entity_id,
            entity_details=entity_details,
            x_frankie_customer_child_id=x_frankie_customer_child_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "EntityIDVResultObject",
            '400': "ErrorObject",
            '401': "ErrorObject",
            '404': "ErrorObject",
            '405': "ErrorObject",
            '415': "ErrorObject",
            '422': "ErrorObject",
            '429': "ErrorObject",
            '500': "ErrorObject",
            '503': "ErrorObject",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def update_entity_init_idv_process_without_preload_content(
        self,
        x_frankie_customer_id: Annotated[StrictStr, Field(description="Customer ID issued by Frankie Financial. This will never change. Your API key, which is mapped to this identity, will change over time. ")],
        entity_id: Annotated[StrictStr, Field(description="The entityId returned previously from an earlier call to /check or /entity")],
        entity_details: Annotated[EntityCheckDetailsObject, Field(description="The entity to update")],
        x_frankie_customer_child_id: Annotated[Optional[StrictStr], Field(description="If, as a Frankie Customer, you are acting on behalf of your own customers, then you can populate this field with a Frankie-assigned ID.  Note: If using a CustomerChildID, you will also need a separate api_key for each child.  Any documents, checks, entities that are created when this field has been populated will now be tied to this CustomerID + CustomerChildID combination. Just as Customers cannot see data created by other Customers, so too a Customer's Children will not be able to see each other's data.  A Customer can see the documents/entities and checks of all their Children. ")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Update Entity and Initiate IDV Process

        Update an entity object and if successful, start the process of downloading the captured data and processing the reports and results of the ID validation process.   At a minimum, the entity will need to have a name. For best results, you should gather the DoB, address, ID document details as well before calling this initProcess function, or supply the details as part of this update. 

        :param x_frankie_customer_id: Customer ID issued by Frankie Financial. This will never change. Your API key, which is mapped to this identity, will change over time.  (required)
        :type x_frankie_customer_id: str
        :param entity_id: The entityId returned previously from an earlier call to /check or /entity (required)
        :type entity_id: str
        :param entity_details: The entity to update (required)
        :type entity_details: EntityCheckDetailsObject
        :param x_frankie_customer_child_id: If, as a Frankie Customer, you are acting on behalf of your own customers, then you can populate this field with a Frankie-assigned ID.  Note: If using a CustomerChildID, you will also need a separate api_key for each child.  Any documents, checks, entities that are created when this field has been populated will now be tied to this CustomerID + CustomerChildID combination. Just as Customers cannot see data created by other Customers, so too a Customer's Children will not be able to see each other's data.  A Customer can see the documents/entities and checks of all their Children. 
        :type x_frankie_customer_child_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_entity_init_idv_process_serialize(
            x_frankie_customer_id=x_frankie_customer_id,
            entity_id=entity_id,
            entity_details=entity_details,
            x_frankie_customer_child_id=x_frankie_customer_child_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "EntityIDVResultObject",
            '400': "ErrorObject",
            '401': "ErrorObject",
            '404': "ErrorObject",
            '405': "ErrorObject",
            '415': "ErrorObject",
            '422': "ErrorObject",
            '429': "ErrorObject",
            '500': "ErrorObject",
            '503': "ErrorObject",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _update_entity_init_idv_process_serialize(
        self,
        x_frankie_customer_id,
        entity_id,
        entity_details,
        x_frankie_customer_child_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if entity_id is not None:
            _path_params['entityId'] = entity_id
        # process the query parameters
        # process the header parameters
        if x_frankie_customer_id is not None:
            _header_params['X-Frankie-CustomerID'] = x_frankie_customer_id
        if x_frankie_customer_child_id is not None:
            _header_params['X-Frankie-CustomerChildID'] = x_frankie_customer_child_id
        # process the form parameters
        # process the body parameter
        if entity_details is not None:
            _body_params = entity_details


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'api_key'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/entity/{entityId}/idvalidate/initProcess',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def update_entity_state(
        self,
        x_frankie_customer_id: Annotated[StrictStr, Field(description="Customer ID issued by Frankie Financial. This will never change. Your API key, which is mapped to this identity, will change over time. ")],
        entity_id: Annotated[StrictStr, Field(description="The entityId returned previously from an earlier call to /check or /entity")],
        x_frankie_customer_child_id: Annotated[Optional[StrictStr], Field(description="If, as a Frankie Customer, you are acting on behalf of your own customers, then you can populate this field with a Frankie-assigned ID.  Note: If using a CustomerChildID, you will also need a separate api_key for each child.  Any documents, checks, entities that are created when this field has been populated will now be tied to this CustomerID + CustomerChildID combination. Just as Customers cannot see data created by other Customers, so too a Customer's Children will not be able to see each other's data.  A Customer can see the documents/entities and checks of all their Children. ")] = None,
        set: Annotated[Optional[StrictStr], Field(description="The status of an entity. Valid values are:   - \"wait\": Waiting for new details from entity.   - \"fail\": Manually fail the onboarding process.   - \"archived\": Hide entity from on onboarding.   - \"clear\": Remove any of the above manual states as well as any manual risk.   - \"inactive\": Hide entity and prevent any further operations on it. Cannot be cleared. ")] = None,
        risk: Annotated[Optional[StrictStr], Field(description="The risk override setting for an entity. This value will be used until a verify result updates a real risk factor. Valid values are:   - \"low\"   - \"medium\"   - \"high\"   - \"unacceptable\"   - \"significant\" ")] = None,
        comment: Annotated[Optional[StrictStr], Field(description="A comment describing the reason for a request. ")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> CheckEntityCheckResultObject:
        """Update Entity States

        Internal only  Add a special internal 'entity result' to superceed any previous real checks until the next one. 

        :param x_frankie_customer_id: Customer ID issued by Frankie Financial. This will never change. Your API key, which is mapped to this identity, will change over time.  (required)
        :type x_frankie_customer_id: str
        :param entity_id: The entityId returned previously from an earlier call to /check or /entity (required)
        :type entity_id: str
        :param x_frankie_customer_child_id: If, as a Frankie Customer, you are acting on behalf of your own customers, then you can populate this field with a Frankie-assigned ID.  Note: If using a CustomerChildID, you will also need a separate api_key for each child.  Any documents, checks, entities that are created when this field has been populated will now be tied to this CustomerID + CustomerChildID combination. Just as Customers cannot see data created by other Customers, so too a Customer's Children will not be able to see each other's data.  A Customer can see the documents/entities and checks of all their Children. 
        :type x_frankie_customer_child_id: str
        :param set: The status of an entity. Valid values are:   - \"wait\": Waiting for new details from entity.   - \"fail\": Manually fail the onboarding process.   - \"archived\": Hide entity from on onboarding.   - \"clear\": Remove any of the above manual states as well as any manual risk.   - \"inactive\": Hide entity and prevent any further operations on it. Cannot be cleared. 
        :type set: str
        :param risk: The risk override setting for an entity. This value will be used until a verify result updates a real risk factor. Valid values are:   - \"low\"   - \"medium\"   - \"high\"   - \"unacceptable\"   - \"significant\" 
        :type risk: str
        :param comment: A comment describing the reason for a request. 
        :type comment: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_entity_state_serialize(
            x_frankie_customer_id=x_frankie_customer_id,
            entity_id=entity_id,
            x_frankie_customer_child_id=x_frankie_customer_child_id,
            set=set,
            risk=risk,
            comment=comment,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CheckEntityCheckResultObject",
            '400': "ErrorObject",
            '401': "ErrorObject",
            '404': "ErrorObject",
            '405': "ErrorObject",
            '422': "ErrorObject",
            '429': "ErrorObject",
            '500': "ErrorObject",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def update_entity_state_with_http_info(
        self,
        x_frankie_customer_id: Annotated[StrictStr, Field(description="Customer ID issued by Frankie Financial. This will never change. Your API key, which is mapped to this identity, will change over time. ")],
        entity_id: Annotated[StrictStr, Field(description="The entityId returned previously from an earlier call to /check or /entity")],
        x_frankie_customer_child_id: Annotated[Optional[StrictStr], Field(description="If, as a Frankie Customer, you are acting on behalf of your own customers, then you can populate this field with a Frankie-assigned ID.  Note: If using a CustomerChildID, you will also need a separate api_key for each child.  Any documents, checks, entities that are created when this field has been populated will now be tied to this CustomerID + CustomerChildID combination. Just as Customers cannot see data created by other Customers, so too a Customer's Children will not be able to see each other's data.  A Customer can see the documents/entities and checks of all their Children. ")] = None,
        set: Annotated[Optional[StrictStr], Field(description="The status of an entity. Valid values are:   - \"wait\": Waiting for new details from entity.   - \"fail\": Manually fail the onboarding process.   - \"archived\": Hide entity from on onboarding.   - \"clear\": Remove any of the above manual states as well as any manual risk.   - \"inactive\": Hide entity and prevent any further operations on it. Cannot be cleared. ")] = None,
        risk: Annotated[Optional[StrictStr], Field(description="The risk override setting for an entity. This value will be used until a verify result updates a real risk factor. Valid values are:   - \"low\"   - \"medium\"   - \"high\"   - \"unacceptable\"   - \"significant\" ")] = None,
        comment: Annotated[Optional[StrictStr], Field(description="A comment describing the reason for a request. ")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[CheckEntityCheckResultObject]:
        """Update Entity States

        Internal only  Add a special internal 'entity result' to superceed any previous real checks until the next one. 

        :param x_frankie_customer_id: Customer ID issued by Frankie Financial. This will never change. Your API key, which is mapped to this identity, will change over time.  (required)
        :type x_frankie_customer_id: str
        :param entity_id: The entityId returned previously from an earlier call to /check or /entity (required)
        :type entity_id: str
        :param x_frankie_customer_child_id: If, as a Frankie Customer, you are acting on behalf of your own customers, then you can populate this field with a Frankie-assigned ID.  Note: If using a CustomerChildID, you will also need a separate api_key for each child.  Any documents, checks, entities that are created when this field has been populated will now be tied to this CustomerID + CustomerChildID combination. Just as Customers cannot see data created by other Customers, so too a Customer's Children will not be able to see each other's data.  A Customer can see the documents/entities and checks of all their Children. 
        :type x_frankie_customer_child_id: str
        :param set: The status of an entity. Valid values are:   - \"wait\": Waiting for new details from entity.   - \"fail\": Manually fail the onboarding process.   - \"archived\": Hide entity from on onboarding.   - \"clear\": Remove any of the above manual states as well as any manual risk.   - \"inactive\": Hide entity and prevent any further operations on it. Cannot be cleared. 
        :type set: str
        :param risk: The risk override setting for an entity. This value will be used until a verify result updates a real risk factor. Valid values are:   - \"low\"   - \"medium\"   - \"high\"   - \"unacceptable\"   - \"significant\" 
        :type risk: str
        :param comment: A comment describing the reason for a request. 
        :type comment: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_entity_state_serialize(
            x_frankie_customer_id=x_frankie_customer_id,
            entity_id=entity_id,
            x_frankie_customer_child_id=x_frankie_customer_child_id,
            set=set,
            risk=risk,
            comment=comment,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CheckEntityCheckResultObject",
            '400': "ErrorObject",
            '401': "ErrorObject",
            '404': "ErrorObject",
            '405': "ErrorObject",
            '422': "ErrorObject",
            '429': "ErrorObject",
            '500': "ErrorObject",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def update_entity_state_without_preload_content(
        self,
        x_frankie_customer_id: Annotated[StrictStr, Field(description="Customer ID issued by Frankie Financial. This will never change. Your API key, which is mapped to this identity, will change over time. ")],
        entity_id: Annotated[StrictStr, Field(description="The entityId returned previously from an earlier call to /check or /entity")],
        x_frankie_customer_child_id: Annotated[Optional[StrictStr], Field(description="If, as a Frankie Customer, you are acting on behalf of your own customers, then you can populate this field with a Frankie-assigned ID.  Note: If using a CustomerChildID, you will also need a separate api_key for each child.  Any documents, checks, entities that are created when this field has been populated will now be tied to this CustomerID + CustomerChildID combination. Just as Customers cannot see data created by other Customers, so too a Customer's Children will not be able to see each other's data.  A Customer can see the documents/entities and checks of all their Children. ")] = None,
        set: Annotated[Optional[StrictStr], Field(description="The status of an entity. Valid values are:   - \"wait\": Waiting for new details from entity.   - \"fail\": Manually fail the onboarding process.   - \"archived\": Hide entity from on onboarding.   - \"clear\": Remove any of the above manual states as well as any manual risk.   - \"inactive\": Hide entity and prevent any further operations on it. Cannot be cleared. ")] = None,
        risk: Annotated[Optional[StrictStr], Field(description="The risk override setting for an entity. This value will be used until a verify result updates a real risk factor. Valid values are:   - \"low\"   - \"medium\"   - \"high\"   - \"unacceptable\"   - \"significant\" ")] = None,
        comment: Annotated[Optional[StrictStr], Field(description="A comment describing the reason for a request. ")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Update Entity States

        Internal only  Add a special internal 'entity result' to superceed any previous real checks until the next one. 

        :param x_frankie_customer_id: Customer ID issued by Frankie Financial. This will never change. Your API key, which is mapped to this identity, will change over time.  (required)
        :type x_frankie_customer_id: str
        :param entity_id: The entityId returned previously from an earlier call to /check or /entity (required)
        :type entity_id: str
        :param x_frankie_customer_child_id: If, as a Frankie Customer, you are acting on behalf of your own customers, then you can populate this field with a Frankie-assigned ID.  Note: If using a CustomerChildID, you will also need a separate api_key for each child.  Any documents, checks, entities that are created when this field has been populated will now be tied to this CustomerID + CustomerChildID combination. Just as Customers cannot see data created by other Customers, so too a Customer's Children will not be able to see each other's data.  A Customer can see the documents/entities and checks of all their Children. 
        :type x_frankie_customer_child_id: str
        :param set: The status of an entity. Valid values are:   - \"wait\": Waiting for new details from entity.   - \"fail\": Manually fail the onboarding process.   - \"archived\": Hide entity from on onboarding.   - \"clear\": Remove any of the above manual states as well as any manual risk.   - \"inactive\": Hide entity and prevent any further operations on it. Cannot be cleared. 
        :type set: str
        :param risk: The risk override setting for an entity. This value will be used until a verify result updates a real risk factor. Valid values are:   - \"low\"   - \"medium\"   - \"high\"   - \"unacceptable\"   - \"significant\" 
        :type risk: str
        :param comment: A comment describing the reason for a request. 
        :type comment: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_entity_state_serialize(
            x_frankie_customer_id=x_frankie_customer_id,
            entity_id=entity_id,
            x_frankie_customer_child_id=x_frankie_customer_child_id,
            set=set,
            risk=risk,
            comment=comment,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CheckEntityCheckResultObject",
            '400': "ErrorObject",
            '401': "ErrorObject",
            '404': "ErrorObject",
            '405': "ErrorObject",
            '422': "ErrorObject",
            '429': "ErrorObject",
            '500': "ErrorObject",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _update_entity_state_serialize(
        self,
        x_frankie_customer_id,
        entity_id,
        x_frankie_customer_child_id,
        set,
        risk,
        comment,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if entity_id is not None:
            _path_params['entityId'] = entity_id
        # process the query parameters
        if set is not None:
            
            _query_params.append(('set', set))
            
        if risk is not None:
            
            _query_params.append(('risk', risk))
            
        if comment is not None:
            
            _query_params.append(('comment', comment))
            
        # process the header parameters
        if x_frankie_customer_id is not None:
            _header_params['X-Frankie-CustomerID'] = x_frankie_customer_id
        if x_frankie_customer_child_id is not None:
            _header_params['X-Frankie-CustomerChildID'] = x_frankie_customer_child_id
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'api_key'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/entity/{entityId}/status',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )


