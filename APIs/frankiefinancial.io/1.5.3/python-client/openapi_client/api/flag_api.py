# coding: utf-8

"""
    Frankie Financial API

    ------   This API allows developers to integrate the Frankie Financial Compliance Utility into their applications. The API allows:   - Checking name, address, date of birth against national databases   - Validating Australian driver's licences, passports, medicare, visas and other Australian national ID documents   - Validating Australian electricity bills   - Validating NZ driver's licences   - Validating Chinese bank cards and national ID card   - Validating International passports and national ID documents   - PEP, Sanctions, Watchlist and adverse media checking   - Australian visa checks    - Fraud list and fraud background checks   - ID validation and selfie check comparisons.    ------     Industry specific services    - Comparing Australian electricity retailers for a better deal.  ------     KYB specific services    - Query organisation ownership   - Perform KYC & AML checks on shareholders, beneficial owners and office bearers.   - Query credit score and credit reports   - International company searches   - International company profiles    ------   The full version of this documentation along with supplemental articles can be found here:   - https://apidocs.frankiefinancial.com/  The traditional Swagger view of this documentation can be found here:   - https://app.swaggerhub.com/apis-docs/FrankieFinancial/kycutility  ------   Sandbox base URL is:   - https://api.demo.frankiefinancial.io/compliance/v1.2      - We do have an old sandbox at https://sandbox.frankiefinancial.com/compliance/v1.2 but this has been retired.    - All calls are the same as production, only with canned data.     - Full Swagger definition, along with test data for playing in the sandbox can be obtained once initial commercial discussions have commenced.    - Production and optional UAT access will be opened up only to those with a signed commercial contract.    ------   Contact us at hello@frankiefinancial.com to speak with a sales rep about issuing a Customer ID and Sandbox api key. 

    The version of the OpenAPI document: 1.5.3
    Contact: dev-support@frankiefinancial.com
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501

import warnings
from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
from typing import Any, Dict, List, Optional, Tuple, Union
from typing_extensions import Annotated

from pydantic import Field, StrictBool, StrictStr
from typing import Optional
from typing_extensions import Annotated
from openapi_client.models.entity_result_object import EntityResultObject

from openapi_client.api_client import ApiClient, RequestSerialized
from openapi_client.api_response import ApiResponse
from openapi_client.rest import RESTResponseType


class FlagApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client


    @validate_call
    def blacklist_entity(
        self,
        x_frankie_customer_id: Annotated[StrictStr, Field(description="Customer ID issued by Frankie Financial. This will never change. Your API key, which is mapped to this identity, will change over time. ")],
        entity_id: Annotated[StrictStr, Field(description="The entityId returned previously from an earlier call to /check or /entity")],
        set: Annotated[StrictBool, Field(description="Set the value of an entity flag. ")],
        x_frankie_customer_child_id: Annotated[Optional[StrictStr], Field(description="If, as a Frankie Customer, you are acting on behalf of your own customers, then you can populate this field with a Frankie-assigned ID.  Note: If using a CustomerChildID, you will also need a separate api_key for each child.  Any documents, checks, entities that are created when this field has been populated will now be tied to this CustomerID + CustomerChildID combination. Just as Customers cannot see data created by other Customers, so too a Customer's Children will not be able to see each other's data.  A Customer can see the documents/entities and checks of all their Children. ")] = None,
        reason: Annotated[Optional[StrictStr], Field(description="Set the reason for blacklisting. Valid values are:   - \"NO_REASON_SUPPLIED\"   - \"FABRICATED_IDENTITY\"   - \"IDENTITY_TAKEOVER\"   - \"FALSIFIED_ID_DOCUMENTS\"   - \"STOLEN_ID_DOCUMENTS\"   - \"MERCHANT_FRAUD\"   - \"NEVER_PAY_BUST_OUT\"   - \"CONFLICTING_DATA_PROVIDED\"   - \"MONEY_MULE\"   - \"FALSE_FRAUD_CLAIM\"   - \"FRAUDULENT_3RD_PARTY\"   - \"COMPANY_TAKEOVER\"   - \"FICTITIOUS_EMPLOYER\"   - \"COLLUSIVE_EMPLOYER\"   - \"OVER_VALUATION_OF_ASSETS\"   - \"FALSIFIED_EMPLOYMENT_DETAILS\"   - \"MANIPULATED_IDENTITY\"   - \"SYNDICATED_FRAUD\"   - \"INTERNAL_FRAUD\"   - \"BANK_FRAUD\"   - \"UNDISCLOSED_DATA\"   - \"FALSE_HARDSHIP\"   - \"SMR_REPORT_LODGED\"   - \"2X_SMR_REPORTS_LODGED\" ")] = None,
        blocked_by: Annotated[Optional[StrictStr], Field(description="Specify who is setting the entity as blacklisted. ")] = None,
        attribute: Annotated[Optional[StrictStr], Field(description="Specify the blacklisted attribute. Valid values are:   - \"ENTIRE_PROFILE\"   - \"FULL_NAME\"   - \"EMAIL_ADDRESS\"   - \"PHONE_NUMBER\"   - \"ID_DOCUMENT\"   - \"MAILING_ADDRESS\"   - \"RESIDENTIAL_ADDRESS\"    ")] = None,
        original_id: Annotated[Optional[StrictStr], Field(description="Specify the Id of the matching blacklisted entity or single data-point. ")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> EntityResultObject:
        """Set Entity Blacklist State.

        Mark the entity as blacklisted or not with the '?set=' query parameter as 'true' or 'false'. 

        :param x_frankie_customer_id: Customer ID issued by Frankie Financial. This will never change. Your API key, which is mapped to this identity, will change over time.  (required)
        :type x_frankie_customer_id: str
        :param entity_id: The entityId returned previously from an earlier call to /check or /entity (required)
        :type entity_id: str
        :param set: Set the value of an entity flag.  (required)
        :type set: bool
        :param x_frankie_customer_child_id: If, as a Frankie Customer, you are acting on behalf of your own customers, then you can populate this field with a Frankie-assigned ID.  Note: If using a CustomerChildID, you will also need a separate api_key for each child.  Any documents, checks, entities that are created when this field has been populated will now be tied to this CustomerID + CustomerChildID combination. Just as Customers cannot see data created by other Customers, so too a Customer's Children will not be able to see each other's data.  A Customer can see the documents/entities and checks of all their Children. 
        :type x_frankie_customer_child_id: str
        :param reason: Set the reason for blacklisting. Valid values are:   - \"NO_REASON_SUPPLIED\"   - \"FABRICATED_IDENTITY\"   - \"IDENTITY_TAKEOVER\"   - \"FALSIFIED_ID_DOCUMENTS\"   - \"STOLEN_ID_DOCUMENTS\"   - \"MERCHANT_FRAUD\"   - \"NEVER_PAY_BUST_OUT\"   - \"CONFLICTING_DATA_PROVIDED\"   - \"MONEY_MULE\"   - \"FALSE_FRAUD_CLAIM\"   - \"FRAUDULENT_3RD_PARTY\"   - \"COMPANY_TAKEOVER\"   - \"FICTITIOUS_EMPLOYER\"   - \"COLLUSIVE_EMPLOYER\"   - \"OVER_VALUATION_OF_ASSETS\"   - \"FALSIFIED_EMPLOYMENT_DETAILS\"   - \"MANIPULATED_IDENTITY\"   - \"SYNDICATED_FRAUD\"   - \"INTERNAL_FRAUD\"   - \"BANK_FRAUD\"   - \"UNDISCLOSED_DATA\"   - \"FALSE_HARDSHIP\"   - \"SMR_REPORT_LODGED\"   - \"2X_SMR_REPORTS_LODGED\" 
        :type reason: str
        :param blocked_by: Specify who is setting the entity as blacklisted. 
        :type blocked_by: str
        :param attribute: Specify the blacklisted attribute. Valid values are:   - \"ENTIRE_PROFILE\"   - \"FULL_NAME\"   - \"EMAIL_ADDRESS\"   - \"PHONE_NUMBER\"   - \"ID_DOCUMENT\"   - \"MAILING_ADDRESS\"   - \"RESIDENTIAL_ADDRESS\"    
        :type attribute: str
        :param original_id: Specify the Id of the matching blacklisted entity or single data-point. 
        :type original_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._blacklist_entity_serialize(
            x_frankie_customer_id=x_frankie_customer_id,
            entity_id=entity_id,
            set=set,
            x_frankie_customer_child_id=x_frankie_customer_child_id,
            reason=reason,
            blocked_by=blocked_by,
            attribute=attribute,
            original_id=original_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "EntityResultObject",
            '400': "ErrorObject",
            '401': "ErrorObject",
            '404': "ErrorObject",
            '429': "ErrorObject",
            '500': "ErrorObject",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def blacklist_entity_with_http_info(
        self,
        x_frankie_customer_id: Annotated[StrictStr, Field(description="Customer ID issued by Frankie Financial. This will never change. Your API key, which is mapped to this identity, will change over time. ")],
        entity_id: Annotated[StrictStr, Field(description="The entityId returned previously from an earlier call to /check or /entity")],
        set: Annotated[StrictBool, Field(description="Set the value of an entity flag. ")],
        x_frankie_customer_child_id: Annotated[Optional[StrictStr], Field(description="If, as a Frankie Customer, you are acting on behalf of your own customers, then you can populate this field with a Frankie-assigned ID.  Note: If using a CustomerChildID, you will also need a separate api_key for each child.  Any documents, checks, entities that are created when this field has been populated will now be tied to this CustomerID + CustomerChildID combination. Just as Customers cannot see data created by other Customers, so too a Customer's Children will not be able to see each other's data.  A Customer can see the documents/entities and checks of all their Children. ")] = None,
        reason: Annotated[Optional[StrictStr], Field(description="Set the reason for blacklisting. Valid values are:   - \"NO_REASON_SUPPLIED\"   - \"FABRICATED_IDENTITY\"   - \"IDENTITY_TAKEOVER\"   - \"FALSIFIED_ID_DOCUMENTS\"   - \"STOLEN_ID_DOCUMENTS\"   - \"MERCHANT_FRAUD\"   - \"NEVER_PAY_BUST_OUT\"   - \"CONFLICTING_DATA_PROVIDED\"   - \"MONEY_MULE\"   - \"FALSE_FRAUD_CLAIM\"   - \"FRAUDULENT_3RD_PARTY\"   - \"COMPANY_TAKEOVER\"   - \"FICTITIOUS_EMPLOYER\"   - \"COLLUSIVE_EMPLOYER\"   - \"OVER_VALUATION_OF_ASSETS\"   - \"FALSIFIED_EMPLOYMENT_DETAILS\"   - \"MANIPULATED_IDENTITY\"   - \"SYNDICATED_FRAUD\"   - \"INTERNAL_FRAUD\"   - \"BANK_FRAUD\"   - \"UNDISCLOSED_DATA\"   - \"FALSE_HARDSHIP\"   - \"SMR_REPORT_LODGED\"   - \"2X_SMR_REPORTS_LODGED\" ")] = None,
        blocked_by: Annotated[Optional[StrictStr], Field(description="Specify who is setting the entity as blacklisted. ")] = None,
        attribute: Annotated[Optional[StrictStr], Field(description="Specify the blacklisted attribute. Valid values are:   - \"ENTIRE_PROFILE\"   - \"FULL_NAME\"   - \"EMAIL_ADDRESS\"   - \"PHONE_NUMBER\"   - \"ID_DOCUMENT\"   - \"MAILING_ADDRESS\"   - \"RESIDENTIAL_ADDRESS\"    ")] = None,
        original_id: Annotated[Optional[StrictStr], Field(description="Specify the Id of the matching blacklisted entity or single data-point. ")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[EntityResultObject]:
        """Set Entity Blacklist State.

        Mark the entity as blacklisted or not with the '?set=' query parameter as 'true' or 'false'. 

        :param x_frankie_customer_id: Customer ID issued by Frankie Financial. This will never change. Your API key, which is mapped to this identity, will change over time.  (required)
        :type x_frankie_customer_id: str
        :param entity_id: The entityId returned previously from an earlier call to /check or /entity (required)
        :type entity_id: str
        :param set: Set the value of an entity flag.  (required)
        :type set: bool
        :param x_frankie_customer_child_id: If, as a Frankie Customer, you are acting on behalf of your own customers, then you can populate this field with a Frankie-assigned ID.  Note: If using a CustomerChildID, you will also need a separate api_key for each child.  Any documents, checks, entities that are created when this field has been populated will now be tied to this CustomerID + CustomerChildID combination. Just as Customers cannot see data created by other Customers, so too a Customer's Children will not be able to see each other's data.  A Customer can see the documents/entities and checks of all their Children. 
        :type x_frankie_customer_child_id: str
        :param reason: Set the reason for blacklisting. Valid values are:   - \"NO_REASON_SUPPLIED\"   - \"FABRICATED_IDENTITY\"   - \"IDENTITY_TAKEOVER\"   - \"FALSIFIED_ID_DOCUMENTS\"   - \"STOLEN_ID_DOCUMENTS\"   - \"MERCHANT_FRAUD\"   - \"NEVER_PAY_BUST_OUT\"   - \"CONFLICTING_DATA_PROVIDED\"   - \"MONEY_MULE\"   - \"FALSE_FRAUD_CLAIM\"   - \"FRAUDULENT_3RD_PARTY\"   - \"COMPANY_TAKEOVER\"   - \"FICTITIOUS_EMPLOYER\"   - \"COLLUSIVE_EMPLOYER\"   - \"OVER_VALUATION_OF_ASSETS\"   - \"FALSIFIED_EMPLOYMENT_DETAILS\"   - \"MANIPULATED_IDENTITY\"   - \"SYNDICATED_FRAUD\"   - \"INTERNAL_FRAUD\"   - \"BANK_FRAUD\"   - \"UNDISCLOSED_DATA\"   - \"FALSE_HARDSHIP\"   - \"SMR_REPORT_LODGED\"   - \"2X_SMR_REPORTS_LODGED\" 
        :type reason: str
        :param blocked_by: Specify who is setting the entity as blacklisted. 
        :type blocked_by: str
        :param attribute: Specify the blacklisted attribute. Valid values are:   - \"ENTIRE_PROFILE\"   - \"FULL_NAME\"   - \"EMAIL_ADDRESS\"   - \"PHONE_NUMBER\"   - \"ID_DOCUMENT\"   - \"MAILING_ADDRESS\"   - \"RESIDENTIAL_ADDRESS\"    
        :type attribute: str
        :param original_id: Specify the Id of the matching blacklisted entity or single data-point. 
        :type original_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._blacklist_entity_serialize(
            x_frankie_customer_id=x_frankie_customer_id,
            entity_id=entity_id,
            set=set,
            x_frankie_customer_child_id=x_frankie_customer_child_id,
            reason=reason,
            blocked_by=blocked_by,
            attribute=attribute,
            original_id=original_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "EntityResultObject",
            '400': "ErrorObject",
            '401': "ErrorObject",
            '404': "ErrorObject",
            '429': "ErrorObject",
            '500': "ErrorObject",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def blacklist_entity_without_preload_content(
        self,
        x_frankie_customer_id: Annotated[StrictStr, Field(description="Customer ID issued by Frankie Financial. This will never change. Your API key, which is mapped to this identity, will change over time. ")],
        entity_id: Annotated[StrictStr, Field(description="The entityId returned previously from an earlier call to /check or /entity")],
        set: Annotated[StrictBool, Field(description="Set the value of an entity flag. ")],
        x_frankie_customer_child_id: Annotated[Optional[StrictStr], Field(description="If, as a Frankie Customer, you are acting on behalf of your own customers, then you can populate this field with a Frankie-assigned ID.  Note: If using a CustomerChildID, you will also need a separate api_key for each child.  Any documents, checks, entities that are created when this field has been populated will now be tied to this CustomerID + CustomerChildID combination. Just as Customers cannot see data created by other Customers, so too a Customer's Children will not be able to see each other's data.  A Customer can see the documents/entities and checks of all their Children. ")] = None,
        reason: Annotated[Optional[StrictStr], Field(description="Set the reason for blacklisting. Valid values are:   - \"NO_REASON_SUPPLIED\"   - \"FABRICATED_IDENTITY\"   - \"IDENTITY_TAKEOVER\"   - \"FALSIFIED_ID_DOCUMENTS\"   - \"STOLEN_ID_DOCUMENTS\"   - \"MERCHANT_FRAUD\"   - \"NEVER_PAY_BUST_OUT\"   - \"CONFLICTING_DATA_PROVIDED\"   - \"MONEY_MULE\"   - \"FALSE_FRAUD_CLAIM\"   - \"FRAUDULENT_3RD_PARTY\"   - \"COMPANY_TAKEOVER\"   - \"FICTITIOUS_EMPLOYER\"   - \"COLLUSIVE_EMPLOYER\"   - \"OVER_VALUATION_OF_ASSETS\"   - \"FALSIFIED_EMPLOYMENT_DETAILS\"   - \"MANIPULATED_IDENTITY\"   - \"SYNDICATED_FRAUD\"   - \"INTERNAL_FRAUD\"   - \"BANK_FRAUD\"   - \"UNDISCLOSED_DATA\"   - \"FALSE_HARDSHIP\"   - \"SMR_REPORT_LODGED\"   - \"2X_SMR_REPORTS_LODGED\" ")] = None,
        blocked_by: Annotated[Optional[StrictStr], Field(description="Specify who is setting the entity as blacklisted. ")] = None,
        attribute: Annotated[Optional[StrictStr], Field(description="Specify the blacklisted attribute. Valid values are:   - \"ENTIRE_PROFILE\"   - \"FULL_NAME\"   - \"EMAIL_ADDRESS\"   - \"PHONE_NUMBER\"   - \"ID_DOCUMENT\"   - \"MAILING_ADDRESS\"   - \"RESIDENTIAL_ADDRESS\"    ")] = None,
        original_id: Annotated[Optional[StrictStr], Field(description="Specify the Id of the matching blacklisted entity or single data-point. ")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Set Entity Blacklist State.

        Mark the entity as blacklisted or not with the '?set=' query parameter as 'true' or 'false'. 

        :param x_frankie_customer_id: Customer ID issued by Frankie Financial. This will never change. Your API key, which is mapped to this identity, will change over time.  (required)
        :type x_frankie_customer_id: str
        :param entity_id: The entityId returned previously from an earlier call to /check or /entity (required)
        :type entity_id: str
        :param set: Set the value of an entity flag.  (required)
        :type set: bool
        :param x_frankie_customer_child_id: If, as a Frankie Customer, you are acting on behalf of your own customers, then you can populate this field with a Frankie-assigned ID.  Note: If using a CustomerChildID, you will also need a separate api_key for each child.  Any documents, checks, entities that are created when this field has been populated will now be tied to this CustomerID + CustomerChildID combination. Just as Customers cannot see data created by other Customers, so too a Customer's Children will not be able to see each other's data.  A Customer can see the documents/entities and checks of all their Children. 
        :type x_frankie_customer_child_id: str
        :param reason: Set the reason for blacklisting. Valid values are:   - \"NO_REASON_SUPPLIED\"   - \"FABRICATED_IDENTITY\"   - \"IDENTITY_TAKEOVER\"   - \"FALSIFIED_ID_DOCUMENTS\"   - \"STOLEN_ID_DOCUMENTS\"   - \"MERCHANT_FRAUD\"   - \"NEVER_PAY_BUST_OUT\"   - \"CONFLICTING_DATA_PROVIDED\"   - \"MONEY_MULE\"   - \"FALSE_FRAUD_CLAIM\"   - \"FRAUDULENT_3RD_PARTY\"   - \"COMPANY_TAKEOVER\"   - \"FICTITIOUS_EMPLOYER\"   - \"COLLUSIVE_EMPLOYER\"   - \"OVER_VALUATION_OF_ASSETS\"   - \"FALSIFIED_EMPLOYMENT_DETAILS\"   - \"MANIPULATED_IDENTITY\"   - \"SYNDICATED_FRAUD\"   - \"INTERNAL_FRAUD\"   - \"BANK_FRAUD\"   - \"UNDISCLOSED_DATA\"   - \"FALSE_HARDSHIP\"   - \"SMR_REPORT_LODGED\"   - \"2X_SMR_REPORTS_LODGED\" 
        :type reason: str
        :param blocked_by: Specify who is setting the entity as blacklisted. 
        :type blocked_by: str
        :param attribute: Specify the blacklisted attribute. Valid values are:   - \"ENTIRE_PROFILE\"   - \"FULL_NAME\"   - \"EMAIL_ADDRESS\"   - \"PHONE_NUMBER\"   - \"ID_DOCUMENT\"   - \"MAILING_ADDRESS\"   - \"RESIDENTIAL_ADDRESS\"    
        :type attribute: str
        :param original_id: Specify the Id of the matching blacklisted entity or single data-point. 
        :type original_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._blacklist_entity_serialize(
            x_frankie_customer_id=x_frankie_customer_id,
            entity_id=entity_id,
            set=set,
            x_frankie_customer_child_id=x_frankie_customer_child_id,
            reason=reason,
            blocked_by=blocked_by,
            attribute=attribute,
            original_id=original_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "EntityResultObject",
            '400': "ErrorObject",
            '401': "ErrorObject",
            '404': "ErrorObject",
            '429': "ErrorObject",
            '500': "ErrorObject",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _blacklist_entity_serialize(
        self,
        x_frankie_customer_id,
        entity_id,
        set,
        x_frankie_customer_child_id,
        reason,
        blocked_by,
        attribute,
        original_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if entity_id is not None:
            _path_params['entityId'] = entity_id
        # process the query parameters
        if set is not None:
            
            _query_params.append(('set', set))
            
        if reason is not None:
            
            _query_params.append(('reason', reason))
            
        if blocked_by is not None:
            
            _query_params.append(('blockedBy', blocked_by))
            
        if attribute is not None:
            
            _query_params.append(('attribute', attribute))
            
        if original_id is not None:
            
            _query_params.append(('originalId', original_id))
            
        # process the header parameters
        if x_frankie_customer_id is not None:
            _header_params['X-Frankie-CustomerID'] = x_frankie_customer_id
        if x_frankie_customer_child_id is not None:
            _header_params['X-Frankie-CustomerChildID'] = x_frankie_customer_child_id
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'api_key'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/entity/{entityId}/flag/blacklist',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def entity_monitoring(
        self,
        x_frankie_customer_id: Annotated[StrictStr, Field(description="Customer ID issued by Frankie Financial. This will never change. Your API key, which is mapped to this identity, will change over time. ")],
        entity_id: Annotated[StrictStr, Field(description="The entityId returned previously from an earlier call to /check or /entity")],
        set: Annotated[StrictBool, Field(description="Set the value of an entity flag. ")],
        x_frankie_customer_child_id: Annotated[Optional[StrictStr], Field(description="If, as a Frankie Customer, you are acting on behalf of your own customers, then you can populate this field with a Frankie-assigned ID.  Note: If using a CustomerChildID, you will also need a separate api_key for each child.  Any documents, checks, entities that are created when this field has been populated will now be tied to this CustomerID + CustomerChildID combination. Just as Customers cannot see data created by other Customers, so too a Customer's Children will not be able to see each other's data.  A Customer can see the documents/entities and checks of all their Children. ")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> EntityResultObject:
        """Set Entity Ongoing AML Monitoring Status.

        Mark the entity as being monitored or not with the '?set=' query parameter as 'true' or 'false'. 

        :param x_frankie_customer_id: Customer ID issued by Frankie Financial. This will never change. Your API key, which is mapped to this identity, will change over time.  (required)
        :type x_frankie_customer_id: str
        :param entity_id: The entityId returned previously from an earlier call to /check or /entity (required)
        :type entity_id: str
        :param set: Set the value of an entity flag.  (required)
        :type set: bool
        :param x_frankie_customer_child_id: If, as a Frankie Customer, you are acting on behalf of your own customers, then you can populate this field with a Frankie-assigned ID.  Note: If using a CustomerChildID, you will also need a separate api_key for each child.  Any documents, checks, entities that are created when this field has been populated will now be tied to this CustomerID + CustomerChildID combination. Just as Customers cannot see data created by other Customers, so too a Customer's Children will not be able to see each other's data.  A Customer can see the documents/entities and checks of all their Children. 
        :type x_frankie_customer_child_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._entity_monitoring_serialize(
            x_frankie_customer_id=x_frankie_customer_id,
            entity_id=entity_id,
            set=set,
            x_frankie_customer_child_id=x_frankie_customer_child_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "EntityResultObject",
            '400': "ErrorObject",
            '401': "ErrorObject",
            '404': "ErrorObject",
            '429': "ErrorObject",
            '500': "ErrorObject",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def entity_monitoring_with_http_info(
        self,
        x_frankie_customer_id: Annotated[StrictStr, Field(description="Customer ID issued by Frankie Financial. This will never change. Your API key, which is mapped to this identity, will change over time. ")],
        entity_id: Annotated[StrictStr, Field(description="The entityId returned previously from an earlier call to /check or /entity")],
        set: Annotated[StrictBool, Field(description="Set the value of an entity flag. ")],
        x_frankie_customer_child_id: Annotated[Optional[StrictStr], Field(description="If, as a Frankie Customer, you are acting on behalf of your own customers, then you can populate this field with a Frankie-assigned ID.  Note: If using a CustomerChildID, you will also need a separate api_key for each child.  Any documents, checks, entities that are created when this field has been populated will now be tied to this CustomerID + CustomerChildID combination. Just as Customers cannot see data created by other Customers, so too a Customer's Children will not be able to see each other's data.  A Customer can see the documents/entities and checks of all their Children. ")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[EntityResultObject]:
        """Set Entity Ongoing AML Monitoring Status.

        Mark the entity as being monitored or not with the '?set=' query parameter as 'true' or 'false'. 

        :param x_frankie_customer_id: Customer ID issued by Frankie Financial. This will never change. Your API key, which is mapped to this identity, will change over time.  (required)
        :type x_frankie_customer_id: str
        :param entity_id: The entityId returned previously from an earlier call to /check or /entity (required)
        :type entity_id: str
        :param set: Set the value of an entity flag.  (required)
        :type set: bool
        :param x_frankie_customer_child_id: If, as a Frankie Customer, you are acting on behalf of your own customers, then you can populate this field with a Frankie-assigned ID.  Note: If using a CustomerChildID, you will also need a separate api_key for each child.  Any documents, checks, entities that are created when this field has been populated will now be tied to this CustomerID + CustomerChildID combination. Just as Customers cannot see data created by other Customers, so too a Customer's Children will not be able to see each other's data.  A Customer can see the documents/entities and checks of all their Children. 
        :type x_frankie_customer_child_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._entity_monitoring_serialize(
            x_frankie_customer_id=x_frankie_customer_id,
            entity_id=entity_id,
            set=set,
            x_frankie_customer_child_id=x_frankie_customer_child_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "EntityResultObject",
            '400': "ErrorObject",
            '401': "ErrorObject",
            '404': "ErrorObject",
            '429': "ErrorObject",
            '500': "ErrorObject",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def entity_monitoring_without_preload_content(
        self,
        x_frankie_customer_id: Annotated[StrictStr, Field(description="Customer ID issued by Frankie Financial. This will never change. Your API key, which is mapped to this identity, will change over time. ")],
        entity_id: Annotated[StrictStr, Field(description="The entityId returned previously from an earlier call to /check or /entity")],
        set: Annotated[StrictBool, Field(description="Set the value of an entity flag. ")],
        x_frankie_customer_child_id: Annotated[Optional[StrictStr], Field(description="If, as a Frankie Customer, you are acting on behalf of your own customers, then you can populate this field with a Frankie-assigned ID.  Note: If using a CustomerChildID, you will also need a separate api_key for each child.  Any documents, checks, entities that are created when this field has been populated will now be tied to this CustomerID + CustomerChildID combination. Just as Customers cannot see data created by other Customers, so too a Customer's Children will not be able to see each other's data.  A Customer can see the documents/entities and checks of all their Children. ")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Set Entity Ongoing AML Monitoring Status.

        Mark the entity as being monitored or not with the '?set=' query parameter as 'true' or 'false'. 

        :param x_frankie_customer_id: Customer ID issued by Frankie Financial. This will never change. Your API key, which is mapped to this identity, will change over time.  (required)
        :type x_frankie_customer_id: str
        :param entity_id: The entityId returned previously from an earlier call to /check or /entity (required)
        :type entity_id: str
        :param set: Set the value of an entity flag.  (required)
        :type set: bool
        :param x_frankie_customer_child_id: If, as a Frankie Customer, you are acting on behalf of your own customers, then you can populate this field with a Frankie-assigned ID.  Note: If using a CustomerChildID, you will also need a separate api_key for each child.  Any documents, checks, entities that are created when this field has been populated will now be tied to this CustomerID + CustomerChildID combination. Just as Customers cannot see data created by other Customers, so too a Customer's Children will not be able to see each other's data.  A Customer can see the documents/entities and checks of all their Children. 
        :type x_frankie_customer_child_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._entity_monitoring_serialize(
            x_frankie_customer_id=x_frankie_customer_id,
            entity_id=entity_id,
            set=set,
            x_frankie_customer_child_id=x_frankie_customer_child_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "EntityResultObject",
            '400': "ErrorObject",
            '401': "ErrorObject",
            '404': "ErrorObject",
            '429': "ErrorObject",
            '500': "ErrorObject",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _entity_monitoring_serialize(
        self,
        x_frankie_customer_id,
        entity_id,
        set,
        x_frankie_customer_child_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if entity_id is not None:
            _path_params['entityId'] = entity_id
        # process the query parameters
        if set is not None:
            
            _query_params.append(('set', set))
            
        # process the header parameters
        if x_frankie_customer_id is not None:
            _header_params['X-Frankie-CustomerID'] = x_frankie_customer_id
        if x_frankie_customer_child_id is not None:
            _header_params['X-Frankie-CustomerChildID'] = x_frankie_customer_child_id
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'api_key'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/entity/{entityId}/flag/monitor',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def flag_duplicate_entity(
        self,
        x_frankie_customer_id: Annotated[StrictStr, Field(description="Customer ID issued by Frankie Financial. This will never change. Your API key, which is mapped to this identity, will change over time. ")],
        entity_id: Annotated[StrictStr, Field(description="The entityId returned previously from an earlier call to /check or /entity")],
        other_id: Annotated[StrictStr, Field(description="An entityId returned previously from an earlier call to /check or /entity. Used when an operation requires two entityIds")],
        set: Annotated[StrictBool, Field(description="Set the value of an entity flag. ")],
        x_frankie_customer_child_id: Annotated[Optional[StrictStr], Field(description="If, as a Frankie Customer, you are acting on behalf of your own customers, then you can populate this field with a Frankie-assigned ID.  Note: If using a CustomerChildID, you will also need a separate api_key for each child.  Any documents, checks, entities that are created when this field has been populated will now be tied to this CustomerID + CustomerChildID combination. Just as Customers cannot see data created by other Customers, so too a Customer's Children will not be able to see each other's data.  A Customer can see the documents/entities and checks of all their Children. ")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> EntityResultObject:
        """Resolve Duplicate States.

        Resolve the state of a pair of duplicate entities with the '?set=' query parameter as 'true' or 'false'. Setting duplicate to 'true' will make entityId invisible for most purposes and otherId will continue to function as normal. Setting duplicate to 'false' means the two entities are in fact separate but similar and they will both continue to exist independently but will no longer be identified as duplicates of eachother. 

        :param x_frankie_customer_id: Customer ID issued by Frankie Financial. This will never change. Your API key, which is mapped to this identity, will change over time.  (required)
        :type x_frankie_customer_id: str
        :param entity_id: The entityId returned previously from an earlier call to /check or /entity (required)
        :type entity_id: str
        :param other_id: An entityId returned previously from an earlier call to /check or /entity. Used when an operation requires two entityIds (required)
        :type other_id: str
        :param set: Set the value of an entity flag.  (required)
        :type set: bool
        :param x_frankie_customer_child_id: If, as a Frankie Customer, you are acting on behalf of your own customers, then you can populate this field with a Frankie-assigned ID.  Note: If using a CustomerChildID, you will also need a separate api_key for each child.  Any documents, checks, entities that are created when this field has been populated will now be tied to this CustomerID + CustomerChildID combination. Just as Customers cannot see data created by other Customers, so too a Customer's Children will not be able to see each other's data.  A Customer can see the documents/entities and checks of all their Children. 
        :type x_frankie_customer_child_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._flag_duplicate_entity_serialize(
            x_frankie_customer_id=x_frankie_customer_id,
            entity_id=entity_id,
            other_id=other_id,
            set=set,
            x_frankie_customer_child_id=x_frankie_customer_child_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "EntityResultObject",
            '400': "ErrorObject",
            '401': "ErrorObject",
            '404': "ErrorObject",
            '429': "ErrorObject",
            '500': "ErrorObject",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def flag_duplicate_entity_with_http_info(
        self,
        x_frankie_customer_id: Annotated[StrictStr, Field(description="Customer ID issued by Frankie Financial. This will never change. Your API key, which is mapped to this identity, will change over time. ")],
        entity_id: Annotated[StrictStr, Field(description="The entityId returned previously from an earlier call to /check or /entity")],
        other_id: Annotated[StrictStr, Field(description="An entityId returned previously from an earlier call to /check or /entity. Used when an operation requires two entityIds")],
        set: Annotated[StrictBool, Field(description="Set the value of an entity flag. ")],
        x_frankie_customer_child_id: Annotated[Optional[StrictStr], Field(description="If, as a Frankie Customer, you are acting on behalf of your own customers, then you can populate this field with a Frankie-assigned ID.  Note: If using a CustomerChildID, you will also need a separate api_key for each child.  Any documents, checks, entities that are created when this field has been populated will now be tied to this CustomerID + CustomerChildID combination. Just as Customers cannot see data created by other Customers, so too a Customer's Children will not be able to see each other's data.  A Customer can see the documents/entities and checks of all their Children. ")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[EntityResultObject]:
        """Resolve Duplicate States.

        Resolve the state of a pair of duplicate entities with the '?set=' query parameter as 'true' or 'false'. Setting duplicate to 'true' will make entityId invisible for most purposes and otherId will continue to function as normal. Setting duplicate to 'false' means the two entities are in fact separate but similar and they will both continue to exist independently but will no longer be identified as duplicates of eachother. 

        :param x_frankie_customer_id: Customer ID issued by Frankie Financial. This will never change. Your API key, which is mapped to this identity, will change over time.  (required)
        :type x_frankie_customer_id: str
        :param entity_id: The entityId returned previously from an earlier call to /check or /entity (required)
        :type entity_id: str
        :param other_id: An entityId returned previously from an earlier call to /check or /entity. Used when an operation requires two entityIds (required)
        :type other_id: str
        :param set: Set the value of an entity flag.  (required)
        :type set: bool
        :param x_frankie_customer_child_id: If, as a Frankie Customer, you are acting on behalf of your own customers, then you can populate this field with a Frankie-assigned ID.  Note: If using a CustomerChildID, you will also need a separate api_key for each child.  Any documents, checks, entities that are created when this field has been populated will now be tied to this CustomerID + CustomerChildID combination. Just as Customers cannot see data created by other Customers, so too a Customer's Children will not be able to see each other's data.  A Customer can see the documents/entities and checks of all their Children. 
        :type x_frankie_customer_child_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._flag_duplicate_entity_serialize(
            x_frankie_customer_id=x_frankie_customer_id,
            entity_id=entity_id,
            other_id=other_id,
            set=set,
            x_frankie_customer_child_id=x_frankie_customer_child_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "EntityResultObject",
            '400': "ErrorObject",
            '401': "ErrorObject",
            '404': "ErrorObject",
            '429': "ErrorObject",
            '500': "ErrorObject",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def flag_duplicate_entity_without_preload_content(
        self,
        x_frankie_customer_id: Annotated[StrictStr, Field(description="Customer ID issued by Frankie Financial. This will never change. Your API key, which is mapped to this identity, will change over time. ")],
        entity_id: Annotated[StrictStr, Field(description="The entityId returned previously from an earlier call to /check or /entity")],
        other_id: Annotated[StrictStr, Field(description="An entityId returned previously from an earlier call to /check or /entity. Used when an operation requires two entityIds")],
        set: Annotated[StrictBool, Field(description="Set the value of an entity flag. ")],
        x_frankie_customer_child_id: Annotated[Optional[StrictStr], Field(description="If, as a Frankie Customer, you are acting on behalf of your own customers, then you can populate this field with a Frankie-assigned ID.  Note: If using a CustomerChildID, you will also need a separate api_key for each child.  Any documents, checks, entities that are created when this field has been populated will now be tied to this CustomerID + CustomerChildID combination. Just as Customers cannot see data created by other Customers, so too a Customer's Children will not be able to see each other's data.  A Customer can see the documents/entities and checks of all their Children. ")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Resolve Duplicate States.

        Resolve the state of a pair of duplicate entities with the '?set=' query parameter as 'true' or 'false'. Setting duplicate to 'true' will make entityId invisible for most purposes and otherId will continue to function as normal. Setting duplicate to 'false' means the two entities are in fact separate but similar and they will both continue to exist independently but will no longer be identified as duplicates of eachother. 

        :param x_frankie_customer_id: Customer ID issued by Frankie Financial. This will never change. Your API key, which is mapped to this identity, will change over time.  (required)
        :type x_frankie_customer_id: str
        :param entity_id: The entityId returned previously from an earlier call to /check or /entity (required)
        :type entity_id: str
        :param other_id: An entityId returned previously from an earlier call to /check or /entity. Used when an operation requires two entityIds (required)
        :type other_id: str
        :param set: Set the value of an entity flag.  (required)
        :type set: bool
        :param x_frankie_customer_child_id: If, as a Frankie Customer, you are acting on behalf of your own customers, then you can populate this field with a Frankie-assigned ID.  Note: If using a CustomerChildID, you will also need a separate api_key for each child.  Any documents, checks, entities that are created when this field has been populated will now be tied to this CustomerID + CustomerChildID combination. Just as Customers cannot see data created by other Customers, so too a Customer's Children will not be able to see each other's data.  A Customer can see the documents/entities and checks of all their Children. 
        :type x_frankie_customer_child_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._flag_duplicate_entity_serialize(
            x_frankie_customer_id=x_frankie_customer_id,
            entity_id=entity_id,
            other_id=other_id,
            set=set,
            x_frankie_customer_child_id=x_frankie_customer_child_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "EntityResultObject",
            '400': "ErrorObject",
            '401': "ErrorObject",
            '404': "ErrorObject",
            '429': "ErrorObject",
            '500': "ErrorObject",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _flag_duplicate_entity_serialize(
        self,
        x_frankie_customer_id,
        entity_id,
        other_id,
        set,
        x_frankie_customer_child_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if entity_id is not None:
            _path_params['entityId'] = entity_id
        if other_id is not None:
            _path_params['otherId'] = other_id
        # process the query parameters
        if set is not None:
            
            _query_params.append(('set', set))
            
        # process the header parameters
        if x_frankie_customer_id is not None:
            _header_params['X-Frankie-CustomerID'] = x_frankie_customer_id
        if x_frankie_customer_child_id is not None:
            _header_params['X-Frankie-CustomerChildID'] = x_frankie_customer_child_id
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'api_key'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/entity/{entityId}/flag/duplicate/{otherId}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def watchlist_entity(
        self,
        x_frankie_customer_id: Annotated[StrictStr, Field(description="Customer ID issued by Frankie Financial. This will never change. Your API key, which is mapped to this identity, will change over time. ")],
        entity_id: Annotated[StrictStr, Field(description="The entityId returned previously from an earlier call to /check or /entity")],
        set: Annotated[StrictBool, Field(description="Set the value of an entity flag. ")],
        x_frankie_customer_child_id: Annotated[Optional[StrictStr], Field(description="If, as a Frankie Customer, you are acting on behalf of your own customers, then you can populate this field with a Frankie-assigned ID.  Note: If using a CustomerChildID, you will also need a separate api_key for each child.  Any documents, checks, entities that are created when this field has been populated will now be tied to this CustomerID + CustomerChildID combination. Just as Customers cannot see data created by other Customers, so too a Customer's Children will not be able to see each other's data.  A Customer can see the documents/entities and checks of all their Children. ")] = None,
        reason: Annotated[Optional[StrictStr], Field(description="Set the reason for watchlisting. Valid values are:  - \"WAS_BLACKLISTED\" ")] = None,
        comment: Annotated[Optional[StrictStr], Field(description="A comment describing the reason for a request. ")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> EntityResultObject:
        """Set Entity Watchlist State.

        Mark the entity as watchlisted or not with the '?set=' query parameter as 'true' or 'false'. 

        :param x_frankie_customer_id: Customer ID issued by Frankie Financial. This will never change. Your API key, which is mapped to this identity, will change over time.  (required)
        :type x_frankie_customer_id: str
        :param entity_id: The entityId returned previously from an earlier call to /check or /entity (required)
        :type entity_id: str
        :param set: Set the value of an entity flag.  (required)
        :type set: bool
        :param x_frankie_customer_child_id: If, as a Frankie Customer, you are acting on behalf of your own customers, then you can populate this field with a Frankie-assigned ID.  Note: If using a CustomerChildID, you will also need a separate api_key for each child.  Any documents, checks, entities that are created when this field has been populated will now be tied to this CustomerID + CustomerChildID combination. Just as Customers cannot see data created by other Customers, so too a Customer's Children will not be able to see each other's data.  A Customer can see the documents/entities and checks of all their Children. 
        :type x_frankie_customer_child_id: str
        :param reason: Set the reason for watchlisting. Valid values are:  - \"WAS_BLACKLISTED\" 
        :type reason: str
        :param comment: A comment describing the reason for a request. 
        :type comment: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._watchlist_entity_serialize(
            x_frankie_customer_id=x_frankie_customer_id,
            entity_id=entity_id,
            set=set,
            x_frankie_customer_child_id=x_frankie_customer_child_id,
            reason=reason,
            comment=comment,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "EntityResultObject",
            '400': "ErrorObject",
            '401': "ErrorObject",
            '404': "ErrorObject",
            '429': "ErrorObject",
            '500': "ErrorObject",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def watchlist_entity_with_http_info(
        self,
        x_frankie_customer_id: Annotated[StrictStr, Field(description="Customer ID issued by Frankie Financial. This will never change. Your API key, which is mapped to this identity, will change over time. ")],
        entity_id: Annotated[StrictStr, Field(description="The entityId returned previously from an earlier call to /check or /entity")],
        set: Annotated[StrictBool, Field(description="Set the value of an entity flag. ")],
        x_frankie_customer_child_id: Annotated[Optional[StrictStr], Field(description="If, as a Frankie Customer, you are acting on behalf of your own customers, then you can populate this field with a Frankie-assigned ID.  Note: If using a CustomerChildID, you will also need a separate api_key for each child.  Any documents, checks, entities that are created when this field has been populated will now be tied to this CustomerID + CustomerChildID combination. Just as Customers cannot see data created by other Customers, so too a Customer's Children will not be able to see each other's data.  A Customer can see the documents/entities and checks of all their Children. ")] = None,
        reason: Annotated[Optional[StrictStr], Field(description="Set the reason for watchlisting. Valid values are:  - \"WAS_BLACKLISTED\" ")] = None,
        comment: Annotated[Optional[StrictStr], Field(description="A comment describing the reason for a request. ")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[EntityResultObject]:
        """Set Entity Watchlist State.

        Mark the entity as watchlisted or not with the '?set=' query parameter as 'true' or 'false'. 

        :param x_frankie_customer_id: Customer ID issued by Frankie Financial. This will never change. Your API key, which is mapped to this identity, will change over time.  (required)
        :type x_frankie_customer_id: str
        :param entity_id: The entityId returned previously from an earlier call to /check or /entity (required)
        :type entity_id: str
        :param set: Set the value of an entity flag.  (required)
        :type set: bool
        :param x_frankie_customer_child_id: If, as a Frankie Customer, you are acting on behalf of your own customers, then you can populate this field with a Frankie-assigned ID.  Note: If using a CustomerChildID, you will also need a separate api_key for each child.  Any documents, checks, entities that are created when this field has been populated will now be tied to this CustomerID + CustomerChildID combination. Just as Customers cannot see data created by other Customers, so too a Customer's Children will not be able to see each other's data.  A Customer can see the documents/entities and checks of all their Children. 
        :type x_frankie_customer_child_id: str
        :param reason: Set the reason for watchlisting. Valid values are:  - \"WAS_BLACKLISTED\" 
        :type reason: str
        :param comment: A comment describing the reason for a request. 
        :type comment: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._watchlist_entity_serialize(
            x_frankie_customer_id=x_frankie_customer_id,
            entity_id=entity_id,
            set=set,
            x_frankie_customer_child_id=x_frankie_customer_child_id,
            reason=reason,
            comment=comment,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "EntityResultObject",
            '400': "ErrorObject",
            '401': "ErrorObject",
            '404': "ErrorObject",
            '429': "ErrorObject",
            '500': "ErrorObject",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def watchlist_entity_without_preload_content(
        self,
        x_frankie_customer_id: Annotated[StrictStr, Field(description="Customer ID issued by Frankie Financial. This will never change. Your API key, which is mapped to this identity, will change over time. ")],
        entity_id: Annotated[StrictStr, Field(description="The entityId returned previously from an earlier call to /check or /entity")],
        set: Annotated[StrictBool, Field(description="Set the value of an entity flag. ")],
        x_frankie_customer_child_id: Annotated[Optional[StrictStr], Field(description="If, as a Frankie Customer, you are acting on behalf of your own customers, then you can populate this field with a Frankie-assigned ID.  Note: If using a CustomerChildID, you will also need a separate api_key for each child.  Any documents, checks, entities that are created when this field has been populated will now be tied to this CustomerID + CustomerChildID combination. Just as Customers cannot see data created by other Customers, so too a Customer's Children will not be able to see each other's data.  A Customer can see the documents/entities and checks of all their Children. ")] = None,
        reason: Annotated[Optional[StrictStr], Field(description="Set the reason for watchlisting. Valid values are:  - \"WAS_BLACKLISTED\" ")] = None,
        comment: Annotated[Optional[StrictStr], Field(description="A comment describing the reason for a request. ")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Set Entity Watchlist State.

        Mark the entity as watchlisted or not with the '?set=' query parameter as 'true' or 'false'. 

        :param x_frankie_customer_id: Customer ID issued by Frankie Financial. This will never change. Your API key, which is mapped to this identity, will change over time.  (required)
        :type x_frankie_customer_id: str
        :param entity_id: The entityId returned previously from an earlier call to /check or /entity (required)
        :type entity_id: str
        :param set: Set the value of an entity flag.  (required)
        :type set: bool
        :param x_frankie_customer_child_id: If, as a Frankie Customer, you are acting on behalf of your own customers, then you can populate this field with a Frankie-assigned ID.  Note: If using a CustomerChildID, you will also need a separate api_key for each child.  Any documents, checks, entities that are created when this field has been populated will now be tied to this CustomerID + CustomerChildID combination. Just as Customers cannot see data created by other Customers, so too a Customer's Children will not be able to see each other's data.  A Customer can see the documents/entities and checks of all their Children. 
        :type x_frankie_customer_child_id: str
        :param reason: Set the reason for watchlisting. Valid values are:  - \"WAS_BLACKLISTED\" 
        :type reason: str
        :param comment: A comment describing the reason for a request. 
        :type comment: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._watchlist_entity_serialize(
            x_frankie_customer_id=x_frankie_customer_id,
            entity_id=entity_id,
            set=set,
            x_frankie_customer_child_id=x_frankie_customer_child_id,
            reason=reason,
            comment=comment,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "EntityResultObject",
            '400': "ErrorObject",
            '401': "ErrorObject",
            '404': "ErrorObject",
            '429': "ErrorObject",
            '500': "ErrorObject",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _watchlist_entity_serialize(
        self,
        x_frankie_customer_id,
        entity_id,
        set,
        x_frankie_customer_child_id,
        reason,
        comment,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if entity_id is not None:
            _path_params['entityId'] = entity_id
        # process the query parameters
        if set is not None:
            
            _query_params.append(('set', set))
            
        if reason is not None:
            
            _query_params.append(('reason', reason))
            
        if comment is not None:
            
            _query_params.append(('comment', comment))
            
        # process the header parameters
        if x_frankie_customer_id is not None:
            _header_params['X-Frankie-CustomerID'] = x_frankie_customer_id
        if x_frankie_customer_child_id is not None:
            _header_params['X-Frankie-CustomerChildID'] = x_frankie_customer_child_id
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'api_key'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/entity/{entityId}/flag/watchlist',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )


