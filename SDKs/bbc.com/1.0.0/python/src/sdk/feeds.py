import requests
from typing import Any,Optional
from sdk.models import shared, operations
from . import utils

class Feeds:
    _client: requests.Session
    _security_client: requests.Session
    _server_url: str
    _language: str
    _sdk_version: str
    _gen_version: str

    def __init__(self, client: requests.Session, security_client: requests.Session, server_url: str, language: str, sdk_version: str, gen_version: str) -> None:
        self._client = client
        self._security_client = security_client
        self._server_url = server_url
        self._language = language
        self._sdk_version = sdk_version
        self._gen_version = gen_version

    
    def list_availability(self, request: operations.ListAvailabilityRequest) -> operations.ListAvailabilityResponse:
        r"""Discover details of on-demand availability for programmes and their versions
        Discover details of on-demand availability for programmes and their versions
        """
        
        base_url = self._server_url
        
        url = base_url.removesuffix("/") + "/availabilities"
        
        query_params = utils.get_query_params(request.query_params)
        
        client = self._security_client
        
        r = client.request("GET", url, params=query_params)
        content_type = r.headers.get("Content-Type")

        res = operations.ListAvailabilityResponse(status_code=r.status_code, content_type=content_type)
        
        if r.status_code == 200:
            if utils.match_content_type(content_type, "application/json"):
                out = utils.unmarshal_json(r.text, Optional[Any])
                res.nitro = out
            if utils.match_content_type(content_type, "application/xml"):
                res.body = r.content
        else:
            if utils.match_content_type(content_type, "application/xml"):
                res.body = r.content
            if utils.match_content_type(content_type, "application/json"):
                out = utils.unmarshal_json(r.text, Optional[shared.ErrorModel])
                res.error_model = out

        return res

    
    def list_broadcasts(self, request: operations.ListBroadcastsRequest) -> operations.ListBroadcastsResponse:
        r"""Build schedules and find metadata for TV and radio broadcasts
        Fetch metadata about linear Broadcasts and Services, allowing the generation of Television and Radio schedules and other datasets for broadcast items. Use /schedules instead of this feed as it is more efficient. Broadcasts will be deprecated in the future.
        """
        
        base_url = self._server_url
        
        url = base_url.removesuffix("/") + "/broadcasts"
        
        query_params = utils.get_query_params(request.query_params)
        
        client = self._security_client
        
        r = client.request("GET", url, params=query_params)
        content_type = r.headers.get("Content-Type")

        res = operations.ListBroadcastsResponse(status_code=r.status_code, content_type=content_type)
        
        if r.status_code == 200:
            if utils.match_content_type(content_type, "application/json"):
                out = utils.unmarshal_json(r.text, Optional[Any])
                res.nitro = out
            if utils.match_content_type(content_type, "application/xml"):
                res.body = r.content
        else:
            if utils.match_content_type(content_type, "application/xml"):
                res.body = r.content
            if utils.match_content_type(content_type, "application/json"):
                out = utils.unmarshal_json(r.text, Optional[shared.ErrorModel])
                res.error_model = out

        return res

    
    def list_groups(self, request: operations.ListGroupsRequest) -> operations.ListGroupsResponse:
        r"""Find metadata for curated groups: seasons, collections, galleries or franchises
        Long-lived curated collections of programmes and more, including Collections, Seasons, Franchises and Galleries
        """
        
        base_url = self._server_url
        
        url = base_url.removesuffix("/") + "/groups"
        
        query_params = utils.get_query_params(request.query_params)
        
        client = self._security_client
        
        r = client.request("GET", url, params=query_params)
        content_type = r.headers.get("Content-Type")

        res = operations.ListGroupsResponse(status_code=r.status_code, content_type=content_type)
        
        if r.status_code == 200:
            if utils.match_content_type(content_type, "application/json"):
                out = utils.unmarshal_json(r.text, Optional[Any])
                res.nitro = out
            if utils.match_content_type(content_type, "application/xml"):
                res.body = r.content
        else:
            if utils.match_content_type(content_type, "application/xml"):
                res.body = r.content
            if utils.match_content_type(content_type, "application/json"):
                out = utils.unmarshal_json(r.text, Optional[shared.ErrorModel])
                res.error_model = out

        return res

    
    def list_images(self, request: operations.ListImagesRequest) -> operations.ListImagesResponse:
        r"""Find metadata for images
        Find metadata for images, particularly those in galleries
        """
        
        base_url = self._server_url
        
        url = base_url.removesuffix("/") + "/images"
        
        query_params = utils.get_query_params(request.query_params)
        
        client = self._security_client
        
        r = client.request("GET", url, params=query_params)
        content_type = r.headers.get("Content-Type")

        res = operations.ListImagesResponse(status_code=r.status_code, content_type=content_type)
        
        if r.status_code == 200:
            if utils.match_content_type(content_type, "application/json"):
                out = utils.unmarshal_json(r.text, Optional[Any])
                res.nitro = out
            if utils.match_content_type(content_type, "application/xml"):
                res.body = r.content
        else:
            if utils.match_content_type(content_type, "application/xml"):
                res.body = r.content
            if utils.match_content_type(content_type, "application/json"):
                out = utils.unmarshal_json(r.text, Optional[shared.ErrorModel])
                res.error_model = out

        return res

    
    def list_items(self, request: operations.ListItemsRequest) -> operations.ListItemsResponse:
        r"""Look inside programmes to find segments: chapters, tracks and more
        Look inside programmes to find segments: chapters, tracks and more
        """
        
        base_url = self._server_url
        
        url = base_url.removesuffix("/") + "/items"
        
        query_params = utils.get_query_params(request.query_params)
        
        client = self._security_client
        
        r = client.request("GET", url, params=query_params)
        content_type = r.headers.get("Content-Type")

        res = operations.ListItemsResponse(status_code=r.status_code, content_type=content_type)
        
        if r.status_code == 200:
            if utils.match_content_type(content_type, "application/json"):
                out = utils.unmarshal_json(r.text, Optional[Any])
                res.nitro = out
            if utils.match_content_type(content_type, "application/xml"):
                res.body = r.content
        else:
            if utils.match_content_type(content_type, "application/xml"):
                res.body = r.content
            if utils.match_content_type(content_type, "application/json"):
                out = utils.unmarshal_json(r.text, Optional[shared.ErrorModel])
                res.error_model = out

        return res

    
    def list_masterbrands(self, request: operations.ListMasterbrandsRequest) -> operations.ListMasterbrandsResponse:
        r"""List all Master Brands
        List all Master Brands
        """
        
        base_url = self._server_url
        
        url = base_url.removesuffix("/") + "/master_brands"
        
        query_params = utils.get_query_params(request.query_params)
        
        client = self._security_client
        
        r = client.request("GET", url, params=query_params)
        content_type = r.headers.get("Content-Type")

        res = operations.ListMasterbrandsResponse(status_code=r.status_code, content_type=content_type)
        
        if r.status_code == 200:
            if utils.match_content_type(content_type, "application/json"):
                out = utils.unmarshal_json(r.text, Optional[Any])
                res.nitro = out
            if utils.match_content_type(content_type, "application/xml"):
                res.body = r.content
        else:
            if utils.match_content_type(content_type, "application/xml"):
                res.body = r.content
            if utils.match_content_type(content_type, "application/json"):
                out = utils.unmarshal_json(r.text, Optional[shared.ErrorModel])
                res.error_model = out

        return res

    
    def list_people(self, request: operations.ListPeopleRequest) -> operations.ListPeopleResponse:
        r"""Find the people behind and in programmes: cast, crew, guests and more
        The People feed allows you to search for the people and groups that contribute to programmes. This is the starting point for cast and crew credits, as well as finding contributors using external IDs (such as Wikipedia URLs)
        """
        
        base_url = self._server_url
        
        url = base_url.removesuffix("/") + "/people"
        
        query_params = utils.get_query_params(request.query_params)
        
        client = self._security_client
        
        r = client.request("GET", url, params=query_params)
        content_type = r.headers.get("Content-Type")

        res = operations.ListPeopleResponse(status_code=r.status_code, content_type=content_type)
        
        if r.status_code == 200:
            if utils.match_content_type(content_type, "application/json"):
                out = utils.unmarshal_json(r.text, Optional[Any])
                res.nitro = out
            if utils.match_content_type(content_type, "application/xml"):
                res.body = r.content
        else:
            if utils.match_content_type(content_type, "application/xml"):
                res.body = r.content
            if utils.match_content_type(content_type, "application/json"):
                out = utils.unmarshal_json(r.text, Optional[shared.ErrorModel])
                res.error_model = out

        return res

    
    def list_pips(self, request: operations.ListPipsRequest) -> operations.ListPipsResponse:
        r"""Look inside pips entities
        Look inside pips entities
        """
        
        base_url = self._server_url
        
        url = base_url.removesuffix("/") + "/pips"
        
        query_params = utils.get_query_params(request.query_params)
        
        client = self._security_client
        
        r = client.request("GET", url, params=query_params)
        content_type = r.headers.get("Content-Type")

        res = operations.ListPipsResponse(status_code=r.status_code, content_type=content_type)
        
        if r.status_code == 200:
            if utils.match_content_type(content_type, "application/json"):
                out = utils.unmarshal_json(r.text, Optional[Any])
                res.nitro = out
            if utils.match_content_type(content_type, "application/xml"):
                res.body = r.content
        else:
            if utils.match_content_type(content_type, "application/xml"):
                res.body = r.content
            if utils.match_content_type(content_type, "application/json"):
                out = utils.unmarshal_json(r.text, Optional[shared.ErrorModel])
                res.error_model = out

        return res

    
    def list_programme_details(self, request: operations.ListProgrammeDetailsRequest) -> operations.ListProgrammeDetailsResponse:
        r"""Exposes programme information for a single pid
        Exposes programme information for a single pid
        """
        
        base_url = self._server_url
        
        url = base_url.removesuffix("/") + "/programme_details"
        
        query_params = utils.get_query_params(request.query_params)
        
        client = self._security_client
        
        r = client.request("GET", url, params=query_params)
        content_type = r.headers.get("Content-Type")

        res = operations.ListProgrammeDetailsResponse(status_code=r.status_code, content_type=content_type)
        
        if r.status_code == 200:
            if utils.match_content_type(content_type, "application/json"):
                out = utils.unmarshal_json(r.text, Optional[Any])
                res.nitro = out
            if utils.match_content_type(content_type, "application/xml"):
                res.body = r.content
        else:
            if utils.match_content_type(content_type, "application/xml"):
                res.body = r.content
            if utils.match_content_type(content_type, "application/json"):
                out = utils.unmarshal_json(r.text, Optional[shared.ErrorModel])
                res.error_model = out

        return res

    
    def list_programmes(self, request: operations.ListProgrammesRequest) -> operations.ListProgrammesResponse:
        r"""Start here for programmes metadata: Brands, Series, Episodes and Clips
        Fetch metadata about Programmes (brands, series, episodes, clips). By applying different filter restrictions this feed can be used in many ways, for example to retrieve all series belonging to a brand, all the episodes and/or clips for a specific series, or any TLEO objects for a masterbrand. Other filters permit restricting to specific formats and/or genres, and you can request specific versions (for example Signed or Audio-Described). Parameters may be combined in any way suitable for your application.
        """
        
        base_url = self._server_url
        
        url = base_url.removesuffix("/") + "/programmes"
        
        query_params = utils.get_query_params(request.query_params)
        
        client = self._security_client
        
        r = client.request("GET", url, params=query_params)
        content_type = r.headers.get("Content-Type")

        res = operations.ListProgrammesResponse(status_code=r.status_code, content_type=content_type)
        
        if r.status_code == 200:
            if utils.match_content_type(content_type, "application/json"):
                out = utils.unmarshal_json(r.text, Optional[Any])
                res.nitro = out
            if utils.match_content_type(content_type, "application/xml"):
                res.body = r.content
        else:
            if utils.match_content_type(content_type, "application/xml"):
                res.body = r.content
            if utils.match_content_type(content_type, "application/json"):
                out = utils.unmarshal_json(r.text, Optional[shared.ErrorModel])
                res.error_model = out

        return res

    
    def list_promotions(self, request: operations.ListPromotionsRequest) -> operations.ListPromotionsResponse:
        r"""Discover metadata for content promotions
        Details of short-term editorially curated \"promotions\", for instance those programmes featured on iPlayer today
        """
        
        base_url = self._server_url
        
        url = base_url.removesuffix("/") + "/promotions"
        
        query_params = utils.get_query_params(request.query_params)
        
        client = self._security_client
        
        r = client.request("GET", url, params=query_params)
        content_type = r.headers.get("Content-Type")

        res = operations.ListPromotionsResponse(status_code=r.status_code, content_type=content_type)
        
        if r.status_code == 200:
            if utils.match_content_type(content_type, "application/json"):
                out = utils.unmarshal_json(r.text, Optional[Any])
                res.nitro = out
            if utils.match_content_type(content_type, "application/xml"):
                res.body = r.content
        else:
            if utils.match_content_type(content_type, "application/xml"):
                res.body = r.content
            if utils.match_content_type(content_type, "application/json"):
                out = utils.unmarshal_json(r.text, Optional[shared.ErrorModel])
                res.error_model = out

        return res

    
    def list_schedules(self, request: operations.ListSchedulesRequest) -> operations.ListSchedulesResponse:
        r"""Build schedules and find metadata for TV and radio broadcasts and webcasts
        Dates, Times, Schedules: when and where are programmes being shown?
        """
        
        base_url = self._server_url
        
        url = base_url.removesuffix("/") + "/schedules"
        
        query_params = utils.get_query_params(request.query_params)
        
        client = self._security_client
        
        r = client.request("GET", url, params=query_params)
        content_type = r.headers.get("Content-Type")

        res = operations.ListSchedulesResponse(status_code=r.status_code, content_type=content_type)
        
        if r.status_code == 200:
            if utils.match_content_type(content_type, "application/json"):
                out = utils.unmarshal_json(r.text, Optional[Any])
                res.nitro = out
            if utils.match_content_type(content_type, "application/xml"):
                res.body = r.content
        else:
            if utils.match_content_type(content_type, "application/xml"):
                res.body = r.content
            if utils.match_content_type(content_type, "application/json"):
                out = utils.unmarshal_json(r.text, Optional[shared.ErrorModel])
                res.error_model = out

        return res

    
    def list_services(self, request: operations.ListServicesRequest) -> operations.ListServicesResponse:
        r"""Information about the linear services used for broadcast transmissions
        The services feed exposes the linear broadcast \"services\" from PIPs. These are the actual services which broadcast programmes (eg bbc_one_oxford is the service for BBC One in Oxford).
        """
        
        base_url = self._server_url
        
        url = base_url.removesuffix("/") + "/services"
        
        query_params = utils.get_query_params(request.query_params)
        
        client = self._security_client
        
        r = client.request("GET", url, params=query_params)
        content_type = r.headers.get("Content-Type")

        res = operations.ListServicesResponse(status_code=r.status_code, content_type=content_type)
        
        if r.status_code == 200:
            if utils.match_content_type(content_type, "application/json"):
                out = utils.unmarshal_json(r.text, Optional[Any])
                res.nitro = out
            if utils.match_content_type(content_type, "application/xml"):
                res.body = r.content
        else:
            if utils.match_content_type(content_type, "application/xml"):
                res.body = r.content
            if utils.match_content_type(content_type, "application/json"):
                out = utils.unmarshal_json(r.text, Optional[shared.ErrorModel])
                res.error_model = out

        return res

    
    def list_versions(self, request: operations.ListVersionsRequest) -> operations.ListVersionsResponse:
        r"""Metadata on editorial programme versions: original, signed, audio-described, etc
        The versions feed exposes editorial \"Versions\" of programmes. These are concepts used to capture different presentations of an overall programme: for example, versions of a programme may include one with sign language, one with audio description, one edited for content and more. Versions are also important to understand for broadcasts: a linear broadcast or an ondemand is always of a specific version, not merely of a programme.
        """
        
        base_url = self._server_url
        
        url = base_url.removesuffix("/") + "/versions"
        
        query_params = utils.get_query_params(request.query_params)
        
        client = self._security_client
        
        r = client.request("GET", url, params=query_params)
        content_type = r.headers.get("Content-Type")

        res = operations.ListVersionsResponse(status_code=r.status_code, content_type=content_type)
        
        if r.status_code == 200:
            if utils.match_content_type(content_type, "application/json"):
                out = utils.unmarshal_json(r.text, Optional[Any])
                res.nitro = out
            if utils.match_content_type(content_type, "application/xml"):
                res.body = r.content
        else:
            if utils.match_content_type(content_type, "application/xml"):
                res.body = r.content
            if utils.match_content_type(content_type, "application/json"):
                out = utils.unmarshal_json(r.text, Optional[shared.ErrorModel])
                res.error_model = out

        return res

    